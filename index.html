<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeepStability - A Database of Numerical Methods for Deep Learning</title>
    <link href="https://fonts.googleapis.com/css2?family=Caveat&family=Montserrat:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="css/styles.css">
    <!-- <img src="images/graphic.png"> -->
  </head>
  <body>
    <main>
      <header>
        <div class="content-wrapper">
          <h1>DeepStability</h1>
          <h2>A Database of Numerical Stability Vulnerabilities of Common Numerical Methods in Deep Learning</h2>
        </div>
      </header>
      <div class="wrapper">
          <div class="content">
            <style type="text/css">
                .tg  {border-collapse:collapse;border-spacing:0;}
                .tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
                  overflow:hidden;padding:10px 5px;word-break:normal;}
                .tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
                  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
                .tg .tg-1wig{font-weight:bold;text-align:left;vertical-align:top}
                .tg .tg-0lax{text-align:left;vertical-align:top}
                </style>
                <table class="tg">
                <thead>
                  <tr>
                    <th class="tg-1wig">Index</th>
                    <th class="tg-1wig">Library</th>
                    <th class="tg-1wig">Commit hash</th>
                    <th class="tg-1wig">Language</th>
                    <th class="tg-1wig">Type of commit</th>
                    <th class="tg-1wig">Root Cause</th>
                    <th class="tg-1wig">Manifestation/End User Impact</th>
                    <th class="tg-1wig">IEEE arithmetic exception type</th>
                    <th class="tg-1wig">Background</th>
                    <th class="tg-1wig">Problem</th>
                    <th class="tg-1wig">DL Topic - level 1</th>
                    <th class="tg-1wig">DL Topic - level 2</th>
                    <th class="tg-1wig">DL Topic - level 3</th>
                    <th class="tg-1wig">Patch type - level 1</th>
                    <th class="tg-1wig">Patch type - level 2</th>
                    <th class="tg-1wig">Patch type - level 3</th>
                    <th class="tg-1wig">Old Solution</th>
                    <th class="tg-1wig">New Solution</th>
                    <th class="tg-1wig">Test</th>
                    <th class="tg-1wig">Math operation</th>
                    <th class="tg-1wig">References</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="tg-0lax">1</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">ac72881f3ff8c46c2a5cf8b09d02babf46bc4c85</td>
                    <td class="tg-0lax">CUDA</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">loss of precision</td>
                    <td class="tg-0lax">inaccurate result of mean in batch normalization</td>
                    <td class="tg-0lax">Inexact</td>
                    <td class="tg-0lax">Sync batch norm applies Batch Normalization over a N-Dimensional input (a mini-batch of [N-2]D inputs with additional channel dimension)<br>y = ((x - E[x])/sqrt(Var[x] + epsilon)) * alpha + beta</td>
                    <td class="tg-0lax">numerical issue in CUDA channels-last SyncBatchNorm, numerical issue of CUDA channels-last SyncBatchNorm', apex SBN channels-last also has this issue</td>
                    <td class="tg-0lax">data processing</td>
                    <td class="tg-0lax">batch normalization</td>
                    <td class="tg-0lax">batch normalization, Cuda</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">Replace: div_roundup() with ATenCeilDiv<br>int div_roundup(int x, int y) {<br>&nbsp;&nbsp;&nbsp;return lastPow2(1 + (x-1)/y);<br>}, where lastPow2 returns 2**floor(log2(n))<br>ATenCeilDiv(T a, T b) {<br>&nbsp;&nbsp;return (a + b - 1) / b;<br>}<br></td>
                    <td class="tg-0lax">int div_roundup(int x, int y) {<br>&nbsp;&nbsp;&nbsp;return lastPow2(1 + (x-1)/y);<br>}<br>static int lastPow2(unsigned int n) {<br>&nbsp;&nbsp;n |= (n &gt;&gt; 1);<br>&nbsp;&nbsp;n |= (n &gt;&gt; 2);<br>&nbsp;&nbsp;n |= (n &gt;&gt; 4);<br>&nbsp;&nbsp;n |= (n &gt;&gt; 8);<br>&nbsp;&nbsp;n |= (n &gt;&gt; 16);<br>&nbsp;&nbsp;return std::max&lt;int&gt;(1, n - (n &gt;&gt; 1));<br>}, where |= is a bitwise or opearator</td>
                    <td class="tg-0lax">ATenCeilDiv(T a, T b) {<br>&nbsp;&nbsp;return (a + b - 1) / b;<br>}</td>
                    <td class="tg-0lax">def _batch_norm_stats(data):<br>&nbsp;&nbsp;&nbsp;&nbsp;mean1, _ = torch.batch_norm_stats(data, 1e-5)<br>&nbsp;&nbsp;&nbsp;&nbsp;mean2, _ = torch.batch_norm_stats(data.to(memory_format=torch.channels_last), 1e-5)<br>&nbsp;&nbsp;&nbsp;&nbsp;mean_ref = torch.mean(data, (0, 2, 3), keepdim=False)<br>&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(mean_ref, mean1)<br>&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(mean_ref, mean2)</td>
                    <td class="tg-0lax">division round up</td>
                    <td class="tg-0lax">https://arxiv.org/abs/1502.03167 <br>https://pytorch.org/docs/stable/generated/torch.nn.SyncBatchNorm.html</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">2</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">dfc7fa03e5d33f909b9d7853dd001086f5d782a0</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">loss of precision</td>
                    <td class="tg-0lax">inaccurate result of gradient</td>
                    <td class="tg-0lax">Inexact</td>
                    <td class="tg-0lax">lower–upper (LU) decomposition (also called LU factorization) factors a matrix as the product of a lower triangular matrix and an upper triangular matrix. It is a procedure for decomposing an N×N matrix A into a product of a lower triangular matrix L and an upper triangular matrix U, LU=A. <br>Matrix A = LU. In the lower triangular matrix all elements above the diagonal are zero, in the upper triangular matrix, all the elements below the diagonal are zero. <br>LU decomposition is an efficient method used for solving a system of linear equations. Suppose we have B=AX and want to solve for X.&nbsp;&nbsp;(The solution could be X = inverse(A)B. But a matrix inverse is numerically unstable.) Find LU decomposition of A, A = LU. So, B=AX=LUX. Then solve for X with two equations: (1) LY = B and (2) UX = Y</td>
                    <td class="tg-0lax">Matrix inverse is numerically unstable, as a result numerical and analytical gradients for LU decomposition are too different.<br><br>gradients for the LU decomposition calculation&nbsp;&nbsp;is unstable, lu_backward is impelemented as autograd<br>torch.det is using LU in forward, while det_backward is using svd_backward (singular value decomposition).<br>The issue with svd_backward is that it is only stable for inputs with distinct singular values. As a result, TestGradientsCuda::test_fn_gradgrad_linalg_det_cuda_float64 fails on Windows with GPU, which compares the numerical and analytical gradient. SVD_backward is only stable for ranks n - 1 &lt;= r &lt;= n with singular values sufficiently far away from each other. </td>
                    <td class="tg-0lax">gradients/derivatives</td>
                    <td class="tg-0lax">automatic differentiation</td>
                    <td class="tg-0lax">gradients for the LU decomposition, backward pass, autograd, linear algebra operations, determinant of a square matrix</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Replace matrix inverse with solutions to systems of linear triangular equations. System of "triangular" equations&nbsp;&nbsp;refers to the equations having the form of a triangle, because of the lower equations containing only the later variables.<br>However, works only for square matrices of full rank</td>
                    <td class="tg-0lax">-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I = LU_grad.new_zeros(LU_grad.shape)<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I.diagonal(dim1=-2, dim2=-1).fill_(1)<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lt_inv = torch.triangular_solve(I, L, upper=False).solution.transpose(-1, -2)<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ut_inv = torch.triangular_solve(I, U, upper=True).solution.transpose(-1, -2)<br>-<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phi_L = (L.transpose(-1, -2) @ LU_grad).tril_()<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phi_U = (LU_grad @ U.transpose(-1, -2)).triu_()<br>-<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self_grad_perturbed = Lt_inv @ (phi_L + phi_U) @ Ut_inv<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return P @ self_grad_perturbed, None, None<br></td>
                    <td class="tg-0lax">phi_L = (L.transpose(-1, -2).conj() @ LU_grad).tril_()<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phi_U = (LU_grad @ U.transpose(-1, -2).conj()).triu_()<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phi = phi_L + phi_U<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X = torch.triangular_solve(phi, L.transpose(-1, -2).conj(), upper=True).solution<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A_grad = torch.triangular_solve(X.transpose(-1, -2).conj() @ P.transpose(-1, -2), U, upper=True) \<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.solution.transpose(-1, -2).conj()<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return A_grad, None, None<br></td>
                    <td class="tg-0lax">def sample_inputs_lu(op_info, device, dtype, requires_grad=False):<br>+&nbsp;&nbsp;&nbsp;&nbsp;# not needed once OpInfo tests support Iterables<br>+&nbsp;&nbsp;&nbsp;&nbsp;def generate_samples():<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;batch_shapes = ((), (3,), (3, 3))<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for batch_shape, get_infos in product(batch_shapes, (True, False)):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shape = batch_shape + (S, S)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input = make_tensor(shape, device, dtype, requires_grad=requires_grad, low=None, high=None)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield SampleInput(input, args=(True, get_infos))<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;return list(generate_samples())</td>
                    <td class="tg-0lax">matrix inverse, autograd</td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">3</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">8e507ad00ebdfd0ae84bc03718e9c2cb74b8573b</td>
                    <td class="tg-0lax">yaml</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">overflow, underflow, loss of precision</td>
                    <td class="tg-0lax">Inaccurate result</td>
                    <td class="tg-0lax">overflow, underflow, inexact</td>
                    <td class="tg-0lax">This script defines derivative formulas and Python signatures of methods on Variables</td>
                    <td class="tg-0lax">Division formula in backward pass is unstable, because multiply two values can lead to loss of precision. When divisor value that is squared is large or small, which results in loss of precision. For extremely large values, the divisor may overflow and will evaluate to inf. For extremely small values the divisor will underflow and will evaluate to 0.</td>
                    <td class="tg-0lax">gradients/derivatives</td>
                    <td class="tg-0lax">automatic differentiation</td>
                    <td class="tg-0lax">backward pass, autograd, division, derivative, higher order gradients</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">Instead of dividing by other squared, divide by other twice. Mathematically x / y^2 = x / y / y, but if y is a large finite precision floating point number, then by performing y^2 you may lose precision. Successive divisions achieves the same result while not losing as much precision for large values of y</td>
                    <td class="tg-0lax">other: -grad * self / (other * other)</td>
                    <td class="tg-0lax">other: -grad * (self / other) / other</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">division</td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">4</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">fe5d23cf4a9d8f673fb1bfc6e84c642fb6a23182</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">loss of precision</td>
                    <td class="tg-0lax">incorrect result and NaN</td>
                    <td class="tg-0lax">Inexact</td>
                    <td class="tg-0lax">Cosine Similarity measures the cosine of the angle between two non-zero vectors of an inner product space. This similarity measurement is particularly concerned with orientation, rather than magnitude. In short, two cosine vectors that are aligned in the same orientation will have a similarity measurement of 1, whereas two vectors aligned perpendicularly will have a similarity of 0. If two vectors are diametrically opposed, meaning they are oriented in exactly opposite directions (i.e. back-to-back), then the similarity measurement is -1. Often, however, Cosine Similarity is used in positive space, between the bounds 0 and 1. Cosine Similarity is not concerned, and does not measure, differences is magnitude (length), and is only a representation of similarities in orientation.</td>
                    <td class="tg-0lax">Cosine similarity implementation that may lose precision and return a value greater than 1.0, which is incorrect, because cosine similarity outputs are in range of -1 and 1.</td>
                    <td class="tg-0lax">distance</td>
                    <td class="tg-0lax">distance</td>
                    <td class="tg-0lax">cosine similarity distance</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">Use x / sqrt(x * x) instead of x / (sqrt(x) * sqrt(x)) followig scipy implementation</td>
                    <td class="tg-0lax">-&nbsp;&nbsp;Tensor n12 = (w1 * w2).rsqrt_().clamp_max(1.0 / eps);<br>-&nbsp;&nbsp;return w12.mul_(n12);</td>
                    <td class="tg-0lax">&nbsp;&nbsp;Tensor n12 = (w1 * w2).clamp_min_(eps * eps).sqrt_();<br>+&nbsp;&nbsp;return w12.div_(n12);<br></td>
                    <td class="tg-0lax">&nbsp;&nbsp;# Check dividing by 0.<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input1 = torch.randn(10).requires_grad_()<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input2 = torch.zeros_like(input1).requires_grad_()<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;torch.cosine_similarity(input1, input2, 0).sum().backward()<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(input1.grad, torch.zeros_like(input1))<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(input2.grad, input1 * 1e8)<br></td>
                    <td class="tg-0lax">reciprocal&nbsp;&nbsp;of square root</td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">5</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">646d25d15910dc5cc3532aebb7e8395487adad4f</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">overflow, underflow</td>
                    <td class="tg-0lax">softmax output is NaN </td>
                    <td class="tg-0lax">overflow, underflow</td>
                    <td class="tg-0lax">Softmax is a normalized exponential function that takes a vector of n real values as input and outputs a vector of n real values that represent a probability distribution and sum up to 1.&nbsp;&nbsp;In deep learning classifiers, softmax is used in the last layer, because it normalizes the output of the prior network layer, a vector with size n, to a probability distribution over n predicted output classes. </td>
                    <td class="tg-0lax">Direct calculation of the softmax function according to its definition formula&nbsp;&nbsp;is conjugate with numerical issues. Single-precision exp(x) function overflows for x &gt; 89 and underflows for x &lt; −104, and, in turn, cause NaN outputs in the na¨ıve implementations.</td>
                    <td class="tg-0lax">activation functions</td>
                    <td class="tg-0lax">activation functions</td>
                    <td class="tg-0lax">softmax, metal GPU acceleration</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Implement a tree pass softmax algorithm, see algorithm in https://arxiv.org/pdf/2001.04438.pdf</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">softmax</td>
                    <td class="tg-0lax">https://arxiv.org/pdf/2001.04438.pdf</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">6</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">a3d726ae8246371515a0f666c38668e9da7765f9</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">underflow</td>
                    <td class="tg-0lax">error due to divide by zero</td>
                    <td class="tg-0lax">invalid operation, underflow</td>
                    <td class="tg-0lax">compute the centered RMSProp, the gradient is normalized by an estimation of its variance</td>
                    <td class="tg-0lax">The denominator in centered RMSProp optimizer does not add a small epsilon as the last operation. This will not be effective af preventing underflow. Given the current formula ms + eps - mg.square, if ms and mg.square are of very similar magnitude, subtracting two similar numbers will lead to loss of significant digits, which has a risk of underflow. Because the epsilon was added to ms prior to that, it will not prevent overflow</td>
                    <td class="tg-0lax">optimizers</td>
                    <td class="tg-0lax">optimizers</td>
                    <td class="tg-0lax">centered RMSprop optimizer</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">Rewrite the order of operations. Reordered the sum (ms - mg^2 + epsilon) to add epsilon last for numerical stability both on CPU and GPU.</td>
                    <td class="tg-0lax">auto denom = ms + epsilon() - mg.square();<br><br>auto denom = epsilon.reshape(single).broadcast(bcast) + ms - mg.square().sqrt()</td>
                    <td class="tg-0lax">auto denom = (ms - mg.square()) + epsilon()<br><br>auto denom = (ms - mg.square()) + epsilon.reshape(single).broadcast(bcast)</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">7</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">6a458512c22c908b19f49262fd0f32a14425ec80</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">loss of precision</td>
                    <td class="tg-0lax">assertion error</td>
                    <td class="tg-0lax">Inexact</td>
                    <td class="tg-0lax">static _cast converts the type of variable <br> static_cast can perform conversions between pointers to related classes, not only upcasts (from pointer-to-derived to pointer-to-base), but also downcasts (from pointer-to-base to pointer-to-derived). No checks are performed during runtime to guarantee that the object being converted is in fact a full object of the destination type.</td>
                    <td class="tg-0lax">function test_computes_cubic_kernel returns an assertion error saying that input is less than 1e-5, which is untrue. The input is slightly larger: 1.0790e-05. The cause is the precision of a variable returned by a function that performs the power operation (x to the power of y).<br><br>On x86_64 a long double will utilize the x87 (the 8087 was the floating point co-processor of the 8086, now it is on the same die as modern amd64 processor) special and proprietary 80 bit float. This 80 bit floating point type is not a part of the IEEE 754 floating point standard. Even though it has more bits of precision, its lack of standardization and its niche nature means that it will often be the cause of stability issues, and is not worth using.</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">power, low level math</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">increase variable precision </td>
                    <td class="tg-0lax">Stop using long doubles, they will only cause you trouble. Instead just use the same type as the function input</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">power</td>
                    <td class="tg-0lax">https://en.wikipedia.org/wiki/X87#Performance</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">8</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">d4b5c606fc9fbd1a20b5b113b4bc831f31d889a3</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">loss of precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Dividing by a number that is squared results in dividing by a very large or small number. The square operation could overflow or underflow respectively and if that does not happen, there is a risk of loss of precision due to dividing two very different magnitudes</td>
                    <td class="tg-0lax">gradients/derivatives</td>
                    <td class="tg-0lax">gradients</td>
                    <td class="tg-0lax">gradient</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">Avoid a square value in denomator and rewrite division as (-x/y)/y instead of (-x/y^2). They are mathematically equivalent, but the first formula avoids dividing by very large or very small numbers. Proof that they are mathematically equivalent: (-x/y)/y = (-x/y)*(1/y) = -x/(y^2)</td>
                    <td class="tg-0lax">math_ops.reduce_sum(grad * math_ops.div(-x, math_ops.square(y))</td>
                    <td class="tg-0lax">math_ops.reduce_sum(grad * math_ops.div(math_ops.div(-x, y), y)</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">division</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">9</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">2411514c726f4ccd98e864e8b2e253e6df99c39d</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">loss of precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">The formula for dequantization in quantization range for multiplication is numerically unstable</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">dequantization</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite the order of operations. Specifically, rewrite q_range_min + (input_array - 1_lowest) * q_range_scale to the following: q_range_min - (q_lowest * q_range_scale + input_array * q_range_scale), which is mathematically equivalent</td>
                    <td class="tg-0lax">#define DEQUANTIZE_WITH_EIGEN(input_array, q2f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>-&nbsp;&nbsp;(q2f.range_min +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>-&nbsp;&nbsp;&nbsp;(((input_array.template cast&lt;float&gt;() - q2f.lowest_quantized())) * \<br>-&nbsp;&nbsp;&nbsp;&nbsp;q2f.range_scale));</td>
                    <td class="tg-0lax">#define DEQUANTIZE_WITH_EIGEN(input_array, q2f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>+&nbsp;&nbsp;((q2f.range_min - q2f.lowest_quantized() * q2f.range_scale) + \<br>+&nbsp;&nbsp;&nbsp;input_array.template cast&lt;float&gt;() * q2f.range_scale)</td>
                    <td class="tg-0lax">// Test for signed 32 bit.<br>+&nbsp;&nbsp;// Note that we cannot use input mins and maxes that match the range because<br>+&nbsp;&nbsp;// there are 7 too few bits of mantissa accuracy in floats to represent<br>+&nbsp;&nbsp;// 2**31-1 accurately.&nbsp;&nbsp;Also there is no good fraction to use because 2**31-1<br>+&nbsp;&nbsp;// is a mersenne prime.<br>+&nbsp;&nbsp;Tensor input32(DT_QINT32, TensorShape({input_height, input_width}));<br>+<br>+&nbsp;&nbsp;// Use a quantizer centered at 0.<br>+&nbsp;&nbsp;float input_range = 1LL &lt;&lt; 25;<br>+&nbsp;&nbsp;int64 num_levels = (1LL &lt;&lt; 32) - 1;<br>+&nbsp;&nbsp;float step_size =<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static_cast&lt;float&gt;(static_cast&lt;double&gt;(input_range) / num_levels);<br>+&nbsp;&nbsp;float q_compatible_min_value =<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roundf(-(input_range / 2.0) / step_size) * step_size;<br>+&nbsp;&nbsp;float q_compatible_max_value = q_compatible_min_value + input_range;<br>+&nbsp;&nbsp;test::FillValues&lt;qint32&gt;(&amp;input32, {-16384, 0, 16256, -13440, -13312, -13184,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14720, 14848, 14976});<br>+<br>+&nbsp;&nbsp;Tensor output32 = QuantizedTensorToFloat&lt;qint32&gt;(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input32, q_compatible_min_value, q_compatible_max_value);<br>+&nbsp;&nbsp;test::FillValues&lt;float&gt;(&amp;expected, {-128.0f, 0.0f, 127.0f, -105.0f, -104.0f,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-103.0f, 115.0f, 116.0f, 117.0f});<br>+&nbsp;&nbsp;// The quantization error in going between 1&lt;&lt;25 and 1&lt;&lt;32 levels.<br>+&nbsp;&nbsp;const double kTolerance = .5 / 128.0;<br>+&nbsp;&nbsp;test::ExpectTensorNear&lt;float&gt;(expected, output32, kTolerance);</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">10</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">43ab91118226b330be6d2274a154b98da233d879</td>
                    <td class="tg-0lax">C</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">loss of precision</td>
                    <td class="tg-0lax">Inaccurate result</td>
                    <td class="tg-0lax">Inexact</td>
                    <td class="tg-0lax">Dirichlet distribution is a family of continuous multivariate probability distributions parameterized by a vector Alpha of positive reals. It is a multivariate generalization of the beta distribution, hence its alternative name of multivariate beta distribution (MBD). Dirichlet distributions are commonly used as prior distributions in Bayesian statistics, and in fact the Dirichlet distribution is the conjugate prior of the categorical distribution and multinomial distribution.<br>In Bayesian probability theory, if the posterior distribution p(θ|x) and the prior distribution p(θ) are from the same probability distribution family, then the prior and posterior are called conjugate distributions, and the prior is the conjugate prior for the likelihood function.<br><br>The saddle point technique is a method for deriving an accurate approximation for the probability density function of the mean of a random sample. A point that is not a local extremum yet has zero gradient is called a saddle point, such point can occur in non-convex functions.</td>
                    <td class="tg-0lax">low precision of gradient approximation in Dirichlet distribution</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">distributions, Dirichlet distribution, gradient approximation</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Use Taylor expansion and Rice saddle point expansion to approximate gradient and use higher precision types for that computation</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">https://en.wikipedia.org/wiki/Dirichlet_distribution</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">11</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">ae1a972d78950abc4dab372f496914b5e78b9637</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">loss of precision</td>
                    <td class="tg-0lax">inaccurate result</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Log softmax is an activation function used in the last layer of a neural network that outputs log probabilities</td>
                    <td class="tg-0lax">loss of precision in log_softmax cpu code when inputs are big but their differences are small</td>
                    <td class="tg-0lax">activation functions</td>
                    <td class="tg-0lax">activation functions</td>
                    <td class="tg-0lax">log softmax</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">Rewrite order of operations to avoid loss of significat digits when subtracting two numbers of very similar magnitude. Change order of operations so that a large number is first subtracted by another large number before adding a small number.</td>
                    <td class="tg-0lax">tmpsum = max_input + std::log(tmpsum);<br>output_data[d * dim_stride] = input_data[d * dim_stride] - tmpsum;</td>
                    <td class="tg-0lax">tmpsum = std::log(tmpsum);<br>output_data[d * dim_stride] =<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input_data[d * dim_stride] - max_input - tmpsum;</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">log(exp(x_i)/sum(exp(x))</td>
                    <td class="tg-0lax">log, exp, division, sum</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">12</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">0c588a500b2219c028eefe595cff0829fd982f52</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">numerical stability</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">SigmoidCrossEntropyWithLogits computes sigmoid cross entropy given logits. Sigmoid cross-entropy is a Sigmoid activation plus a Cross-Entropy loss.</td>
                    <td class="tg-0lax">Using sigmoid followed by a multinomial logistic loss layer can be less stable than a single layer of sigmoid cross entropy with logits</td>
                    <td class="tg-0lax">loss functions</td>
                    <td class="tg-0lax">loss functions, activation functions</td>
                    <td class="tg-0lax">cross entropy, sigmoid</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Use a single layer of sigmoid cross entropy with logits instead. Replace sigmoid + xent loss with SigmoidCrossEntropyWithLogits. The sigmoid layer computes the multinomial logistic loss of the sigmoid of its inputs. It's conceptually identical to a sigmoid layer followed by a multinomial logistic loss layer, but provides a more numerical stable gradient.</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">13</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">3d06a1e075ef0e6f4bf862d13e83cdd4b02dbc32</td>
                    <td class="tg-0lax">Cuda</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">numerical stability</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Welford’s method is a usable single-pass method for computing the variance. It can be derived by looking at the differences between the sums of squared differences for N and N-1 samples. Algorithm:<br>variance(samples):<br>&nbsp;&nbsp;M := 0<br>&nbsp;&nbsp;S := 0<br>&nbsp;&nbsp;for k from 1 to N:<br>&nbsp;&nbsp;&nbsp;&nbsp;x := samples[k]<br>&nbsp;&nbsp;&nbsp;&nbsp;oldM := M<br>&nbsp;&nbsp;&nbsp;&nbsp;M := M + (x-M)/k<br>&nbsp;&nbsp;&nbsp;&nbsp;S := S + (x-M)*(x-oldM)<br>&nbsp;&nbsp;return S/(N-1)</td>
                    <td class="tg-0lax">THCTensor_varInnermostDim numerically unstable</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">low level tensor math, variance calculation, GPU</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Make THCTensor_varInnermostDim numerically stable using Welford's algorithm (#3425)<br>&nbsp;&nbsp;&nbsp;&nbsp;* Use Welford's algorithm when reducing along inner dimension for THCTensor's variance fn<br>&nbsp;&nbsp;&nbsp;&nbsp;* Use accreals in THCTensor's varInnermostDim<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">variance</td>
                    <td class="tg-0lax">https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">14</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">638f0b5d78fe5ff2e484dc573c35b97a4bcf4e82</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">invalid input</td>
                    <td class="tg-0lax">loss = NaN</td>
                    <td class="tg-0lax">invalid operation</td>
                    <td class="tg-0lax">Negative log likelihood loss with Poisson distribution of target. The Poisson distribution is used to model the number of events occurring within a given time interval.<br>target∼Poisson(input)loss(input,target)=input−target∗log(input)+log(target!)</td>
                    <td class="tg-0lax">log(0) = NaN in poisson negative log likelihood loss function</td>
                    <td class="tg-0lax">loss functions</td>
                    <td class="tg-0lax">loss functions</td>
                    <td class="tg-0lax">loss, poisson negative log likelihood loss</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">Add small epsilon to prevent log(0) following keras implementation, eps=1e-8</td>
                    <td class="tg-0lax"> `input - target * log(input)`. Default: True</td>
                    <td class="tg-0lax">log_input=False. Default: 1e-8<br>`input - target * log(input+eps)`. Defrue<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">log</td>
                    <td class="tg-0lax">https://pytorch.org/docs/stable/generated/torch.nn.PoissonNLLLoss.html</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">15</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">81b995514ea908b635d725e11d1b91ac7ad03eb0</td>
                    <td class="tg-0lax">C</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">precision, overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Welford’s method is a usable single-pass method for computing the variance. It can be derived by looking at the differences between the sums of squared differences for N and N-1 samples. Algorithm:<br>variance(samples):<br>&nbsp;&nbsp;M := 0<br>&nbsp;&nbsp;S := 0<br>&nbsp;&nbsp;for k from 1 to N:<br>&nbsp;&nbsp;&nbsp;&nbsp;x := samples[k]<br>&nbsp;&nbsp;&nbsp;&nbsp;oldM := M<br>&nbsp;&nbsp;&nbsp;&nbsp;M := M + (x-M)/k<br>&nbsp;&nbsp;&nbsp;&nbsp;S := S + (x-M)*(x-oldM)<br>&nbsp;&nbsp;return S/(N-1)</td>
                    <td class="tg-0lax">numerical stability of std and var of THTensor,&nbsp;&nbsp;formulas for the variance may involve sums of squares, which causes loss of precision or overflow when dealing with large values</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">low level tensor math, variance and standard deviation calculation, CPU</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Use Welford’s algorithm for better numerical stability</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">tensor = torch.FloatTensor([1.0, 2.0, 3.0])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(tensor.var(unbiased=True), 1.0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(tensor.var(unbiased=False), 2.0 / 3.0)</td>
                    <td class="tg-0lax">variance, standard deviation</td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">16</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">455038e470dd60dae45f68948ae876b1931a8bf0</td>
                    <td class="tg-0lax">Cuda</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">numerical stability</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Spatial logsoftmax computes the log of spatial softmax. Spatial softmax returns the expected pixel locations of each feature map in a CNN and hence, be better described as spatial soft argmax. It is defined in https://arxiv.org/pdf/1504.00702.pdf.<br><br>Each output channel of the softmax is a probability distribution over the location of a<br>feature in the image. To convert from this distribution to a coordinate representation<br>(fcx, fcy), the network calculates the expected image position of each feature, yielding a<br>2D coordinate for each channel.<br><br>s_cij = e^(a_cij) / sum_from_i'_to_j'(e^(a_ci'j') ), where i and j are coordinates specifing location in an image</td>
                    <td class="tg-0lax">Spatial log softmax in CUDA backend for the Neural Network Package is not stable</td>
                    <td class="tg-0lax">activation functions</td>
                    <td class="tg-0lax">activation functions</td>
                    <td class="tg-0lax">spatial log softmax, CNN</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">It appears to be reducing the sum by the maxiumum input vector at each iteration of accumulating sum. This may be to ensure that the input to exp() is not too large.</td>
                    <td class="tg-0lax">sum += THCNumerics&lt;T&gt;::exp(input[inputStartIndex + i]);<br>sum = AccumT(1) / sum;<br> output[outputIndex] = ScalarConvert&lt;AccumT, T&gt;::to(<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;THCNumerics&lt;AccumT&gt;::log(sum * THCNumerics&lt;T&gt;::exp(input[inputStartIndex + i])));</td>
                    <td class="tg-0lax">T maxInput = input[inputStartIndex];<br>+&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 1; i &lt; classSize; i++) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T value = input[inputStartIndex + i];<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxInput = THCNumerics&lt;T&gt;::ge(maxInput, value) ? maxInput : value;<br>+&nbsp;&nbsp;&nbsp;&nbsp;}<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum += THCNumerics&lt;T&gt;::exp(input[inputStartIndex + i] - maxInput);<br>+&nbsp;&nbsp;&nbsp;&nbsp;T logsum = maxInput + ScalarConvert&lt;AccumT, T&gt;::to(THCNumerics&lt;AccumT&gt;::log(sum));<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output[outputIndex] = input[inputStartIndex + i] - logsum;<br><br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">spatial logsoftmax, log, exp, scalar convert</td>
                    <td class="tg-0lax">https://arxiv.org/pdf/1504.00702.pdf</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">17</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">c010ef7f0c6d837809a7e973048afac76373e3de</td>
                    <td class="tg-0lax">Cuda</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Cuda block is a group of threads that execute the same task. CUDA blocks are grouped into a grid. A kernel (i.e.: Cuda functipn) is executed as a grid of blocks of threads.</td>
                    <td class="tg-0lax">Overflow issue in GET_BLOCKS Cuda function that returns the number of blocks used for scheduling blocks in Cuda device (i.e.: Nvidia GPU), because addition operations on N could cause an overflow for large N.</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Cuda blocks</td>
                    <td class="tg-0lax">Cuda thread scheduling</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">Rather than directly adding to N, rearrange the operations to shrink N first.</td>
                    <td class="tg-0lax">(N + CUDA_NUM_THREADS - 1) / CUDA_NUM_THREADS;</td>
                    <td class="tg-0lax">auto block_num = (N - 1) / CUDA_NUM_THREADS + 1;</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">division</td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">18</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">6be3e5d3bb00a288da51bd368c5342c8676bbcf7</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Unit test</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">One of basic units of computation in Caffe2 are the Operators. Operators in Caffe2 are kind of like functions. CAFFE (Convolutional Architecture for Fast Feature Embedding) is a deep learning framework, originally developed at University of California, Berkeley. It is open source, under a BSD license. It is written in C++, with a Python interface.</td>
                    <td class="tg-0lax">unstable formula for updating gradient and momentum for adagrad optimizer in Caffe 2 in operators test script</td>
                    <td class="tg-0lax">optimizers</td>
                    <td class="tg-0lax">optimizers</td>
                    <td class="tg-0lax">adagrad testing, optimizer, gradients, caffe2, weight decay, momentum</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">Rewrite formula, specifically change updating gradient using a temp variable (change x+= y to temp = x + y)</td>
                    <td class="tg-0lax"> grad += weight_decay * param_in_f32</td>
                    <td class="tg-0lax">grad_temp = grad + weight_decay * param_in_f32</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">19</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">0b7e8323256e56728e1ffc9ee5d701987af3d06c</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Unit test</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">The primary difference between const and constexpr variables is that the initialization of a const variable can be deferred until run time. A constexpr variable must be initialized at compile time. </td>
                    <td class="tg-0lax">signed integer overflow of variable range</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">random number generator</td>
                    <td class="tg-0lax">random number generator testing</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">increase variable precision </td>
                    <td class="tg-0lax">change type of variable range from signed to unsigned int 64 bits<br>and change type from const auto to constexpr and </td>
                    <td class="tg-0lax">const int64_t max_val = std::is_floating_point&lt;T&gt;::value ? int64_max_val : static_cast&lt;int64_t&gt;(t_max_val);<br>range = *to - from;<br>range = max_val - from + 1;</td>
                    <td class="tg-0lax">range = static_cast&lt;uint64_t&gt;(*to) - static_cast&lt;uint64_t&gt;(from);<br>range = static_cast&lt;uint64_t&gt;(max_val) - static_cast&lt;uint64_t&gt;(from) + 1;</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">20</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">470c496eb224bdd735eea1accf7269dfdd87d49f</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Cholesky inverse = Compute inverse of Hermitian positive definite matrix using Cholesky factorization<br>inverse(S) = inverse(LL*)<br></td>
                    <td class="tg-0lax">In multivariate normal distribution class, there is a function for computing the precision matrix that uses inverse, which is numerically unstable</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">multivariate normal distribution, precision matrix</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Replace the naive inverse with a cholesky decomposition to find the inverse for improved stability</td>
                    <td class="tg-0lax">-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scale_tril_inv = torch.inverse(self._unbroadcasted_scale_tril)<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return torch.matmul(scale_tril_inv.transpose(-1, -2), scale_tril_inv).expand(</td>
                    <td class="tg-0lax">identity = torch.eye(self.loc.size(-1), device=self.loc.device, dtype=self.loc.dtype)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# TODO: use cholesky_inverse when its batching is supported<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return torch.cholesky_solve(identity, self._unbroadcasted_scale_tril).expand(<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">matrix inverse</td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">21</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">071971476d7431a24e527bdc181981678055a95d</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">torch.clamp(input, min, max, *, out=None) → Tensor<br>Clamp all elements in input into the range [ min, max ].</td>
                    <td class="tg-0lax">Binomial distribution class encounters overflow when logits are large. Note: the binomial distribution is parametrized by logits</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">Binomial distribution, log probability</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">Rewrite equation for log_prob method and use a custom clamp function on logits to ensure they are of certain value. The custom clamp function works like torch.clamp, except for that it returns 0.5 when gradient = 0 and value = 0<br></td>
                    <td class="tg-0lax">-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (log_factorial_n - log_factorial_k - log_factorial_nmk +<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value * self.logits - self.total_count * torch.log1p(self.logits.exp()))</td>
                    <td class="tg-0lax">def _clamp_by_zero(x):<br>+&nbsp;&nbsp;&nbsp;&nbsp;# works like clamp(x, min=0) but has grad at 0 is 0.5<br>+&nbsp;&nbsp;&nbsp;&nbsp;return (x.clamp(min=0) + x - x.clamp(max=0)) / 2<br><br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normalize_term = (self.total_count * _clamp_by_zero(self.logits)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ self.total_count * torch.log1p(torch.exp(-torch.abs(self.logits)))<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- log_factorial_n)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return value * self.logits - log_factorial_k - log_factorial_nmk - normalize_term<br><br></td>
                    <td class="tg-0lax">def test_binomial_stable(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logits = torch.tensor([-100., 100.], dtype=torch.float)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total_count = 1.<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = torch.tensor([0., 0.], dtype=torch.float)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log_prob = Binomial(total_count, logits=logits).log_prob(x)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertTrue(torch.isfinite(log_prob).all())<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# make sure that the grad at logits=0, value=0 is 0.5<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = torch.tensor(0., requires_grad=True)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = Binomial(total_count, logits=x).log_prob(torch.tensor(0.))<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(grad(y, x)[0], torch.tensor(-0.5))<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">22</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">3dcc329746223bc24f8213ccbaa5eba09273e162</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">loss of precision</td>
                    <td class="tg-0lax">Inaccurate result</td>
                    <td class="tg-0lax">Inexact</td>
                    <td class="tg-0lax">Summation of numbers should be performed from smallest to largest to avoid loss of significant digits</td>
                    <td class="tg-0lax">Loss of precision and floating point truncation in summation formula. Summing many floating point values can lead to loss in precision if the values are different orders of magnitude.</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">summation, tensor math</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Use a tree based approach where items of similar orders of magnitude are summed together&nbsp;&nbsp;to avoid numerical instability.<br><br>This algorithm does the summation along a single axis with multiple "levels" of accumulator, each of which is designed to hold the sum of an order of magnitude more values than the previous. e.g. if there are 2^16 elements, the first level will hold the sum of 2^4 elements, and so on in increasing powers of 2: 2^4, 2^8, 2^12 and finally 2^16. This limits the differences in magnitude of the partial results being added together, and so we don't lose accuracy as the axis length increases.<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">A simplified recursive implementation would look like this:<br>+<br>+&nbsp;&nbsp;scalar_t row_sum(const scalar_t * data, int64_t n) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;// Note, in practice the chunk size can increase with n<br>+&nbsp;&nbsp;&nbsp;&nbsp;// This allows the recursion depth to be limited to O(1).<br>+&nbsp;&nbsp;&nbsp;&nbsp;constexpr int64_t min_chunk_size = 16;<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;scalar_t sum = 0;<br>+&nbsp;&nbsp;&nbsp;&nbsp;if (n &lt;= min_chunk_size) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Recursive base case, calculate a simple running sum<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int64_t i = 0; i &lt; n; ++i) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum += data[i];<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return sum;<br>+&nbsp;&nbsp;&nbsp;&nbsp;}<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;// Recursively sum larger chunks of elements<br>+&nbsp;&nbsp;&nbsp;&nbsp;const int64_t chunk_size = std::max(divup(n, min_chunk_size), min_chunk_size);<br>+&nbsp;&nbsp;&nbsp;&nbsp;for (int64_t i = 0; i &lt; n; i += chunk_size) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum += row_sum(data + i, std::min(chunk_size, n - i));<br>+&nbsp;&nbsp;&nbsp;&nbsp;}<br>+&nbsp;&nbsp;&nbsp;&nbsp;return sum;<br>+&nbsp;&nbsp;}</td>
                    <td class="tg-0lax">ASSERT_NEAR(norm_after, max_norm, 1e-6);</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">sum</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">23</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">d16c8238e164c6499714de625eb73422382e5ec1</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">overflow, underflow, loss of precision</td>
                    <td class="tg-0lax">Inaccurate result, NaN</td>
                    <td class="tg-0lax">overflow, underflow, inexact</td>
                    <td class="tg-0lax">Softmax function turns a vector of K real values into a vector of K real values that sum to 1. The input values can be positive, negative, zero, or greater than one, but the softmax transforms them into values between 0 and 1, so that they can be interpreted as probabilities. I</td>
                    <td class="tg-0lax">Implementation of softmax&nbsp;&nbsp;for certain cases (when the dim argument of softmax and axis do not equal to ndim - 1, where ndim - 1 = the last dimension) is numerically unstable. Large inputs into the exponential function will produce infinity and output of softmax becomes NaN.</td>
                    <td class="tg-0lax">activation functions</td>
                    <td class="tg-0lax">activation functions</td>
                    <td class="tg-0lax">softmax</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Transpose input to allow for using ONNX softmax numerically stable implementation</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">softmax</td>
                    <td class="tg-0lax">exp</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">24</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">b403b10ff98a6bc1a238e7ba4eee6393b6b89048</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">loss of precision</td>
                    <td class="tg-0lax">categorical cross entropy yields inacurate result</td>
                    <td class="tg-0lax">Inexact</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">When a small float is subtracted from a large float, the large float is not changing in value (as it should mathematically). logsoftmax not working for large logits, as a result nn.CrossEntropyLoss() yields incorrect results for big logits</td>
                    <td class="tg-0lax">loss functions</td>
                    <td class="tg-0lax">loss functions</td>
                    <td class="tg-0lax">logsoftmax, cross entropy loss</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">Rewrite formula considering maximum input. If we add a very small number to a large one, the small number will be ignored. Example: tmpsum = 1e8 + log(2) = 1e8. Numerically with float precision the log(2) is ignored so at the end we basically have 1e8 - (1e8 + log(2)) = 0 instead of -log(2).</td>
                    <td class="tg-0lax">[tmp_sum](Vec x) { return x - Vec(tmp_sum); }</td>
                    <td class="tg-0lax">[tmp_sum](Vec x) { return x - Vec(tmp_sum); }</td>
                    <td class="tg-0lax">def test_log_softmax(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x_small = torch.ones(1, 2, dtype=torch.float32)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x_big = x_small + 1e16<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(F.log_softmax(x_small, -1), F.log_softmax(x_big, -1))<br></td>
                    <td class="tg-0lax">log softmax</td>
                    <td class="tg-0lax">subtaction</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">25</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">f8cab38578a99ad04d23256c2da877db4814f76f</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">?</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">?</td>
                    <td class="tg-0lax">Only a positive definite matrix has a unique Cholesky factorization A = RTR, where R is upper triangular with positive diagonal elements. A positive definite matrix = symmetric matrix with all positive eigenvalues. Cholesky decomposition is roughly twice as efficient as the LU decomposition for solving systems of linear equations. A = RTR, R is called the Cholesky factor of A.</td>
                    <td class="tg-0lax">Matrix inverse triggers a cholesky error, because the matrix is not positive definite. Also, matrix inverse can cause numerical instability.</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">Gaussian distribution</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">only take inverse of a triangular matrix</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">def _precision_to_scale_tril(P):<br>+&nbsp;&nbsp;&nbsp;&nbsp;# Ref: https://nbviewer.jupyter.org/gist/fehiepsi/5ef8e09e61604f10607380467eb82006#Precision-to-scale_tril<br>+&nbsp;&nbsp;&nbsp;&nbsp;Lf = torch.cholesky(torch.flip(P, (-2, -1)))<br>+&nbsp;&nbsp;&nbsp;&nbsp;L_inv = torch.transpose(torch.flip(Lf, (-2, -1)), -2, -1)<br>+&nbsp;&nbsp;&nbsp;&nbsp;L = torch.triangular_solve(torch.eye(P.shape[-1], dtype=P.dtype, device=P.device),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L_inv, upper=False)[0]<br>+&nbsp;&nbsp;&nbsp;&nbsp;return L<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">matrix inverse</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">26</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">c1790fa202f30e3aca1d1ecb31f26e0b3bb1e69f</td>
                    <td class="tg-0lax">Cuda, C++</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">linear interpolation is a method of curve fitting using linear polynomials to construct new data points within the range of a discrete set of known data points.Parameters of lerp: a, b, t, Output: a + t (b-a), The parameter t defines where to estimate the value on the interpolated line, it is 0 at the first point and 1 and the second point. For interpolated values between the two points mu ranges between 0 and 1. https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support</td>
                    <td class="tg-0lax">unstable formula for linear interpolation</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">linear interpolation</td>
                    <td class="tg-0lax">linear interpolation</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite formula<br>// Imprecise method, which does not guarantee v = v1 when t = 1, due to floating-point arithmetic error. This method is monotonic<br>// This form may be used when the hardware has a native fused multiply-add instruction.<br>float lerp(float v0, float v1, float t) {<br>&nbsp;&nbsp;return v0 + t * (v1 - v0);<br>}<br><br>// Precise method, which guarantees v = v1 when t = 1. This method is monotonic only when v0 * v1 &lt; 0. Lerping between same values might not produce the same value<br>float lerp(float v0, float v1, float t) {<br>&nbsp;&nbsp;return (1 - t) * v0 + t * v1;<br>}</td>
                    <td class="tg-0lax">ret_val = self_val + weight_val * (end_val - self_val);<br></td>
                    <td class="tg-0lax"> ret_val = (weight_val &lt; 0.5) ?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self_val + weight_val * (end_val - self_val) : end_val - (end_val - self_val) * (1 - weight_val);</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">a + t (b-a)</td>
                    <td class="tg-0lax">linear interpolation</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">27</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">e17b8dea1dd30bef55b314b0217f79ce22a13cf9</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">In C and C++, integer literals are interpreted as an `int` type unless specified otherwise by using a trailing L for long and LL for long long, e.g., 42 is an int, 42L is a long, 42LL is a long long. On x86_64 systems using GNU toolchains on Linux, this is 32, 64, and 64 bits respectively.<br>$ cat long.c <br>#include &lt;stdio.h&gt;<br><br>int main(void) {<br>&nbsp;&nbsp;&nbsp;&nbsp;printf("sizeof(42) = %lu\n", sizeof(42));<br>&nbsp;&nbsp;&nbsp;&nbsp;printf("sizeof(42L) = %lu\n", sizeof(42L));<br>&nbsp;&nbsp;&nbsp;&nbsp;printf("sizeof(42LL) = %lu\n", sizeof(42LL));<br>&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br>}<br>(py38) kyle@fulltower:~<br>$ gcc long.c <br>(py38) kyle@fulltower:~<br>$ ./a.out <br>sizeof(42) = 4<br>sizeof(42L) = 8<br>sizeof(42LL) = 8<br></td>
                    <td class="tg-0lax">Accumulator is overflowing because the starting value of accumulation is too small of a type (int) to accomodate the size of inputs that are common in Pytorch. Calculation of number of elements (e.g.: number of batches) overflows, because return type does not have enough precision to hold the result.</td>
                    <td class="tg-0lax">linear algebra</td>
                    <td class="tg-0lax">linear algebra</td>
                    <td class="tg-0lax">linear algebra, distance</td>
                    <td class="tg-0lax">change variable type</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">Use 64 bit type for accumulator.<br></td>
                    <td class="tg-0lax">-&nbsp;&nbsp;int64_t numel = std::accumulate(oldshape.begin(), oldshape.end(), 1,<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::multiplies&lt;int64_t&gt;());<br></td>
                    <td class="tg-0lax">const int64_t numel = prod_intlist(oldshape);</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">28</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">56840f0a81e4460089740d50d3768f37e79a17fc</td>
                    <td class="tg-0lax">Cuda</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">In binary search, the variables used to represent the indices will often be of fixed size (integers), and this can result in an arithmetic overflow for very large arrays. <br>If the midpoint of the span is calculated as (L+R)/2, then the value of L+R may exceed the range of integers of the data type used to store the midpoint, even if L and R are within the range. <br>If L and R are nonnegative, this can be avoided by calculating the midpoint as&nbsp;&nbsp;L+ ((R-L)/2)<br><br>Bucketize bucketizes 'input' based on 'boundaries'.<br><br>Summary <br>For example, if the inputs are boundaries = [0, 10, 100] input = [[-5, 10000] [150, 10] [5, 100]]<br><br>then the output will be output = [[0, 3] [3, 2] [1, 3]]</td>
                    <td class="tg-0lax">Possible overflow when adding two 32 bit ints in binary search algorithm when calculating the midpoint </td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">bucketize</td>
                    <td class="tg-0lax">binary search, bucketize operation</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">By first subtracting low from high, this assures that this intermediate calculation will not overflow its 32 bit datatype.</td>
                    <td class="tg-0lax">int32_t median = (high + low) / 2;</td>
                    <td class="tg-0lax">const int32_t median = low + (high - low) / 2;</td>
                    <td class="tg-0lax">int32_t mp1(int32_t a, int32_t b){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (a+b)/2;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;int32_t mp2(int32_t a, int32_t b){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return a+(b-a)/2;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;int main(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32_t low=-1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int32_t high=1;high&lt;10000;high++){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(mp1(low,high)!=mp2(low,high)){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&lt;&lt;"Ahhhh!"&lt;&lt;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">29</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">7f42d1c98a72855806bd35ef27ce6823837e0816</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Python "floats" are actually doubles internally</td>
                    <td class="tg-0lax">Originally a float was used, which has less precision than a double. JIT only supports double, not float. So when insertConstant, we need to cast the python `float_` to double instead of float. This will fix the incorrect `math.pi` and other high precision constants value.</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">python bindings from C++, low level math, constants</td>
                    <td class="tg-0lax">increase variable precision </td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">When converting a Pyobject representation into a C++ representation, use a double instead of a float</td>
                    <td class="tg-0lax">return toSimple(g.insertConstant(py::cast&lt;float&gt;(obj), loc));</td>
                    <td class="tg-0lax">return toSimple(g.insertConstant(py::cast&lt;double&gt;(obj), loc));</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">30</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">c784f847debc6f6a30b41da6853517b2ccd3ddf0</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">int is 32 bits on amd64/Linux/GNU. sizes and indexes should use size_t in order to use the word size of the current platform, which allows one to index as many elements as could possibly fit into memory.</td>
                    <td class="tg-0lax">sparse_adagrad param_size overflow error</td>
                    <td class="tg-0lax">optimizers</td>
                    <td class="tg-0lax">optimizers</td>
                    <td class="tg-0lax">adagrad optimizer</td>
                    <td class="tg-0lax">increase variable precision </td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">Correctly replace the data type of a size from "int" to "size_t"</td>
                    <td class="tg-0lax">int param_size<br>uint64_t idx_pref = indices[i_pref]; </td>
                    <td class="tg-0lax">size_t param_size<br>auto idx_pref = indices[i_pref]; </td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">31</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">76c1b5cd794c44e4fec8da1d87ec8f0ccc045e68</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Std::numeric_limits = way to query various properties of arithmetic types</td>
                    <td class="tg-0lax">Reusing a variable who's data type (precision) depends on the template argument.<br>Bug: caffe2/caffe2/operators/stats_put_ops.h:66:25: runtime error: 9.22337e+18 is outside the range of representable values of type 'long' . The assignment from int64_t to float loses some precision and because of that we overflow</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">external library</td>
                    <td class="tg-0lax">Caffe operators</td>
                    <td class="tg-0lax">increase variable precision </td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">increase precision computation to int 64 and as opposed to converting to int64_t at the end from float<br>add overflow safeguard using std::numeric_limits</td>
                    <td class="tg-0lax">-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input = 0;<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if (input &lt; -bound_value) {<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input = -bound_value;<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if (input &gt; bound_value) {<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input = bound_value;<br><br> <br>-&nbsp;&nbsp;&nbsp;&nbsp;int64_t int_value = input * magnitude_expand_;<br></td>
                    <td class="tg-0lax"> int_value = 0;<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if (input &lt;= -bound_value) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int_value = std::numeric_limits&lt;int64_t&gt;::min();<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if (input &gt;= bound_value) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int_value = std::numeric_limits&lt;int64_t&gt;::max();<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int_value = input * magnitude_expand_;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CAFFE_ENFORCE(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::abs(static_cast&lt;int64_t&gt;(input)) &lt; bound_value,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Input value is too large for the given magnitude expansion!");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CAFFE_ENFORCE(!isNan(input), "Input value cannot be NaN!");<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int_value = input * magnitude_expand_;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</td>
                    <td class="tg-0lax">def test_clamp_with_out_of_bounds(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;put_value = float(1e20)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;magnitude_expand = 1000000000000<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stat_name = "stat".encode('ascii')<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum_postfix = "/stat_value/sum".encode("ascii")<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count_postfix = "/stat_value/count".encode("ascii")<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;workspace.FeedBlob("value", np.array([put_value], dtype=np.float))<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;workspace.RunOperatorOnce(core.CreateOperator(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"AveragePut",<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"value",<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[],<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stat_name=stat_name,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;magnitude_expand=magnitude_expand,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bound=True))<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;workspace.RunOperatorOnce(core.CreateOperator(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'StatRegistryExport', [], ['k', 'v', 't']))<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k = workspace.FetchBlob('k')<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v = workspace.FetchBlob('v')<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stat_dict = dict(zip(k, v))<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertIn(stat_name + sum_postfix, stat_dict)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertIn(stat_name + count_postfix, stat_dict)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEquals(stat_dict[stat_name + sum_postfix],<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9223372036854775807)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEquals(stat_dict[stat_name + count_postfix], 1)<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">32</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">08b1324ec26043b1acfaf4b65335c671c8658a3c</td>
                    <td class="tg-0lax">C</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">integer overflow in remainder operator</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor math, remainder operator</td>
                    <td class="tg-0lax">rewrite math formula, add overflow check</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">The sign of the result of modulo should be the same as the denominator. This commit checks that those signs have not flipped, which would indicate an overflow. There is a bug, however, because signed overflow is undefined behavior in C, and therefore the compiler is allowed to emit any machine code for this. A compiler upgrade may break this code, or more likely, not emit machine code for this condition check, since a signed integer cannot overflow as per the standard, and thus the compiler can ignore that as a condition.</td>
                    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;TensorRemainderOp(T v) : val(v) {}<br>&nbsp;&nbsp;&nbsp;__device__ __forceinline__ void operator()(T* out, T* in) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*out = *in % val;<br>-&nbsp;&nbsp;&nbsp;&nbsp;if ((*out * val) &lt; 0){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*out += val;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br></td>
                    <td class="tg-0lax">static inline bool has_different_sign(real a, real b) {<br>+&nbsp;&nbsp;return (a &lt; 0) != (b &lt; 0);<br>+}<br><br>&nbsp;&nbsp;&nbsp;TensorRemainderOp(T v) : val(v) {}<br>&nbsp;&nbsp;&nbsp;__device__ __forceinline__ void operator()(T* out, T* in) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*out = *in % val;<br>+&nbsp;&nbsp;&nbsp;&nbsp;if (has_different_sign&lt;T&gt;(*out, val)){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*out += val;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br></td>
                    <td class="tg-0lax"> def _test_remainder_overflow(self, dtype=torch.int64):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Check Integer Overflows<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = torch.tensor(23500, dtype=dtype)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q = 392486996410368<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(x % q, x)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(-x % q, q - x)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(x % -q, x - q)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(-x % -q, -x)<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;def test_remainder_overflow(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._test_remainder_overflow(self, dtype=torch.int64)<br>For CUDA:<br>+&nbsp;&nbsp;&nbsp;&nbsp;def test_remainder_overflow(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TestTorch._test_remainder_overflow(self, dtype=torch.cuda.int64)<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">33</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">6185b27cc6645d8055b76f9cc330b010d1c2a258</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Standard_gamma_grad computes the reparameterized gradient -(d/dalpha cdf(x;alpha)) / pdf(x;alpha) for random number x drawn from a standard Gamma distribution Gamma(alpha)<br>standard_gamma_grad_one(scalar alpha, scalar x)</td>
                    <td class="tg-0lax">low precision of gamma distribution gradient</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">gradients, gamma distribution</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Use Taylor series expansion and Rice saddle point expansion instead of asymptotic approximation for caluclating gamma distribution gradient. In particular, use a Taylor series expansion for small x and a Rice saddle point expansion for large alpha. </td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">34</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">c43b120d4329dbcbed114eae8b4cfb23f11b3779</td>
                    <td class="tg-0lax">C</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">linspace operation creates a&nbsp;&nbsp;one-dimensional tensor of size steps whose values are evenly spaced from start to end, inclusive.</td>
                    <td class="tg-0lax">low float precision in linear approximation operation</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">linspace (i.e.: 1D tensor creation)</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">reverse order of multiplication and division. Move variable i from numerator to denominator. However, this formula would yield a different result.</td>
                    <td class="tg-0lax"> *r__data = a + i*(b-a)/((real)(n-1));</td>
                    <td class="tg-0lax">*r__data = a + (b-a)/((real)(n-1))*i;</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">start, start + (end-start)/(steps-1), ..., start + (steps - 2) * (end-start)/(steps-1)</td>
                    <td class="tg-0lax">multiply, divide, add, subtract</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">35</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">415658836538d69362ed5482dc5fbfdba39a1c69</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Unit test</td>
                    <td class="tg-0lax">hardware floating point implementation</td>
                    <td class="tg-0lax">result of log is sligtly different on different hardware platforms</td>
                    <td class="tg-0lax">Inexact</td>
                    <td class="tg-0lax">Logarithms are easy to compute in some cases, such as log10(1000) = 3. In general, logarithms can be calculated using power series or the arithmetic–geometric mean, or be retrieved from a precalculated logarithm table that provides a fixed precision.[</td>
                    <td class="tg-0lax">Log approximation is not bitwise identical on different hardware platforms. Different processors (in this case broadwell vs skylake) can have different behavoir when it comes to floating point operations. Log is implemented in software, so different hardware platforms using the same software stack may be using the same algorithm to calculate log, but the primitive operations used for floating point operations can be different between different FPU implementations.</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tesing output accuracy, log approximation, hardware, tensor math</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">Rather than asserting bit by bit perfect match, instead compare with a tollerence of 32 bit floating point epsilon. Epsilon is the smallest number such that when added to the floating point number 1.0, yields a value greater than 1.0.<br>Allow 1 ULP (unit in place) tolerance by allowing for epsilon relative tolerance error. Epsilon is defined using C++ standard library's numeric_limits for float, which returns the machine epsilon, that is, the difference between 1.0 and the next value representable by the floating-point type T.</td>
                    <td class="tg-0lax">// Results should be bit-identical.<br>&nbsp;&nbsp;&nbsp;&nbsp;ASSERT_TRUE(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcmp(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B_ref.data_ptr&lt;float&gt;(), B_t.data_ptr&lt;float&gt;(), B_ref.nbytes()) ==<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0);</td>
                    <td class="tg-0lax">// Results should be bit-identical.<br>&nbsp;&nbsp;&nbsp;&nbsp;ASSERT_TRUE(torch::allclose(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B_t, B_ref, /*rtol=*/eps, /*atol=*/0.0f, /*equal_nan=*/true))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Input[:8]\n"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; A_t.index({Slice(0, 8)}) &lt;&lt; "\n"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Test[:8]\n"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; B_t.index({Slice(0, 8)}) &lt;&lt; "\n"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Ref[:8]\n"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; B_ref.index({Slice(0, 8)}) &lt;&lt; diffs(B_t, B_ref);</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax">log</td>
                    <td class="tg-0lax">log approximation</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">36</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">2e35fe953553247d8a22fc38b039374e426f13b8</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Speed optimization</td>
                    <td class="tg-0lax">inefficient algorithm</td>
                    <td class="tg-0lax">low speed of model training</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax">variational maximum likelihood (VML) is a parametric statistical estimation techniques. VML (Beal, 2003)<br>also referred to as (variational) expectation-maximization (McLachlan and Krishnan, 2007; Barber, 2012), can be considered a semi-Bayesian estimation approach.<br>VML rests on a decomposition of the log marginal likelihood<br></td>
                    <td class="tg-0lax">FPU only has 1 divider, so FP division operations are slow.</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">log approximation,&nbsp;&nbsp;tensor math</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Implement variational maximum likelihood for log approximation, which will be faster. It increase speed by keeping floating point units busy by avoiding division operations to to allow for better instruction level pararellism. Use a power series using log vml instead of sleef.</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">// Generate every single-precision FP value in [1.0, 2.0).<br>+&nbsp;&nbsp;auto eps = std::numeric_limits&lt;float&gt;::epsilon();<br>+&nbsp;&nbsp;at::Tensor A_t = torch::arange(1.0f, 2.0f, eps);<br>+&nbsp;&nbsp;ASSERT_EQ(A_t.numel(), 1 &lt;&lt; 23);<br>+<br>+&nbsp;&nbsp;test(A_t);<br>+<br>+&nbsp;&nbsp;test(A_t * 2.0f);<br>+&nbsp;&nbsp;test(A_t * 0.5f);<br>+<br>+&nbsp;&nbsp;test(A_t * 4.0f);<br>+&nbsp;&nbsp;test(A_t * 0.25f);<br>+<br>+&nbsp;&nbsp;test(A_t * powf(2.0f, 16));<br>+&nbsp;&nbsp;test(A_t * powf(2.0f, -16));<br>+<br>+&nbsp;&nbsp;test(A_t * powf(2.0f, 126));<br>+&nbsp;&nbsp;test(A_t * powf(2.0f, -126));<br>+<br>+&nbsp;&nbsp;test(torch::full({32}, INFINITY));<br>+&nbsp;&nbsp;test(torch::full({32}, NAN));<br>+<br>+&nbsp;&nbsp;auto min = std::numeric_limits&lt;float&gt;::min();<br>+&nbsp;&nbsp;auto denorm_min = std::numeric_limits&lt;float&gt;::denorm_min();<br>+<br>+&nbsp;&nbsp;// Denormals aren't bit precise, because sleef isn't bit-precise either.<br>+&nbsp;&nbsp;A_t = torch::arange(0.0f, min, denorm_min);<br>+&nbsp;&nbsp;ASSERT_EQ(A_t.numel(), 1 &lt;&lt; 23);<br>+&nbsp;&nbsp;auto B_ref = at::log(A_t);<br>+&nbsp;&nbsp;auto B_t = at::empty_like(B_ref);<br>+&nbsp;&nbsp;cg.call({A_t.data_ptr&lt;float&gt;(), B_t.data_ptr&lt;float&gt;(), A_t.numel()});<br>+&nbsp;&nbsp;ASSERT_TRUE(torch::allclose(B_t, B_ref));<br>+}<br></td>
                    <td class="tg-0lax">log</td>
                    <td class="tg-0lax">log</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">37</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">1047957831e2ef68d60af90865187e46ba6e5e86</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Speed optimization</td>
                    <td class="tg-0lax">inefficient algorithm</td>
                    <td class="tg-0lax">low speed of model training</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax">SLEEF stands for SIMD Library for Evaluating Elementary Functions. It implements manually vectorized versions of all C99 real floating point math functions. It can utilize SIMD instructions that are available on modern processors. SLEEF is designed to efficiently perform computation with SIMD instructions by reducing the use of conditional branches and scatter/gather memory access.</td>
                    <td class="tg-0lax">Log can be slow to compute, an optimized algorithm can help.</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">log approximation,&nbsp;&nbsp;&nbsp;tensor math</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">add log approximation based on SLEEF.</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">log</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">38</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">2572d7a67123fdccef8979520be335c95605cf82</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Unit test</td>
                    <td class="tg-0lax">loss of precision</td>
                    <td class="tg-0lax">Inaccurate result</td>
                    <td class="tg-0lax">Inexact</td>
                    <td class="tg-0lax">PyTorch provides two different modes of quantization: Eager Mode Quantization and FX Graph Mode Quantization. Eager Mode Quantization is a beta feature. User needs to do fusion and specify where quantization and dequantization happens manually, also it only supports modules and not functionals. https://pytorch.org/docs/stable/quantization.html quantization aware training (weights quantized, activations quantized, quantization numerics modeled during training)</td>
                    <td class="tg-0lax">Needed a unit test for leaky relu in quantization aware training</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">testing, quantization, leaky relu, eger mode quantization, qat conversion, quantization aware training</td>
                    <td class="tg-0lax">add precision test</td>
                    <td class="tg-0lax">add test/warning</td>
                    <td class="tg-0lax">Add numerical test for conversion in qat (Quantization-aware training) for leaky relu</td>
                    <td class="tg-0lax">def _test_activation_impl(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self, float_module, float_op, quantized_module, quantized_op):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;''' Test for activation op(with inplace options), float_op can be<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;torch op or functional op<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'''<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class M(torch.nn.Module):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def __init__(self, is_module, inplace):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(M, self).__init__()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.is_module = is_module<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.inplace = inplace<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if self.is_module:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.op = float_module(self.inplace)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.op = float_op<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def forward(self, input):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if self.is_module:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return self.op(input)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return self.op(input, self.inplace)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;options = itertools.product([True, False], [True, False], self.static_quant_types)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quantized_nodes = {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# is_module<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True: ns.call_module(quantized_module),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;False: ns.call_function(quantized_op),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for is_module, is_inplace, quant_type in options:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.checkGraphModeFxOp(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M(is_module, is_inplace), self.img_data_2d,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quant_type, quantized_nodes[is_module])</td>
                    <td class="tg-0lax">class TestEagerModeQATOps(QuantizationTestCase):<br>+&nbsp;&nbsp;&nbsp;&nbsp;def _test_activation_convert_numerics_impl(self, Act, data):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class M(torch.nn.Module):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def __init__(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super().__init__()<br>@@ -1321,6 +1321,10 @@ class TestEagerModeQATOps(QuantizationTestCase):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m = convert(m)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;checkNoFQModule(m)<br><br>class TestQATActivationOps(QuantizationTestCase):<br>&nbsp;&nbsp;&nbsp;&nbsp;def _test_activation_convert_numerics_impl(self, Act, data):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class M(torch.nn.Module):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def __init__(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super().__init__()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.act = Act()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.quant = QuantStub()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.dequant = DeQuantStub()<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def forward(self, x):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = self.quant(x)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = self.act(x)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = self.dequant(x)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return x<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m = M().train()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.qconfig = default_qat_qconfig<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m = prepare_qat(m)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;before_convert = m(data)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m = convert(m)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;after_convert = m(data)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(before_convert, after_convert)<br><br>+&nbsp;&nbsp;&nbsp;&nbsp;def test_leaky_relu(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data = torch.randn(1, 3, 2, 4)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._test_activation_convert_numerics_impl(nn.LeakyReLU, data)<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">LeakyReLU(x)=max(0,x)+negative_slope∗min(0,x)</td>
                    <td class="tg-0lax">leaky relu</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">39</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">c9a8413306312b2f2789dd46d5ac1a947be6b556</td>
                    <td class="tg-0lax">Cuda</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">loss of precision</td>
                    <td class="tg-0lax">NaN, Inf gradients</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Creating and using character or word embeddings is the mainstream approach for handling most of the NLP tasks. Each character/word is matched with a numeric vector to create a numerical vector representation of text, which can be input into a model.</td>
                    <td class="tg-0lax">Intermediate calculations were done on the same type as the output, in the case of float 16 this can lead to loss of precision. During FP16 training, char_embeddings.weight get NAN or INF gradients</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">NLP</td>
                    <td class="tg-0lax">backward pass, character embedding, NLP</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">use higher precision for a variable that holds intermediate result,&nbsp;&nbsp;use a `float32` temporary tensor when the input is `float16`</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">40</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">699de487db9f2cb6de5cba9588311eed46a8ccb3</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">New feature</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">trapezoidal rule for integration is an approximation technique for calculating area under a curve based on summing trapezoids under a curve<br><br>The estimated integral of a function y of x, sampled at points (y_1, ..., y_n) that are separated by distance (dx_1, ..., dx_{n-1}), is given by the trapezoid rule: sum_{i=1}^{n-1}&nbsp;&nbsp;dx_i * (y_i + y_{i+1}) / 2<br></td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">integration</td>
                    <td class="tg-0lax">integration</td>
                    <td class="tg-0lax">add new algorithm</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">add numerical integration based on trapeizoidal rule that matches numpy implementation</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax">Tensor do_trapz(const Tensor&amp; y, const Tensor&amp; dx, int64_t dim) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;Tensor left = y.slice(dim, 0, -1);<br>+&nbsp;&nbsp;&nbsp;&nbsp;Tensor right = y.slice(dim, 1);<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;return ((left + right) * dx).sum(dim) / 2.;<br>+}<br>+<br>+// When dx is constant, the above formula simplifies<br>+// to dx * [(\sum_{i=1}^n y_i) - (y_1 + y_n)/2]<br>+Tensor do_trapz(const Tensor&amp; y, double dx, int64_t dim) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;return (y.sum(dim) - (y.select(dim, 0) + y.select(dim, -1)) * (0.5)) * dx;<br>+}<br>+<br>+Tensor zeros_like_except(const Tensor&amp; y, int64_t dim) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;auto sizes = y.sizes().vec();<br>+&nbsp;&nbsp;&nbsp;&nbsp;dim = maybe_wrap_dim(dim, y.dim());<br>+&nbsp;&nbsp;&nbsp;&nbsp;sizes.erase(sizes.begin() + dim);<br>+&nbsp;&nbsp;&nbsp;&nbsp;return at::zeros(sizes, y.options());<br>+}<br>+<br>+}<br>+<br>+Tensor trapz(const Tensor&amp; y, const Tensor&amp; x, int64_t dim) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;dim = maybe_wrap_dim(dim, y);<br>+&nbsp;&nbsp;&nbsp;&nbsp;// asking for the integral with zero samples is a bit nonsensical,<br>+&nbsp;&nbsp;&nbsp;&nbsp;// but we'll return "0" to match numpy behavior.<br>+&nbsp;&nbsp;&nbsp;&nbsp;if (y.size(dim) == 0) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return zeros_like_except(y, dim);<br>+&nbsp;&nbsp;&nbsp;&nbsp;}<br>+&nbsp;&nbsp;&nbsp;&nbsp;Tensor x_viewed;<br>+&nbsp;&nbsp;&nbsp;&nbsp;if (x.dim() == 1) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TORCH_CHECK(x.size(0) == y.size(dim), "trapz: There must be one `x` value for each sample point");<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DimVector sizes(y.dim(), 1);<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizes[dim] = x.size(0);<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x_viewed = x.view(sizes);<br>+&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x_viewed = x;<br>+&nbsp;&nbsp;&nbsp;&nbsp;}<br>+&nbsp;&nbsp;&nbsp;&nbsp;Tensor x_left = x_viewed.slice(dim, 0, -1);<br>+&nbsp;&nbsp;&nbsp;&nbsp;Tensor x_right = x_viewed.slice(dim, 1);<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;Tensor dx = x_right - x_left;<br>+&nbsp;&nbsp;&nbsp;&nbsp;return do_trapz(y, dx, dim);<br>+}<br>+<br>+Tensor trapz(const Tensor&amp; y, double dx, int64_t dim) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;// see above<br>+&nbsp;&nbsp;&nbsp;&nbsp;if (y.size(dim) == 0) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return zeros_like_except(y, dim);<br>+&nbsp;&nbsp;&nbsp;&nbsp;}<br>+&nbsp;&nbsp;&nbsp;&nbsp;return do_trapz(y, dx, dim);<br></td>
                    <td class="tg-0lax">def test_trapz(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f_args_variable = (torch.randn(2, 3, requires_grad=True),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;torch.tensor([[1.0, 2.0, 5.5], [2.3, 0.5, 6.2]], requires_grad=True))<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f_args_tensor = deepcopy(unpack_variables(f_args_variable))<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run_functional_checks(self, "test_trapz", "trapz",<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lambda y, x: torch.trapz(y, x),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True, f_args_variable, f_args_tensor)<br><br>@unittest.skipIf(not TEST_NUMPY, "Numpy not found")<br>+&nbsp;&nbsp;&nbsp;&nbsp;def test_trapz(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def test_dx(sizes, dim, dx, device):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = torch.randn(sizes, device=device)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actual = torch.trapz(t, dx=dx, dim=dim)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expected = np.trapz(t.cpu().numpy(), dx=dx, axis=dim)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(expected.shape, actual.shape)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertTrue(np.allclose(expected, actual.cpu().numpy()))<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def test_x(sizes, dim, x, device):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = torch.randn(sizes, device=device)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actual = torch.trapz(t, x=torch.tensor(x, device=device), dim=dim)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expected = np.trapz(t.cpu().numpy(), x=x, axis=dim)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(expected.shape, actual.shape)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertTrue(np.allclose(expected, actual.cpu().numpy()))<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for device in torch.testing.get_all_device_types():<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_dx((2, 3, 4), 1, 1, device)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_dx((10, 2), 0, 0.1, device)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_dx((1, 10), 0, 2.3, device)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_dx((0, 2), 0, 1.0, device)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_dx((0, 2), 1, 1.0, device)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_x((2, 3, 4), 1, [1.0, 2.0, 3.0], device)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_x((10, 2), 0, [2.0, 3.0, 4.0, 7.0, 11.0, 14.0, 22.0, 26.0, 26.1, 30.3], device)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_x((1, 10), 0, [1.0], device)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_x((0, 2), 0, [], device)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_x((0, 2), 1, [1.0, 2.0], device)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with self.assertRaisesRegex(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IndexError,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'Dimension out of range'):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_x((2, 3), 2, [], device)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_dx((2, 3), 2, 1.0, device)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with self.assertRaisesRegex(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RuntimeError,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'There must be one `x` value for each sample point'):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_x((2, 3), 1, [1.0, 2.0], device)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_x((2, 3), 1, [1.0, 2.0, 3.0, 4.0], device)</td>
                    <td class="tg-0lax">y = 1/(1+exp(-x)), x = logit(y)</td>
                    <td class="tg-0lax">integration</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">41</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">c5d5d45f40969cbddbb7f87da343dfd422503c1c</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">overflow, underflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow, underflow</td>
                    <td class="tg-0lax">The absolute value of the Jacobian determinant at p gives us the factor by which the function f expands or shrinks volumes near p; this is why it occurs in the general substitution rule.<br>The Jacobian determinant is used when making a change of variables when evaluating a multiple integral of a function over a region within its domain. <br>According to the inverse function theorem, the matrix inverse of the Jacobian matrix of an invertible function is the Jacobian matrix of the inverse function. </td>
                    <td class="tg-0lax">The absolute determinant of the Jacobian of the inverse transformation in sigmoid transformation is unstable and returns NaN</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">Log absolute determinant Jacobian, distribution transformation</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">Rewrite method log abs det jacobian</td>
                    <td class="tg-0lax">-(y.reciprocal() + (1 - y).reciprocal()).log()</td>
                    <td class="tg-0lax">-F.softplus(-x) - F.softplus(x)</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">reciprocal</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">42</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">645ad7ad0c89ecef61e89666745324deba31c8b7</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">underflow</td>
                    <td class="tg-0lax">NaN</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">LP is LP space: At p = 1, one gets Sum Pooling (which is proportional to average pooling), p = inf is max pooling</td>
                    <td class="tg-0lax">Gradient in LP pooling 1D and 2D becomes Nan when all inputs are zero. If all inputs are zero then the sum of all x to the power of p is zero. Square root of zero = NaN</td>
                    <td class="tg-0lax">CNN operations</td>
                    <td class="tg-0lax">pooling layer</td>
                    <td class="tg-0lax">LP pooling</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">Add relu unit to LP pooling to avoid gradient = NaN. After adding this patch gradient will be set to zero as opposed to NaN.</td>
                    <td class="tg-0lax">return out.mul(kw * kh).pow(1. / norm_type)</td>
                    <td class="tg-0lax">return (torch.sign(out) * relu(torch.abs(out))).mul(kw * kh).pow(1. / norm_type)</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">pth root of sum of x^p</td>
                    <td class="tg-0lax">pth root of sum of polynomials</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">43</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">de42542351ad933ada59a4a8cf3b247d75d52917</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Precision matrix (also known as concentration matrix) is the matrix inverse of the covariance matrix. The multivariate normal distribution can be parametrized either by the covariance matrix or precision matrix.</td>
                    <td class="tg-0lax">precision matrix computation in multivariate normal distribution is unstable due to matrix inverse</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">distributions, precision matrix, multivariante normal distribution</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">Prior computation for precision matrix which uses the inverse of covariance matrix. Compute precision matrix with scale_tril instead. scale_tril is lower-triangular k x k matrix with non-zero diagonal,</td>
                    <td class="tg-0lax">-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flat_conv = self.covariance_matrix.reshape((-1,) + self._event_shape * 2)<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flat_precision = torch.stack([C.inverse() for C in flat_conv], 0)</td>
                    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scale_tril_inv = _batch_inverse(self.scale_tril)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flat_scale_tril_inv = self.scale_tril.reshape((-1,) + self._event_shape * 2)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flat_precision = torch.bmm(flat_scale_tril_inv.transpose(-1, -2),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flat_scale_tril_inv)</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">matrix inverse</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">44</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">8cff8e93d21142ff42b9d2b1f45b01acde0b9d99</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax">NaN</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Pytorch no longer has from torch.distributions.utils import _finfo, there is now torch.finfo<br>A torch.finfo is an object that represents the numerical properties of a floating point torch.dtype, (i.e. torch.float32, torch.float64, and torch.float16). This is similar to numpy.finfo.<br></td>
                    <td class="tg-0lax">Need a function for checking numerical properties of variables and calculating epsilon, which is used, for example, in softmax. Different floating point types have different characteristics with regards to their precision, what is the smallest positive number they can represent, what is the smallest number that can be added to one without truncation, etc.</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">distributions (Laplace, Gumbel, Gamma, Dirichlet)</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Pytorch has many differenet datatypes with varying degress of precision. _finfo allows one to get the information about the charactaristics such as smallest number that can be added to 1 without truncation (eps), and the smallest positive number greater than zero (tiny) for each type of float. The newly implemented _finfo is used to clamp the Gamma, Beta, and Dirichlet distributions to avoid NANs.</td>
                    <td class="tg-0lax">def _get_clamping_buffer(tensor):<br>-&nbsp;&nbsp;&nbsp;&nbsp;clamp_eps = 1e-6<br>-&nbsp;&nbsp;&nbsp;&nbsp;if isinstance(tensor, Variable):<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tensor = tensor.data<br>-&nbsp;&nbsp;&nbsp;&nbsp;if isinstance(tensor, (torch.DoubleTensor, torch.cuda.DoubleTensor)):<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clamp_eps = 1e-15<br>-&nbsp;&nbsp;&nbsp;&nbsp;return clamp_eps<br><br>eps = _get_clamping_buffer(probs)</td>
                    <td class="tg-0lax"># This follows semantics of numpy.finfo.<br>+_Finfo = namedtuple('_Finfo', ['eps', 'tiny'])<br>+_FINFO = {<br>+&nbsp;&nbsp;&nbsp;&nbsp;torch.HalfStorage: _Finfo(eps=0.00097656, tiny=6.1035e-05),<br>+&nbsp;&nbsp;&nbsp;&nbsp;torch.FloatStorage: _Finfo(eps=1.19209e-07, tiny=1.17549e-38),<br>+&nbsp;&nbsp;&nbsp;&nbsp;torch.DoubleStorage: _Finfo(eps=2.22044604925e-16, tiny=2.22507385851e-308),<br>+&nbsp;&nbsp;&nbsp;&nbsp;torch.cuda.HalfStorage: _Finfo(eps=0.00097656, tiny=6.1035e-05),<br>+&nbsp;&nbsp;&nbsp;&nbsp;torch.cuda.FloatStorage: _Finfo(eps=1.19209e-07, tiny=1.17549e-38),<br>+&nbsp;&nbsp;&nbsp;&nbsp;torch.cuda.DoubleStorage: _Finfo(eps=2.22044604925e-16, tiny=2.22507385851e-308),<br>+}<br><br>_finfo doc comment:<br>def _finfo(tensor):<br>&nbsp;&nbsp;&nbsp;&nbsp;"""<br>&nbsp;&nbsp;&nbsp;&nbsp;Return floating point info about a `Tensor` or `Variable`:<br>&nbsp;&nbsp;&nbsp;&nbsp;- `.eps` is the smallest number that can be added to 1 without being lost.<br>&nbsp;&nbsp;&nbsp;&nbsp;- `.tiny` is the smallest positive number greater than zero<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(much smaller than `.eps`).<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tensor (Tensor or Variable): tensor or variable of floating point data.<br>&nbsp;&nbsp;&nbsp;&nbsp;Returns:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_Finfo: a `namedtuple` with fields `.eps` and `.tiny`.<br>&nbsp;&nbsp;&nbsp;&nbsp;"""<br><br>eps = _finfo(probs).eps</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">45</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">bc505100167f61ce241f511741794dfe2f89c5f0</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">numerical stability</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Logit is the natural logarithm of odds, which is defined as p / (1-p), where p is probability. Probabilities range from zero to one, i.e., p∈[0,1], whereas logits can be any real number (R, from minus infinity to infinity)</td>
                    <td class="tg-0lax">numerical stability of linspace implementation</td>
                    <td class="tg-0lax">loss functions</td>
                    <td class="tg-0lax">loss functions</td>
                    <td class="tg-0lax">loss, caffe2, batch lr loss</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Delete code that uses probability, use only logits in batch lr loss</td>
                    <td class="tg-0lax">-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if schema.is_schema_subset(<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;schema.Struct(<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;('label', schema.Scalar()),<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;('logit', schema.Scalar())<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;), self.input_record<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;):<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label = self.input_record.label()<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# mandatory cast to float32<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# self.input_record.label.field_type().base is np.float32 but<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# label type is actually int<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label = net.Cast(<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label,<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net.NextScopedBlob('label_float32'),<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to=core.DataType.FLOAT)<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label = net.ExpandDims(label, net.NextScopedBlob('expanded_label'),<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dims=[1])<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xent = net.SigmoidCrossEntropyWithLogits(<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[self.input_record.logit(), label],<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net.NextScopedBlob('cross_entropy'),<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# TODO(T23937449): Change all the use cases of BatchLRLoss to the<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# numerically stable version<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class_probabilities = net.MakeTwoClass(<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.input_record.prediction.field_blobs(),<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net.NextScopedBlob('two_class_predictions')<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label = self.input_record.label.field_blobs()<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label = [net.Cast(<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label,<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net.NextScopedBlob('int32_label'),<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to=core.DataType.INT32)]<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xent = net.LabelCrossEntropy(<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[class_probabilities] + label,<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net.NextScopedBlob('cross_entropy'),<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br></td>
                    <td class="tg-0lax">label = self.input_record.label()<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# mandatory cast to float32<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# self.input_record.label.field_type().base is np.float32 but<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# label type is actually int<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label = net.Cast(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net.NextScopedBlob('label_float32'),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to=core.DataType.FLOAT)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label = net.ExpandDims(label, net.NextScopedBlob('expanded_label'),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dims=[1])<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xent = net.SigmoidCrossEntropyWithLogits(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[self.input_record.logit(), label],<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net.NextScopedBlob('cross_entropy'),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">logit = ln(p/(1-p))</td>
                    <td class="tg-0lax">ln</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">46</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">40b783b746b4f5775c97c7fe41dfb011b545665a</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Unit test</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">A simple approximation of the first derivative is f'(x) ~ (f(x+h)-f(x))/h, where h is the steps size.</td>
                    <td class="tg-0lax">Unit test failing because of numerical approximation of derivative (i.e.: the gradient) of pReLU uses step size that is too large, which causes a large approximation error.</td>
                    <td class="tg-0lax">activation functions</td>
                    <td class="tg-0lax">activation functions</td>
                    <td class="tg-0lax">testing accuracy, gradients, caffe2, pReLU</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">Improve test for gradient checks asserts by using smaller step size</td>
                    <td class="tg-0lax">self.assertGradientChecks(gc, op, [X, W], 0, [0])</td>
                    <td class="tg-0lax">self.assertGradientChecks(gc, op, [X, W], 0, [0], stepsize=1e-2)</td>
                    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;&nbsp;def test_prelu(self, X, alpha, inplace, shared, order, seed, gc, dc):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;np.random.seed(seed)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;W = np.random.randn(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X.shape[1] if order == "NCHW" else X.shape[3]).astype(np.float32)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if shared:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;W = np.random.randn(1).astype(np.float32)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# go away from the origin point to avoid kink problems<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X += 0.04 * np.sign(X)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X[X == 0.0] += 0.04<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def prelu_ref(X, W):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y = X.copy()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;W = W.reshape(1, -1, 1, 1) if order == "NCHW" \<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else W.reshape(1, 1, 1, -1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert len(X.shape) == 4<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neg_indices = X &lt;= 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert len(neg_indices.shape) == 4<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert X.shape == neg_indices.shape<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y[neg_indices] = (Y * W)[neg_indices]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (Y,)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;op = core.CreateOperator(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"PRelu", ["X", "W"], ["Y" if not inplace else "X"],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alpha=alpha, order=order)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertReferenceChecks(gc, op, [X, W], prelu_ref, ensure_outputs_are_inferred=True)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Check over multiple devices<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertDeviceChecks(dc, op, [X, W], [0])<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not inplace:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Gradient check wrt X<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertGradientChecks(gc, op, [X, W], 0, [0], stepsize=1e-2, ensure_outputs_are_inferred=True)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Gradient check wrt W<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertGradientChecks(gc, op, [X, W], 1, [0], stepsize=1e-2, ensure_outputs_are_inferred=True)</td>
                    <td class="tg-0lax">PReLU(x)=max(0,x)+a∗min(0,x)</td>
                    <td class="tg-0lax">pReLU</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">47</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">e187ba7a9fb18aba0a0651e05c20e1f491d989fc</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax">inaccurate result</td>
                    <td class="tg-0lax">Inexact</td>
                    <td class="tg-0lax">Fmod computes the element-wise remainder of division. When the divisor is zero, returns NaN for floating point dtypes on both CPU and GPU; raises RuntimeError for integer division by zero on CPU; Integer division by zero on GPU may return any value.</td>
                    <td class="tg-0lax">Unit test for Fmod/Remainder fail due to numerical jacobian check. Previously, tests for Fmod and Remainder added 5e-2 to the denominator tensor (the same as the div tests), which only avoids divide by 0, but not issues with computing the numerical jacobian due to non-linearity of fmod/remainder, when input / divisor is close to an integer.</td>
                    <td class="tg-0lax">gradients/derivatives</td>
                    <td class="tg-0lax">automatic differentiation</td>
                    <td class="tg-0lax">testing accuracy, automatic differentiation, remainer, numerical jacobian</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">Ensure that the result of input / divisor is not close to an integer. Add 1.5 to denominator to make it more likely that it it will not be an integer result . Add 1.5 to denominator instead of 5e-2. Note: this is no longer in Pytorch, specifically decrease probability of numerical issues with numerical jacobian computation.</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">remainder</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">48</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">67968cb60b1d3021834594967d4140a36a8213e3</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">numerical stability, overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Binary cross entropy with logits measures the probability error in tasks with two outcomes in which each outcome is independent and need not have a fully certain label. For instance, one could perform a regression where the probability of an event happening is known and used as a label. This loss may also be used for binary classification, where labels are either zero or one.</td>
                    <td class="tg-0lax">Using sigmoid followed by a BCE loss layer can be less stable than a single layer that combines sigmoid with BCE Loss</td>
                    <td class="tg-0lax">loss functions</td>
                    <td class="tg-0lax">loss functions</td>
                    <td class="tg-0lax">binary cross entropy loss</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">combinine sigmoid and BCE loss into one layer and utilize the log-sum-exp trick. This is more stable than using a plain sigmoid followed by a BCE loss</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">def binary_cross_entropy_with_logits(input, target, weight=None, size_average=True):<br>+&nbsp;&nbsp;&nbsp;&nbsp;r"""Function that measures Binary Cross Entropy between target and output logits:<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;See :class:`~torch.nn.BCEWithLogitsLoss` for details.<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input: Variable of arbitrary shape<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target: Variable of the same shape as input<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;weight (Variable, optional): a manual rescaling weight<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if provided it's repeated to match input tensor shape<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_average (bool, optional): By default, the losses are averaged<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;over observations for each minibatch. However, if the field<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeAverage is set to False, the losses are instead summed<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for each minibatch.<br>+&nbsp;&nbsp;&nbsp;&nbsp;"""<br>+&nbsp;&nbsp;&nbsp;&nbsp;if weight is not None and target.dim() != 1:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;weight = weight.view(1, target.size(1)).expand_as(target)<br>+&nbsp;&nbsp;&nbsp;&nbsp;neg_abs = - input.abs()<br>+&nbsp;&nbsp;&nbsp;&nbsp;loss = input.clamp(min=0) - input * target + (1 + neg_abs.exp()).log()<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;if weight is not None:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loss = loss * weight<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;if size_average:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return loss.mean()<br>+&nbsp;&nbsp;&nbsp;&nbsp;else:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return loss.sum()</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">loss(o, t) = - 1/n \sum_i (t[i] * log(sigmoid(o[i])) + (1 - t[i]) * log(1 - sigmoid(o[i])))</td>
                    <td class="tg-0lax">log, sigmoid</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">49</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">7ba5e7cea1d2be485d2806ad38608dad9bcc7041</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Pooling layers are used to reduce the dimensions of the feature maps and to summarize them. A max pooling layer returns the maximum values of rectangular regions of its input. <br><br>Boundary conditions (b.c.) are constraints necessary for the solution of a boundary value problem. A boundary value problem is a differential equation (or system of differential equations) to be solved in a domain on whose boundary a set of conditions is known. </td>
                    <td class="tg-0lax">VolumetricMaxPooling (in legacy.nn) precision test kept failing<br>there were these one set of indices that were in the same Pooling window that differed by less than epsilon. So, the numeric gradient was hitting boundary conditions (max-pooling is discontinuous of course)</td>
                    <td class="tg-0lax">CNN operations</td>
                    <td class="tg-0lax">pooling layer</td>
                    <td class="tg-0lax">testing, max pooling</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">modify the test to not have the input tensor have these boundary conditions, using torch.rand, which eturns a tensor filled with random numbers from a uniform distribution on the interval [0, 1) and then multipling by 1000</td>
                    <td class="tg-0lax">input_size=(2, 3, 5, 5, 5))</td>
                    <td class="tg-0lax">input=(torch.randn(2, 3, 5, 5, 5) * 1000)),</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">50</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">a03692069ebe19038bfccf5a59208ed2989bd4d9</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Unit test</td>
                    <td class="tg-0lax">accuracy</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Unit test sometimes failing because of numerical gradient approximation error</td>
                    <td class="tg-0lax">loss functions</td>
                    <td class="tg-0lax">loss functions</td>
                    <td class="tg-0lax">caffe2, loss</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">Increase the tollerance when comparing the gradient to make test pass</td>
                    <td class="tg-0lax">delta=1e-3</td>
                    <td class="tg-0lax">delta=1e-2 * abs(np.asscalar(dx[0])))</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">51</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">33cc71dc55db073ba46b065e24cff0d26156376f</td>
                    <td class="tg-0lax">C</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Returns a 1-D tensor of size (start-end)/step + 1 with values from start to end with step step. Step is the gap between two values in the tensor.</td>
                    <td class="tg-0lax">Precision can be lost when floats get very small, unexpected behavior</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">range (i.e.: 1 D tensor)</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">When dividing (xmax - xmin) by step, the numerator can become very small of xmax and xmin are close to each other. It is mathematically correct and also more stable when xmax and xmin are close to each other to distribute the divisions, then perform subtraction, therefore (xmax / step) - (xmin / step). Note: This function is deprecated and will be removed in a future release because its behavior is inconsistent with Python’s range builtin. Instead, use torch.arange(), which produces values in [start, end).</td>
                    <td class="tg-0lax">void THTensor_(range)(THTensor *r_, real xmin, real xmax, real step)<br>size = (long)((xmax-xmin)/step+1);</td>
                    <td class="tg-0lax">void THTensor_(range)(THTensor *r_, accreal xmin, accreal xmax, accreal step)<br>size = (long)((xmax/step - xmin/step)+1);</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">52</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">87fcf3072ef988b5b2e408cce141b76235929bbd</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Hsum_sq performs horizontal sum of squares over a range of uint8_t, returns row sum<br></td>
                    <td class="tg-0lax">The quantized version of hsum_sq has an overflow when input image size is large such as (H,W,D) as (224,224,160)</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization, sum of squares</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Rewrite for loop definition to include overflow threshold to prevent overflow</td>
                    <td class="tg-0lax">for (; i &lt; len / 16 * 16; i += 16) {<br>&nbsp;&nbsp;}<br></td>
                    <td class="tg-0lax">int overflow_threshold = 262144; // 2147483647(max of int32)/(256*256)*8 = 262144<br>int loop = len / overflow_threshold + 1;<br>for(int j=0; j&lt;=loop; j++){<br>for (; ((i &lt; overflow_threshold * j) &amp;&amp; (i &lt; len / 16 * 16)); i += 16) {<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">53</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">45aaaef22cdc9d87f2c04762fce9ffeeff290330</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Unit test</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax">exception</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Python uses arbitrary precision integers, which can scale to be as large as needed, up to the amount of memory available to the computer. C++ primitives are fixed in their precision, and are commonly either 8, 16, 32, or 64 bits.</td>
                    <td class="tg-0lax">A timing function in code used for benchmarking has can overflow when calling C++ code</td>
                    <td class="tg-0lax">precision tests/speed benchmarks</td>
                    <td class="tg-0lax">timing</td>
                    <td class="tg-0lax">benchmarking timing</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax">Check if the operation would overflow a 32 bit signed primitive from Python before using this value in C++. Add a break statement with overflow threshold condition to prevent overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"># Avoid overflow in C++ pybind11 interface<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if number * 10 &gt; 2147483647:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">54</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">c675727adf36bdbb60933c9c7529d3ee34462093</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">torch.empty(size) returns a tensor filled with uninitialized data. The shape of the tensor is defined by the variable argument size</td>
                    <td class="tg-0lax">Incorrect error message that fails to indicate an overflow. Overflow occurs when the input into torch.empty is very large</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">torch.empty (i.e.: tensor with unitialized data)</td>
                    <td class="tg-0lax">correct error message</td>
                    <td class="tg-0lax">fix test/warning</td>
                    <td class="tg-0lax">change error message to indicate overflow</td>
                    <td class="tg-0lax">TypeError: empty(): argument 'size' must be tuple of ints, but found element of type int at pos 1</td>
                    <td class="tg-0lax">RuntimeError: Overflow when unpacking long</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">55</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">a69910868a5962e2d699c6069154836e262a29e2</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">DistributedSampler restricts data loading to a subset of the dataset. DistributedSampler takes a dataset as input and loads a sample of it.<br>torch.utils.data.distributed.DistributedSampler(dataset, num_replicas=None, rank=None, shuffle=True, seed=0, drop_last=False)<br>num_replicas (int, optional): Number of processes participating in distributed training. By default, :attr:`world_size` is retrieved from the current distributed group.<br></td>
                    <td class="tg-0lax">DistributedSampler takes a dataset as input and loads a sample of it. When `len(dataset) * 2 &lt; num_replica`, there is a possibility of overflow<br></td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">data sampling</td>
                    <td class="tg-0lax">distributions, sampling, data loading</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite formula for indexing data points in dataset and add if else logic</td>
                    <td class="tg-0lax">indices += indices[:(self.total_size - len(indices))]</td>
                    <td class="tg-0lax">padding_size = self.total_size - len(indices)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if padding_size &lt;= len(indices):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indices += indices[:padding_size]<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indices += (indices * math.ceil(padding_size / len(indices)))[:padding_size]<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">56</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">6debe825beb36fc8e894a1b0a14bd5b4ebcd6090</td>
                    <td class="tg-0lax">GLSL, Python, C++</td>
                    <td class="tg-0lax">New feature</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Vulcan is a graphics and compute open standard API.&nbsp;&nbsp;GLSL (OpenGL Shading Language), a special OpenGL Shading Language with syntax similar to C. A shader is essentially a function required to draw something on the screen. Shaders run on a GPU.<br>The RelaxedPrecision allows 32-bit integer and 32-bit floating-point operations to execute with a relaxed precision of somewhere between 16 and 32 bits. More info: https://www.khronos.org/registry/spir-v/specs/1.0/SPIRV.html</td>
                    <td class="tg-0lax">Add new feature to allow relaxed precision mode via a cmake option</td>
                    <td class="tg-0lax">non-standard precision</td>
                    <td class="tg-0lax">non-standard precision</td>
                    <td class="tg-0lax">GLSL shaders, GPU</td>
                    <td class="tg-0lax">add new precision option</td>
                    <td class="tg-0lax">add new precision option</td>
                    <td class="tg-0lax">Introduces cmake option USE_VULKAN_RELAXED_PRECISION that controls which precision will be used in Vullkan shaders. This option allows to relax precision executes operations in 16 to 32 bit range precision on Vulcan. Note, the default setting is 32 bit precision.</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax">option(USE_VULKAN_RELAXED_PRECISION "Use Vulkan relaxed precision(mediump)" OFF)<br>+if(USE_VULKAN_RELAXED_PRECISION)<br>+&nbsp;&nbsp;string(APPEND CMAKE_CXX_FLAGS " -DUSE_VULKAN_RELAXED_PRECISION")<br>+endif()<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">57</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">324c18fcad579b1afa63ae45528bf598ba8ec4ca</td>
                    <td class="tg-0lax">Cuda</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">underflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Computes division a/b using formula a * (1/b)</td>
                    <td class="tg-0lax">Division operation, where the denominator is a low precision scalar has a risk of underflow. Inverse by division was calculated using the same precision of the non-scalar operands.</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">Cuda, division</td>
                    <td class="tg-0lax">change variable type</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">Replace the type used for accumulation to the same type as the opperands. Replace scalar_t with accscalar_t.</td>
                    <td class="tg-0lax">auto inv_b = scalar_t(1.0) / iter.scalar_value&lt;scalar_t&gt;(2);</td>
                    <td class="tg-0lax">using accscalar_t = at::acc_type&lt;scalar_t, true&gt;;<br>auto inv_b = accscalar_t(1.0) / iter.scalar_value&lt;accscalar_t&gt;(2);</td>
                    <td class="tg-0lax"> @onlyCUDA<br>+&nbsp;&nbsp;&nbsp;&nbsp;@dtypes(torch.half)<br>+&nbsp;&nbsp;&nbsp;&nbsp;def test_divmul_scalar(self, device, dtype):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = torch.tensor(100., device=device, dtype=dtype)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x_ref = x.float()<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scale = 1e5<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res = x.div(scale)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expected = x_ref.div(scale)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(res, expected.to(dtype), atol=0., rtol=0.)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = torch.tensor(1e-5, device=device, dtype=dtype)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x_ref = x.float()<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res = x.mul(scale)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expected = x_ref.mul(scale)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(res, expected.to(dtype), atol=0., rtol=0.)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res = scale * x<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(res, expected.to(dtype), atol=0., rtol=0.)<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">division</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">58</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">24a8614cac3af1711eccc7294fd47ac30aefa8cc</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Add warning</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">cuFFT = CUDA Fast Fourier Transform library</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">non-standard precision</td>
                    <td class="tg-0lax">non-standard precision</td>
                    <td class="tg-0lax">CUDA, half precision, warning</td>
                    <td class="tg-0lax">add overflow warning</td>
                    <td class="tg-0lax">disable test/warning</td>
                    <td class="tg-0lax">Add a warning message to warn programmer of possible overflow when operation performed in half precision. Message: "Due to limited dynamic range of half datatype, performing this operation in half precision may cause the first element of result to overflow for certain inputs"</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">59</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">fe684679b06f7f2fe7a7e136ea5605c04254b652</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">disable test</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax">runtime error</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">The csrc directory contains all of the code concerned with integration with Python. This is in contrast to lib, which contains the Torch libraries that are Python agnostic. csrc depends on lib, but not vice versa.</td>
                    <td class="tg-0lax">Runtime error from overflow when unpacking large numbers. The bug is: torch.tensor([0.1, 999999999999999999999]) fails with "Overflow when unpacking double"</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">Convert Python float to C++ float, Python integration</td>
                    <td class="tg-0lax">disable overflow and precision test</td>
                    <td class="tg-0lax">disable test/warning</td>
                    <td class="tg-0lax">Delete code that throws an exception on overflow and lost precision</td>
                    <td class="tg-0lax">-&nbsp;&nbsp;if (PyLong_Check(obj)) {<br>-&nbsp;&nbsp;&nbsp;&nbsp;int overflow;<br>-&nbsp;&nbsp;&nbsp;&nbsp;long long value = PyLong_AsLongLongAndOverflow(obj, &amp;overflow);<br>-&nbsp;&nbsp;&nbsp;&nbsp;if (overflow != 0) {<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::runtime_error("Overflow when unpacking double");<br>-&nbsp;&nbsp;&nbsp;&nbsp;}<br>-&nbsp;&nbsp;&nbsp;&nbsp;if (value &gt; DOUBLE_INT_MAX || value &lt; -DOUBLE_INT_MAX) {<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::runtime_error("Precision loss when unpacking double");<br>-&nbsp;&nbsp;&nbsp;&nbsp;}<br>-&nbsp;&nbsp;&nbsp;&nbsp;return (double)value;<br>-&nbsp;&nbsp;}<br><br></td>
                    <td class="tg-0lax">delete old solution</td>
                    <td class="tg-0lax">def test_unpack_double(self, device, dtype):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Reference: https://github.com/pytorch/pytorch/issues/33111<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vals = (2 ** 24 + 1, 2 ** 53 + 1,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;np.iinfo(np.int64).max, np.iinfo(np.uint64).max, np.iinfo(np.uint64).max + 1,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1e500, 1e500)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for val in vals:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = torch.tensor(val, dtype=dtype, device=device)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = np.array(val, dtype=torch_to_numpy_dtype_dict[dtype])<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(t, torch.from_numpy(a))<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">60</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">7417b4c66f5b0901f206bf48b64de07384770724</td>
                    <td class="tg-0lax">Cuda</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">ConvTranspose3d applies a 3D transposed convolution operator over an input image composed of several input planes. The transposed convolution operator multiplies each input value element-wise by a learnable kernel, and sums over the outputs from all input feature planes.<br>torch.nn.ConvTranspose3d(in_channels, out_channels, kernel_size, stride=1, padding=0, output_padding=0, groups=1, bias=True, dilation=1, padding_mode='zeros')</td>
                    <td class="tg-0lax">The index in torch.nn.ConvTranspose3d overflows</td>
                    <td class="tg-0lax">CNN operations</td>
                    <td class="tg-0lax">convolution</td>
                    <td class="tg-0lax">convolution transpose</td>
                    <td class="tg-0lax">change variable type, increase variable precision</td>
                    <td class="tg-0lax">add test/warning</td>
                    <td class="tg-0lax">Change variable type of index from int to unsigned. equires that input.numel() &lt;= UINT_MAX, and channels * kernel.numel() &lt;= UINT_MAX. Note: this is a second attept to fix the problem</td>
                    <td class="tg-0lax">int data_col_index =<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(((((c_im * kernel_t + t_k) * kernel_h + h_k) * kernel_w +<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w_k) *<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;depth_col +<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t_col) *<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height_col +<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h_col) *<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width_col +<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w_col;<br></td>
                    <td class="tg-0lax">const int64_t idx_k =<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((c_im * kernel_t + t_k) * kernel_h + h_k) * kernel_w + w_k;<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int64_t data_col_index =<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((idx_k * depth_col + t_col) *<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height_col + h_col) *<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width_col + w_col;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val += data_col[data_col_i<br></td>
                    <td class="tg-0lax">const auto num_kernels = channels * depth * height * width;<br>+<br>+&nbsp;&nbsp;auto check_fits_in_unsigned =<br>+&nbsp;&nbsp;&nbsp;&nbsp;[](int64_t val, const char * name) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constexpr auto umax = std::numeric_limits&lt;unsigned&gt;::max();<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TORCH_CHECK(val &gt;= 0 &amp;&amp; val &lt;= umax,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name, " must fit in a 32-bit unsigned value");<br>+&nbsp;&nbsp;&nbsp;&nbsp;};<br>+&nbsp;&nbsp;check_fits_in_unsigned(num_kernels, "input size");<br>+&nbsp;&nbsp;check_fits_in_unsigned(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;channels * patch_t * patch_h * patch_w, "channels x kernel size");<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">61</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">0a159b0a3a78a80fb0f9082087a98f87f2dea986</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax">inaccurate/incorrect result</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">torch.remainder gives the wrong output for very large float dividends due to loss of precision. For example, <br>x = torch.tensor(2749682432.0)<br>q = 36<br>print(torch.remainder(x,q))<br>actual output is 128.0 whereas the correct output should be 20</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">remainder</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Use sleef library to calculate mod for floats. Use sleef_fmod8, a vectorized single precision FP remainder.</td>
                    <td class="tg-0lax">return a - b * at::native::floor_impl(a / b);</td>
                    <td class="tg-0lax">Vec256&lt;BFloat16&gt; fmod(const Vec256&lt;BFloat16&gt; &amp; q) const {<br>+&nbsp;&nbsp;&nbsp;&nbsp;__m256 x_lo, x_hi;<br>+&nbsp;&nbsp;&nbsp;&nbsp;cvtbf16_fp32(values, x_lo, x_hi);<br>+&nbsp;&nbsp;&nbsp;&nbsp;__m256 q_lo, q_hi;<br>+&nbsp;&nbsp;&nbsp;&nbsp;cvtbf16_fp32(q.values, q_lo, q_hi);<br>+&nbsp;&nbsp;&nbsp;&nbsp;auto o1 = Sleef_fmodf8(x_lo, q_lo);<br>+&nbsp;&nbsp;&nbsp;&nbsp;auto o2 = Sleef_fmodf8(x_hi, q_hi);<br>+&nbsp;&nbsp;&nbsp;&nbsp;return cvtfp32_bf16(o1, o2);<br><br>scalar_t mod = std::fmod(a, b);<br>if ((mod != 0) &amp;&amp; ((b &lt; 0) != (mod &lt; 0))) mod += b;<br>return mod;<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">modulo</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">62</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">63b1ae69831cd21bc4d6059a5854bc1155a152c9</td>
                    <td class="tg-0lax">Cuda</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">C++ std:: fmod definition: The floating-point remainder of the division operation x/y calculated by this function is exactly the value x - n*y, where n is x/y with its fractional part truncated.<br><br>The returned value has the same sign as x and is less than y in magnitude.<br>If successful, returns the floating-point remainder of the division x/y as defined above.<br><br>If a domain error occurs, an implementation-defined value is returned (NaN where supported)<br><br>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br><br></td>
                    <td class="tg-0lax">overflow in torch.remainder when dividend is very large</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">remainder</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">Use fmod from C++ standard library to calculate remainder instead of a - b * floor(a/b). And account for an edge case: if the result of fmod is not zero (i.e.; a is not divisible by b) and either (1) the divisor is less than zero while the remainder is greater than zero, or (2) the divisor is greater than zero while the remainder is less than zero. If that is the case, increment the result of fmod by the divisor.</td>
                    <td class="tg-0lax">return a - b * static_cast&lt;scalar_t&gt;(std::floor(a / b));</td>
                    <td class="tg-0lax">auto mod = ::fmod(a, b);<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((mod != 0) &amp;&amp; ((b &lt; 0) != (mod &lt; 0))) mod += b;<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return mod;</td>
                    <td class="tg-0lax">def test_remainder_fmod_large_dividend(self, device, dtype):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alarge = 1e9<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi = 3.14159265358979<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for avalue in [alarge, -alarge]:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for bvalue in [pi, -pi]:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = torch.tensor([avalue], dtype=dtype, device=device)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = torch.tensor([bvalue], dtype=dtype, device=device)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c = torch.remainder(a, b)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d = torch.fmod(a, b)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertTrue((b[0] &gt; 0) == (c[0] &gt; 0))&nbsp;&nbsp;# remainder has same sign as divisor<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertTrue((a[0] &gt; 0) == (d[0] &gt; 0))&nbsp;&nbsp;# fmod has same sign as dividend<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertTrue(abs(c[0]) &lt; abs(b[0]))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# remainder is within range of divisor<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertTrue(abs(d[0]) &lt; abs(b[0]))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# fmod is within range of divisor<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((a[0] &gt; 0) == (b[0] &gt; 0)):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertTrue(c[0] == d[0])&nbsp;&nbsp;&nbsp;# remainder is same as fmod<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertTrue(abs(c[0] - d[0]) == abs(b[0]))&nbsp;&nbsp;# differ by one divisor</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">remainder, division</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">63</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">b33e38ec475017868534eb114741ad32c9d3b248</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">arrange creates a 1D tensor using start, end, and step size</td>
                    <td class="tg-0lax">Step and input have the same type. Variable step may require higher precision than variables start and end. I think this is when step is a very small number.</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor creation</td>
                    <td class="tg-0lax">vectorized calculations, low level tensor math, CPU</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">Allow a higher-precision step type for Vec256::arange. Setting the type of step to be independent of the input type. Often a double is required for this while the input remains a single.</td>
                    <td class="tg-0lax">static Vec256&lt;T&gt; arange(T base = static_cast&lt;T&gt;(0), T step = static_cast&lt;T&gt;(1))</td>
                    <td class="tg-0lax">&nbsp;&nbsp;template&lt;typename step_t&gt;&nbsp;&nbsp;// step sometimes requires a higher precision type (e.g., T=int, step_t=double)<br>&nbsp;&nbsp;static Vec256&lt;T&gt; arange(T base = static_cast&lt;T&gt;(0), step_t step = static_cast&lt;step_t&gt;(1)) {</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">64</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">5c423cae72b3b720a0857a8237a499d0e07d6b98</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Unit test</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Linspace creates a 1D tensor of size steps whose values are evenly spaced from start to end, inclusive. <br>Logspace creates a 1D tensor of size steps whose values are evenly spaced from base^start to base^end inclusive, on a logarithmic scale with base "base". </td>
                    <td class="tg-0lax">Precision of Cuda half precision computation of linspace and logspace seems bad</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor creation</td>
                    <td class="tg-0lax">testing precision, Cuda, half precision, linspace, logspace</td>
                    <td class="tg-0lax">add precision test</td>
                    <td class="tg-0lax">add test/warning</td>
                    <td class="tg-0lax">adds precision tests for CUDA half (16 bits), float (32 bits), and double (64 bits). Since linspace/logspace are deterministic, we can compute an expected<br>amount of error (by testing without a precision override), adding a tiny amount (EPS) to that, and using that value as the override.<br>EPS = 1e-5</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">LINSPACE_LOGSPACE_EXTRA_EPS = 1e-5<br>+<br> # Tests that compare a device's computation with the (gold-standard) CPU's.<br> class TestDevicePrecision(TestCase):<br>-&nbsp;&nbsp;&nbsp;&nbsp;def test_linspace(self, device):<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = torch.linspace(0, 10, 10, device=device)<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = torch.linspace(0, 10, 10)<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;# The implementation of linspace+logspace goes through a different path<br>+&nbsp;&nbsp;&nbsp;&nbsp;# when the steps arg is equal to 0 or 1. For other values of `steps`<br>+&nbsp;&nbsp;&nbsp;&nbsp;# they call specialized linspace (or logspace) kernels.<br>+&nbsp;&nbsp;&nbsp;&nbsp;LINSPACE_LOGSPACE_SPECIAL_STEPS = [0, 1]<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;def _test_linspace(self, device, dtype, steps):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = torch.linspace(0, 10, steps=steps, dtype=dtype, device=device)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = torch.linspace(0, 10, steps=steps)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(a, b)<br> <br>-&nbsp;&nbsp;&nbsp;&nbsp;@dtypes(torch.double)<br>-&nbsp;&nbsp;&nbsp;&nbsp;def test_logspace(self, device, dtype):<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = torch.logspace(1, 10, 10, dtype=dtype, device=device)<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = torch.logspace(1, 10, 10, dtype=dtype, device='cpu')<br>+&nbsp;&nbsp;&nbsp;&nbsp;# See NOTE [Linspace+Logspace precision override]<br>+&nbsp;&nbsp;&nbsp;&nbsp;@precisionOverride({torch.half: 0.0039 + LINSPACE_LOGSPACE_EXTRA_EPS})<br>+&nbsp;&nbsp;&nbsp;&nbsp;@dtypesIfCUDA(torch.half, torch.float, torch.double)<br>+&nbsp;&nbsp;&nbsp;&nbsp;@dtypes(torch.float, torch.double)<br>+&nbsp;&nbsp;&nbsp;&nbsp;def test_linspace(self, device, dtype):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._test_linspace(device, dtype, steps=10)<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;@dtypesIfCUDA(torch.half, torch.float, torch.double)<br>+&nbsp;&nbsp;&nbsp;&nbsp;@dtypes(torch.float, torch.double)<br>+&nbsp;&nbsp;&nbsp;&nbsp;def test_linspace_special_steps(self, device, dtype):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for steps in self.LINSPACE_LOGSPACE_SPECIAL_STEPS:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._test_linspace(device, dtype, steps=steps)<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;def _test_logspace(self, device, dtype, steps):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = torch.logspace(1, 1.1, steps=steps, dtype=dtype, device=device)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = torch.logspace(1, 1.1, steps=steps)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(a, b)<br> <br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Check non-default base=2<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = torch.logspace(1, 10, 10, 2, dtype=dtype, device=device)<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = torch.logspace(1, 10, 10, 2, dtype=dtype, device='cpu')<br>+&nbsp;&nbsp;&nbsp;&nbsp;def _test_logspace_base2(self, device, dtype, steps):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = torch.logspace(1, 1.1, steps=steps, base=2, dtype=dtype, device=device)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = torch.logspace(1, 1.1, steps=steps, base=2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(a, b)<br> <br>+&nbsp;&nbsp;&nbsp;&nbsp;# See NOTE [Linspace+Logspace precision override]<br>+&nbsp;&nbsp;&nbsp;&nbsp;@precisionOverride({torch.half: 0.0157 + LINSPACE_LOGSPACE_EXTRA_EPS})<br>+&nbsp;&nbsp;&nbsp;&nbsp;@dtypesIfCUDA(torch.half, torch.float, torch.double)<br>+&nbsp;&nbsp;&nbsp;&nbsp;@dtypes(torch.float, torch.double)<br>+&nbsp;&nbsp;&nbsp;&nbsp;def test_logspace(self, device, dtype):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._test_logspace(device, dtype, steps=10)<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;# See NOTE [Linspace+Logspace precision override]<br>+&nbsp;&nbsp;&nbsp;&nbsp;@precisionOverride({torch.half: 0.00201 + LINSPACE_LOGSPACE_EXTRA_EPS})<br>+&nbsp;&nbsp;&nbsp;&nbsp;@dtypesIfCUDA(torch.half, torch.float, torch.double)<br>+&nbsp;&nbsp;&nbsp;&nbsp;@dtypes(torch.float, torch.double)<br>+&nbsp;&nbsp;&nbsp;&nbsp;def test_logspace_base2(self, device, dtype):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._test_logspace_base2(device, dtype, steps=10)<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;@dtypesIfCUDA(torch.half, torch.float, torch.double)<br>+&nbsp;&nbsp;&nbsp;&nbsp;@dtypes(torch.float, torch.double)<br>+&nbsp;&nbsp;&nbsp;&nbsp;def test_logspace_special_steps(self, device, dtype):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for steps in self.LINSPACE_LOGSPACE_SPECIAL_STEPS:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._test_logspace(device, dtype, steps=steps)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._test_logspace_base2(device, dtype, steps=steps)<br>\</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">start, start + (end-start)/(steps-1), ..., start + (steps - 2) * (end-start)/(steps-1)<br><br>https://pytorch.org/docs/stable/generated/torch.logspace.html</td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">65</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">b9b9fd4fadc4d4fa0b030941a35011956eafa10b</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Disable warning</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Warning pragma enables selective modification of the behavior of compiler warning messages. The pragma warning( push ) stores the current warning state for every warning. The pragma warning( push, n ) stores the current state for every warning and sets the global warning level to n. The pragma warning( pop ) pops the last warning state pushed onto the stack. Any changes that you made to the warning state between push and pop are undone.</td>
                    <td class="tg-0lax">False arithmetic overflow warning in MSVC ( Microsoft Visual compiler for C, C++) results in code not compiling</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">overflow warning, Microsoft compiler</td>
                    <td class="tg-0lax">disable warning</td>
                    <td class="tg-0lax">disable test/warning</td>
                    <td class="tg-0lax">Disable warnings for arithmetic overflow raised by MSVC (Microsoft Visual C Compiler). Add logic to ignore warning using warning pragma: pragma warning(disable : 4146) that allows for ignoring specified warning messages. Also push and pop are used.</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">// Ignore the false warning "Arithmetic overflow" for MSVC<br>+ #ifdef _MSC_VER<br>+ # pragma warning(push)<br>+ # pragma warning(disable : 4146)<br>+ #endif<br>+<br>&nbsp;&nbsp;/// Gets the minimum value for a N-bit signed integer.<br>&nbsp;&nbsp;inline int64_t minIntN(int64_t N) {<br>&nbsp;&nbsp;&nbsp;&nbsp;assert(N &gt; 0 &amp;&amp; N &lt;= 64 &amp;&amp; "integer width out of range");<br><br>+&nbsp;&nbsp;&nbsp;return -(UINT64_C(1) &lt;&lt; (N - 1));<br>&nbsp;&nbsp;}<br> <br>+ #ifdef _MSC_VER<br>+ # pragma warning(pop)<br>+ #endif<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">66</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">ec8e75ea92ae2b5ea73b4aeb3ec7cb39e9f95db9</td>
                    <td class="tg-0lax">Cuda</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Histograms are an important data representation with many applications in computer vision, data analytics and medical imaging. Histogram is a popular analytic graphical representation of data distribution resulting from processing a given numerical input data.</td>
                    <td class="tg-0lax">Not enough bits to represent the necessary values using an int for nbins. getBin function in Cuda overflows for large bVal and nbins values =&gt; (bVal - minvalue) * nbins = inf<br></td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">Cuda histogram</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">Patch: increase precision from int (32 bits) to int64</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">&nbsp;&nbsp;t = torch.zeros([10], dtype=torch.int32, device='cuda')<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# 35488 * 65536 as int32 would cause overflow to negative value<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# giving negative bin offset<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t[0] = 35488<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counted = t.bincount(minlength=65536)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(torch.sum(counted), 10)</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">67</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">17c1b2c7159a0218a69e8486eb4212339253353a</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Saturation arithmetic is a version of arithmetic in which all operations such as addition and multiplication are limited to a fixed range between a minimum and maximum value.<br>If the result of an operation is greater than the maximum, it is set ("clamped") to the maximum; if it is below the minimum, it is clamped to the minimum. The name comes from how the value becomes "saturated" once it reaches the extreme values; further additions to a maximum or subtractions from a minimum will not change the result.<br></td>
                    <td class="tg-0lax">In quantization code,&nbsp;&nbsp;range (i.e.: the min and max values of fixed range), which is used as fallback onto default 8-bit qmin and qmax calculation if dynamic range is not used, can cause overflow</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization, range</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">Change range: relax scale and zero-point for activations to ensure that fbgemm implementations of conv and linear do not saturate due to 16 bit intermediate accumulation.&nbsp;&nbsp;But now in Pytorch: "Please use quant_min and quant_max to specify the range for observers. reduce_range will be deprecated in a future release of PyTorch."</td>
                    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if self.dtype == torch.qint8:<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qmin, qmax = -128, 127<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qmin, qmax = 0, 255</td>
                    <td class="tg-0lax">@@ -59,9 +61,15 @@ class ObserverBase(ABC, nn.Module):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if self.dtype == torch.qint8:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if self.reduce_range:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qmin, qmax = -64, 63<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qmin, qmax = -128, 127<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if self.reduce_range:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qmin, qmax = 0, 127<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qmin, qmax = 0, 255<br></td>
                    <td class="tg-0lax"> class ObserverTest(QuantizationTestCase):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@given(qdtype=st.sampled_from((torch.qint8, torch.quint8)),<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qscheme=st.sampled_from((torch.per_tensor_affine, torch.per_tensor_symmetric)))<br>-&nbsp;&nbsp;&nbsp;&nbsp;def test_minmax_observer(self, qdtype, qscheme):<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myobs = MinMaxObserver(dtype=qdtype, qscheme=qscheme)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qscheme=st.sampled_from((torch.per_tensor_affine, torch.per_tensor_symmetric)),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reduce_range=st.booleans())<br>+&nbsp;&nbsp;&nbsp;&nbsp;def test_minmax_observer(self, qdtype, qscheme, reduce_range):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# reduce_range cannot be true for symmetric quantization with uint8<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if qdtype == torch.quint8 and qscheme == torch.per_tensor_symmetric:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reduce_range = False<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myobs = MinMaxObserver(dtype=qdtype, qscheme=qscheme, reduce_range=reduce_range)</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">68</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">c845984271a551ac1c61b9eb06a17fb57aafbd7e</td>
                    <td class="tg-0lax">Cuda</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">overflow, buffer overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">A loop from i to n uses int to store the index i, which overflows after it is incremented. Overflow makes the index negative, which will also cause buffer overflow</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">looping, Cuda</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">increase precision from int to int 64</td>
                    <td class="tg-0lax"> #define CUDA_KERNEL_LOOP(i, n) \<br>for (int i = blockIdx.x * blockDim.x + threadIdx.x; i &lt; (n); i += blockDim.x * gridDim.x)</td>
                    <td class="tg-0lax"> // CUDA: grid stride looping<br>+// int64_t _i_n_d_e_x specifically prevents overflow in the loop increment.<br>+// If input.numel() &lt; INT_MAX, _i_n_d_e_x &lt; INT_MAX, except after the final<br>+// iteration of the loop where _i_n_d_e_x += blockDim.x * gridDim.x can be<br>+// greater than INT_MAX.&nbsp;&nbsp;But in that case _i_n_d_e_x &gt;= n, so there are no<br>+// further iterations and the overflowed value in i=_i_n_d_e_x is not used.<br><br> #define CUDA_KERNEL_LOOP(i, n) \<br>+&nbsp;&nbsp;int64_t _i_n_d_e_x = blockIdx.x * blockDim.x + threadIdx.x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>+&nbsp;&nbsp;for (int i=_i_n_d_e_x; _i_n_d_e_x &lt; (n); _i_n_d_e_x+=blockDim.x * gridDim.x, i=_i_n_d_e_x)<br></td>
                    <td class="tg-0lax">@unittest.skipIf(not TEST_MEDIUM_TENSOR, "not enough memory")<br>+&nbsp;&nbsp;&nbsp;&nbsp;def test_cuda_kernel_loop_overflow(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Issue #24309: In extreme cases, the loop variable could overflow and continue<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# the kernel loop with a negative index, causing a RuntimeError (invalid write):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = torch.randn(1, 1, 1, 2**30 + 1, dtype=torch.float16, device="cuda")<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expected = x[0, 0, 0, 2**30]<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = torch.nn.functional.avg_pool2d(x, kernel_size=1)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;torch.cuda.synchronize()<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(y[0, 0, 0, 2**30], expected)<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;@unittest.skipIf(not TEST_LARGE_TENSOR, "not enough memory")<br>+&nbsp;&nbsp;&nbsp;&nbsp;def test_cuda_kernel_loop_overflow_large(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Make sure input.numel() &gt; INT_MAX is handled:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = torch.randn(1, 1, 1, 2**31, dtype=torch.float16, device="cuda")<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with self.assertRaisesRegex(RuntimeError, "integer out of range"):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = torch.nn.functional.avg_pool2d(x, kernel_size=1)<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Issue #24309: In extreme cases, the loop variable could overflow and continue<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# the kernel loop with a negative index, causing a RuntimeError (invalid write):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = torch.randn(1, 1, 1, 2**31 - 1, dtype=torch.float16, device="cuda")<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expected = x[0, 0, 0, 2**31 - 2]<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = torch.nn.functional.avg_pool2d(x, kernel_size=1)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;torch.cuda.synchronize()<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(y[0, 0, 0, 2**31 - 2], expected)<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">69</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">4d2bf0b51b71f96929b58c6e23fb71d3e25440ff</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Unit test</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">backward pass output in quantization aware training was not accurate enough</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization aware training, testing precision, backward pass</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">Increase precision from float to double</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">70</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">af908d57ea07c593bb7c8db00c3139fc973b2d4c</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Unit test</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Test for quantized operations’s precision is failing in function def test_adaptive_avg_pool2d(self, X, output_size_h, output_size_w) due to double rounding</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization, precision testing, average pooling</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">Increase unittest precision tolerance to 1.0 to avoid failing</td>
                    <td class="tg-0lax">-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(X_ref, qX_repr,<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message=error_message.format(name, X_ref, qX_repr))</td>
                    <td class="tg-0lax">self.assertEqual(X_ref, qX_hat.int_repr(), prec=1.0,<br>message=error_message.format(name, X_ref, qX_hat))<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">71</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">83bfd76b2f7a9b388537eb00022622d9c6989890</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Unit test</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">absolute tolerance (atol). An absolute tolerance is a fixed number that is used to make direct comparisons</td>
                    <td class="tg-0lax">Test in function make_input(batch_size) in class ONNX Runtime (ONNX=Open Neural Network Exchange) fails <br>AssertionError:&nbsp;&nbsp;Not equal to tolerance rtol=0.001, atol=1e-07</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">GRU (Gated Recurrent Unit in RNN)</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">relax precision tolerance, absolute tolerance (atol) = 1e-5</td>
                    <td class="tg-0lax">self.run_test(model, input, batch_size=RNN_BATCH_SIZE,)</td>
                    <td class="tg-0lax">self.run_test(model, input, batch_size=RNN_BATCH_SIZE, atol=1e-5)</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">72</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">77651615c8976b6ad7ddd8abf2a62cd54b573f56</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">CHAR_BIT indicates how many bits are in a char. On almost every architecture today it's 8 bits to a char, but on some historical machines it has been 7.</td>
                    <td class="tg-0lax">The previous code mistook the number of decimal digits with the binary precision that this gemm implementation expected</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization, fbgemm</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">Use the correct number of binary precision. Interestingly, while C expects everything in terms of number of bytes, this library expects precision to be in number of bits, so CHAR_BIT must be multiplied by the result of sizeof (sizeof returns number of bytes) in order to get this number in bits.</td>
                    <td class="tg-0lax">qparams.precision = std::numeric_limits&lt;typename T::underlying&gt;::digits;</td>
                    <td class="tg-0lax">qparams.precision = CHAR_BIT * sizeof(typename T::underlying);</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">73</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">9b69f21a95fa626522ef371f8557e7286f9db318</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">The Code Generator (codegen.h/cpp) produces the string to be compiled on the device.<br>Csrc directory in Pytorch repo contains all of the code concerned with integration with Python. This is in contrast to lib, which contains the Torch libraries that are Python agnostic. csrc depends on lib, but not vice versa.<br>Jit directory contains (most of) the C++ code for the PyTorch JIT, a language and compiler stack for executing PyTorch models portably and efficiently. <br>The fuser accepts subgraphs wrapped in "fusion nodes" and tries to execute them by just-in-time (JIT) compiling kernels that run all the graph operations. fuser - identify processes using files or sockets<br>just-in-time (JIT) compilation (also dynamic translation or run-time compilations)[1] is a way of executing computer code that involves compilation during execution of a program – at run time – rather than before execution.[<br>Std::scientific <br>modifies the default formatting for floating-point input/output. <br>Specifically, write floating-point values in scientific notation<br>Sets the floatfield format flag for the str stream to scientific. When floatfield is set to scientific, floating-point values are written using scientific notation: the value is represented always with only one digit before the decimal point, followed by the decimal point and as many decimal digits as the precision field (precision). Finally, this notation always includes an exponential part consisting on the letter e followed by an optional sign and three exponential digits.<br>Std::setprecision<br>When used in an expression out &lt;&lt; setprecision(n) or in &gt;&gt; setprecision(n), sets the precision parameter of the stream out or in to exactly n.</td>
                    <td class="tg-0lax">low precision emitted for prim:: Constant</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">code generation for compiler, fuser, JIT</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">Patch 1: Emit higher precision literal for float values v in the fusion kernel using std::setprecision instead of std::scietific.<br>Patch 2: increase precision in code that sets variable types: int to int 64 and float to double<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">// Note: The NAN, NEG_INFINITY and POS_INFINITY strings map to device-specific<br>// implementations of these special values. These macros are found in the<br>// resource strings for each device.<br>static std::string scalarValue(const double v) {<br>&nbsp;&nbsp;std::ostringstream out;<br>&nbsp;&nbsp;if (std::isnan(v)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;out &lt;&lt; "NAN";<br>&nbsp;&nbsp;} else if (std::isinf(v)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (v &lt; 0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out &lt;&lt; "NEG_INFINITY";<br>&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out &lt;&lt; "POS_INFINITY";<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;out &lt;&lt; std::setprecision(16) &lt;&lt; v;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;return out.str();<br>}</td>
                    <td class="tg-0lax">@unittest.skipIf(RUN_CUDA, 'This tests the CPU fuser')<br>+&nbsp;&nbsp;&nbsp;&nbsp;@unittest.skipIf(IS_WINDOWS or IS_SANDCASTLE, "NYI: fuser support for Windows or Sandcastle")<br>+&nbsp;&nbsp;&nbsp;&nbsp;@enable_cpu_fuser<br>+&nbsp;&nbsp;&nbsp;&nbsp;def test_fuser_double_literal_precision(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;code = '''<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;graph(%2 : Float(*, *)):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%4 : int = prim::Constant[value=1]()<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%3 : float = prim::Constant[value=1.282549830161864]()<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%5 : Float(*, *) = aten::add(%2, %3, %4)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%1 : Float(*, *) = aten::relu(%5)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (%1)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'''<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;graph = parse_ir(code)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;code = torch._C._jit_fuser_get_fused_kernel_code(graph, [torch.rand(3, 4)])<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileCheck().check('1.282549830161864').run(code)<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">74</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">8e1e29124de99c01d08a2e2c02455c72335a971d</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">In various distributions (bernoulli, binomial, etc.) the expansion method chooses to use probabilities over logits, which results in loss of precision</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">distributions</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">In method “expand(self, batch_shape, _instance=None)” of the distribution class change logic of preference of probabilities and logits<br>If logits are available, use them over probabilities (not the other way around)<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">75</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">2ed95c58713b45a6a9dac4336135523555bc58a9</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Disable warning</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">error from Microsoft compiler when building</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">Micsrosoft C++ compiler, Converter</td>
                    <td class="tg-0lax">disable warning</td>
                    <td class="tg-0lax">disable test/warning</td>
                    <td class="tg-0lax">disable warning using pragma warning disable</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">#ifdef _MSC_VER<br>+#pragma warning( disable : 4146 )<br>+#endif<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">76</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">dc72a5e02c1ecb105ea58cafcf10ef3a6f7d9c25</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">underflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">CV refers to OpenCV and rotatedRectangleIntersection is a function in OpenCV library<br>rotatedRectangleIntersection finds out if there is any intersection between two rotated rectangles.<br><br>int cv::rotatedRectangleIntersection	(	const RotatedRect &amp; 	rect1,<br>const RotatedRect &amp; 	rect2,<br>OutputArray 	intersectingRegion <br>)	</td>
                    <td class="tg-0lax">cv::rotatedRectangleIntersection has a known float underflow bug that would cause failure in ```CV_Assert(intersection.size() &lt;= 8)```, Problem reported in OpenCV<br></td>
                    <td class="tg-0lax">data processing</td>
                    <td class="tg-0lax">image processing</td>
                    <td class="tg-0lax">OpenCV, rotated triangele intersection</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Replace rotatedRectangleIntersection with custom made replacement function cvfix_rotatedRectangleIntersection. When OpenCV version is upgraded to be &gt;= 4.0, we can remove this replacement function.<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">77</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">4b97a4642100e26d14c34c07c31643422d60ac48</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Disable warning</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">compilation error due to signed overflow</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiling</td>
                    <td class="tg-0lax">disable warning</td>
                    <td class="tg-0lax">disable test/warning</td>
                    <td class="tg-0lax">Disable strict-overflow flag to avoid compilation error</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">ADD_COMPILE_OPTIONS(-Wno-strict-overflow)<br>ADD_COMPILE_OPTIONS(-Wno-error=strict-overflow)<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">78</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">55b25365e9e11ee4d9dfb02ff1c79081225c7bd1</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">New feature</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">non-standard precision</td>
                    <td class="tg-0lax">non-standard precision</td>
                    <td class="tg-0lax">quantization, low precision computations</td>
                    <td class="tg-0lax">add new algorithm</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">Add feature to allow 8 bit precision values (ultra low precision)</td>
                    <td class="tg-0lax">is_same&lt;T, uint8_t&gt;::value &amp;&amp; GetCpuId().avx2();</td>
                    <td class="tg-0lax">is_same&lt;T, uint8_t&gt;::value &amp;&amp; GetCpuId().avx2() &amp;&amp;<br>!FLAGS_caffe2_dnnlowp_force_slow_path;<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">79</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">efd2aeac9e03a8813ba37db98e1a7645fa2902be</td>
                    <td class="tg-0lax">txt</td>
                    <td class="tg-0lax">Disable warning</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Wno-stringop-overflow uses Object Size Checking to determine the sizes of destination objects</td>
                    <td class="tg-0lax">stringop-overflow flag is added in only in GCC 7</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">GCC compiler flags</td>
                    <td class="tg-0lax">disable warning</td>
                    <td class="tg-0lax">disable test/warning</td>
                    <td class="tg-0lax">Change logic for compiler flag Wno-stringop-overflow. Set it only if GCC compiler version &gt;= 7</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">if (CMAKE_COMPILER_IS_GNUCXX AND NOT (CMAKE_CXX_COMPILER_VERSION VERSION_LESS 7.0.0))<br>+&nbsp;&nbsp;&nbsp;&nbsp;set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-stringop-overflow")<br>+&nbsp;&nbsp;endif()<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">80</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">d97c9dd01904ff423554345cd877ebc1e520c21e</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Add warning</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Check gradients computed via small finite differences against analytical<br>&nbsp;&nbsp;&nbsp;&nbsp;gradients w.r.t. tensors in :attr:`inputs` that are of floating point or complex type<br>&nbsp;&nbsp;&nbsp;&nbsp;and with ``requires_grad=True``.<br>&nbsp;&nbsp;&nbsp;&nbsp;The check between numerical and analytical gradients uses :func:`~torch.allclose`.<br>&nbsp;&nbsp;&nbsp;&nbsp;For most of the complex functions we consider for optimization purposes, no notion of<br>&nbsp;&nbsp;&nbsp;&nbsp;Jacobian exists. Instead, gradcheck verifies if the numerical and analytical values of<br>&nbsp;&nbsp;&nbsp;&nbsp;the Wirtinger and Conjugate Wirtinger derivatives are consistent. Because the gradient<br>&nbsp;&nbsp;&nbsp;&nbsp;computation is done under the assumption that the overall function has a real-valued<br>&nbsp;&nbsp;&nbsp;&nbsp;output, we treat functions with complex output in a special way. For these functions,<br>&nbsp;&nbsp;&nbsp;&nbsp;gradcheck is applied to two real-valued functions corresponding to taking the real<br>&nbsp;&nbsp;&nbsp;&nbsp;components of the complex outputs for the first, and taking the imaginary components<br>&nbsp;&nbsp;&nbsp;&nbsp;of the complex outputs for the second. For more details, check out<br>&nbsp;&nbsp;&nbsp;&nbsp;:ref:`complex_autograd-doc`.</td>
                    <td class="tg-0lax">failure of gradient check between numerical and anlytical gradients due to low precision input (the input is numerical gradients)</td>
                    <td class="tg-0lax">gradients/derivatives</td>
                    <td class="tg-0lax">automatic differentiation</td>
                    <td class="tg-0lax">gradients, autograd, testing precision</td>
                    <td class="tg-0lax">add precision warning</td>
                    <td class="tg-0lax">add test/warning</td>
                    <td class="tg-0lax">Add a warning for gradients that require a check between numerical and analytical gradients need to be of double precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">81</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">4d287f90743e09d1fdc6e2b3519b16c2d1ae3fa3</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">for loop index overflow if input vector is large</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">loop index, low level math, summation of scalars</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">increase precision from int to int 64</td>
                    <td class="tg-0lax">for (int i = k * WIDTH; i != size; i++)</td>
                    <td class="tg-0lax">Patch: increase precision from int to int 64<br>@@ -102,7 +102,7 @@ struct Reduction {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum = std::accumulate(buf, buf + WIDTH, scalar_t(ident), ReduceScalar());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>+&nbsp;&nbsp;&nbsp;&nbsp;for (int64_t i = k * WIDTH; i != size; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum = ReduceScalar()(sum, data[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return sum;<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">82</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">7cbe63da8621b6063c864527592db6b1c894804f</td>
                    <td class="tg-0lax">Cuda</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">Distributions (Multinomial), THT Tensor Random,<br>binarySearchForMultinomial</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">&nbsp;&nbsp;// first non-zero element by setting start to size-1 here,<br>+&nbsp;&nbsp;&nbsp;&nbsp;// the code below will move it to the last non-zero probability<br>+&nbsp;&nbsp;&nbsp;&nbsp;// this actually can happen when the random number is 1<br></td>
                    <td class="tg-0lax">start = 0;</td>
                    <td class="tg-0lax">start = size - 1;</td>
                    <td class="tg-0lax"># Test a corner case from older PyTorch (Issue #4858)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqs = torch.cuda.FloatTensor([<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.03178183361887932, 0.027680952101945877, 0.033176131546497345,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.046052902936935425, 0.07742464542388916, 0.11543981730937958,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.14148041605949402, 0.15784293413162231, 0.13180233538150787,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.08271478116512299, 0.049702685326337814, 0.027557924389839172,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.018125897273421288, 0.011851548217236996, 0.010252203792333603,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.007422595750540495, 0.005372154992073774, 0.0045109698548913,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0036087757907807827, 0.0035267581697553396, 0.0018864056328311563,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0024605290964245796, 0.0022964938543736935, 0.0018453967059031129,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0010662291897460818, 0.0009842115687206388, 0.00045109697384759784,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0007791675161570311, 0.00020504408166743815, 0.00020504408166743815,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00020504408166743815, 0.00012302644609007984, 0.0,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00012302644609007984, 4.100881778867915e-05, 0.0, 0.0, 0.0, 0.0,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 0.0])<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;torch.cuda.manual_seed(11042)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sample = torch.multinomial(freqs, 1000, True)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertNotEqual(freqs[sample].min(), 0)</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">83</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">0167f76d2a99ced5f4359d8ea77eb6704179b797</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Unit test</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">An absolute tolerance is a fixed number that is used to make direct comparisons. <br>Rtol = relative tolerance<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">precision tests/speed benchmarks</td>
                    <td class="tg-0lax">accuracy testing</td>
                    <td class="tg-0lax">testing precision, external to pytorch, onnx</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">Relax precision, specifically, add absolute tolerance (atol).</td>
                    <td class="tg-0lax"> np.testing.assert_allclose(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ref_outputs[i],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outputs[i],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rtol=1e-3)</td>
                    <td class="tg-0lax">np.testing.assert_allclose(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ref_outputs[i],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outputs[i],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rtol=1e-3,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;atol=1e-7)</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">84</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">4b8f4fc25902e3a325b06e2db415bba9fad7c0ef</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">New feature</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">non-standard precision</td>
                    <td class="tg-0lax">non-standard precision</td>
                    <td class="tg-0lax">mixed precision, training</td>
                    <td class="tg-0lax">add new precision option</td>
                    <td class="tg-0lax">add new precision option</td>
                    <td class="tg-0lax">allow mixed precision in distributed training</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">85</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">873f1163806c14ae236538f76c44d04b63bef331</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Unit test</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">The STFT computes the Fourier transform of short overlapping windows of the input. This giving frequency components of the signal as they change over time. The interface of this function is modeled after the librosa stft function.</td>
                    <td class="tg-0lax">STFT (short time fourier transform) precision test not passing</td>
                    <td class="tg-0lax">precision tests/speed benchmarks</td>
                    <td class="tg-0lax">accuracy testing</td>
                    <td class="tg-0lax">testing precision, fourier transform</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">increase precision tolerance in assertEqual from 5e-6 to 7e-6</td>
                    <td class="tg-0lax">self.assertEqual(result.data, ref_result, 5e-6, 'stft result')</td>
                    <td class="tg-0lax">self.assertEqual(result.data, ref_result, 7e-6, 'stft result')</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">86</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">f9fd82d8933639a8cf20a029c7fa47fff8fdb93d</td>
                    <td class="tg-0lax">Cuda</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">__half2float = defined in cuda: cuda_fp16.h. Converts half number to float.<br>ScalarConvert = defined cvd library<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">non-standard precision</td>
                    <td class="tg-0lax">non-standard precision</td>
                    <td class="tg-0lax">mixed precision, sigmoid</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">Change how to convert half precision variables to float in struct TensorSigmoidOp. Use ScalarConvert instead of __half2float. Change float to accreal, which is int64_t</td>
                    <td class="tg-0lax">-&nbsp;&nbsp;&nbsp;&nbsp;float fin = __half2float(*in);<br>-&nbsp;&nbsp;&nbsp;&nbsp;*out = __float2half(1.0f / (1.0f + expf(- fin)));<br><br>-#define H2F(input) __half2float(input)<br>-#define F2H(input) __float2half(input)<br><br></td>
                    <td class="tg-0lax"> float fin = ScalarConvert&lt;half, float&gt;::to(*in);<br>+&nbsp;&nbsp;&nbsp;&nbsp;*out = ScalarConvert&lt;float, half&gt;::to(1.0f / (1.0f + expf(- fin)));<br><br>+#define H2F(input) ScalarConvert&lt;real, accreal&gt;::to(input)<br>+#define F2H(input) ScalarConvert&lt;accreal, real&gt;::to(input)<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">87</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">35abc4efa2d08ef2e9b7d978089fbd98b8d14187</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">New feature</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax">torch.digamma(input, *, out=None) → Tensor Computes the logarithmic derivative of the gamma function on input. <br>torch.polygamma(n, input, *, out=None) → Tensor Computes the nth derivative of the digamma function on input. n≥0 is called the order of the polygamma function.</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">gradients/derivatives</td>
                    <td class="tg-0lax">derivatives</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">add new precision option</td>
                    <td class="tg-0lax">add new precision option</td>
                    <td class="tg-0lax">Add low-precision digamma() and polygamma() functions</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">def test_digamma(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def test(use_double=False):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cpu_tensor = torch.randn(10, 10, 10)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpu_tensor = cpu_tensor.cuda()<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zeros = torch.zeros(10, 10, 10)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (use_double):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cpu_tensor = cpu_tensor.double()<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpu_tensor = gpu_tensor.double()<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zeros = zeros.double()<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cpu_out = cpu_tensor.digamma()<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpu_out = gpu_tensor.digamma()<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;norm_errors = (gpu_out - cpu_out.cuda()) / gpu_out<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(norm_errors, zeros)<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test(True)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test(False)<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;def test_polygamma(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def test(use_double=False):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cpu_tensor = torch.randn(10, 10, 10)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpu_tensor = cpu_tensor.cuda()<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zeros = torch.zeros(10, 10, 10)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (use_double):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cpu_tensor = cpu_tensor.double()<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpu_tensor = gpu_tensor.double()<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zeros = zeros.double()<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for n in [0, 1]:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cpu_out = cpu_tensor.polygamma(n)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpu_out = gpu_tensor.polygamma(n)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;norm_errors = (gpu_out - cpu_out.cuda()) / gpu_out<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(norm_errors, zeros)</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">log, derivative</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">88</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">0443c11f7e4d14dfe5f5b23f4112a4c443d95a9c</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Volta is the codename for a GPU microarchitecture developed by Nvidia<br>The major revision number is 7 for devices based on the Volta architecture, 6 for devices based on the Pascal architecture, 5 for devices based on the Maxwell architecture, 3 for devices based on the Kepler architecture, 2 for devices based on the Fermi architecture, and 1 for devices based on the Tesla architecture.<br><br>torch.cuda.get_device_capability(device=None)<br>Gets the cuda capability of a device.<br>Return type: tuple(int, int)<br>Returns: the major and minor cuda capability of the device<br><br></td>
                    <td class="tg-0lax">pre-volta architecture (i.e.: prior to cuda major version 7) half precision needs special handling</td>
                    <td class="tg-0lax">non-standard precision</td>
                    <td class="tg-0lax">non-standard precision</td>
                    <td class="tg-0lax">GPU, cuDNN, RNN, half precision, hardware</td>
                    <td class="tg-0lax">check hardware</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">Fix half precision for older (pre-volta) NVIDIA cards. Add in additional logic for checking major cuda capability of currently selected device - check if major cuda capability is greater than 7.</td>
                    <td class="tg-0lax">-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if version() &gt;= 7000 and int(cuda[0]) &gt;= 9:<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lib.cudnnSetRNNMatrixMathType(self, CUDNN_DEFAULT_MATH)<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if datatype == CUDNN_DATA_HALF:<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lib.cudnnSetRNNMatrixMathType(self, CUDNN_TENSOR_OP_MATH)</td>
                    <td class="tg-0lax"> if version() &gt;= 7000 and int(cuda[0]) &gt;= 9 and (<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;torch.cuda.get_device_capability(torch.cuda.current_device())[0] &gt;= 7):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lib.cudnnSetRNNMatrixMathType(self, CUDNN_DEFAULT_MATH)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if datatype == CUDNN_DATA_HALF:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lib.cudnnSetRNNMatrixMathType(self, CUDNN_TENSOR_OP_MATH)<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">89</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">f7a459b28b184dedf265ed8718f85cb483e8284e</td>
                    <td class="tg-0lax">Cuda</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">MAGMA is a collection of next generation linear algebra (LA) GPU accelerated libraries designed and implemented by the team that developed LAPACK and ScaLAPACK.</td>
                    <td class="tg-0lax">overflow when using magma<br>Ints are commonly only 32 bits. An int should not be used for a size. If you index an array of floats with an int, you can only store up to 8 GB of data in that array, much smaller than many workloads require.</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">external library</td>
                    <td class="tg-0lax">extranal library, linear algebra</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">Use a 64 bit value for size.</td>
                    <td class="tg-0lax">-&nbsp;&nbsp;int n = a_-&gt;size[0];<br>-&nbsp;&nbsp;int nrhs = b_-&gt;size[1];</td>
                    <td class="tg-0lax">int64_t n = a_-&gt;size[0];<br>+&nbsp;&nbsp;int64_t nrhs = b_-&gt;size[1];<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">90</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">30bbeb8b87ef815d8a7ce8ab8af9a301fcedfbe9</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Change exception to a warning</td>
                    <td class="tg-0lax">overflow, precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">exception due to check requiring that type conversions are exact</td>
                    <td class="tg-0lax">precision tests/speed benchmarks</td>
                    <td class="tg-0lax">accuracy testing</td>
                    <td class="tg-0lax">scalars, overflow check, precision check</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">relax type conversion check - only throw an exception if overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">91</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">a92fce18715be7317b5eab1319140899b355eb9f</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Unit test</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">cpu and gpu gradients are not exact</td>
                    <td class="tg-0lax">precision tests/speed benchmarks</td>
                    <td class="tg-0lax">accuracy testing</td>
                    <td class="tg-0lax">precision testing, testing that cpu and cuda gradients are equal</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">Relax precision tolerance from 0 to 5e-5 for comparing cpu and gpu gradients</td>
                    <td class="tg-0lax">self.assertEqual(grid_cpu.grad, grid_cuda.grad)</td>
                    <td class="tg-0lax">self.assertEqual(grid_cpu.grad, grid_cuda.grad, prec=5e-5)</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">92</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">4c35c630eca9a7a3fbfc8f4bc72ea2fd5ba0dd05</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Unit test</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">precision tests/speed benchmarks</td>
                    <td class="tg-0lax">accuracy testing</td>
                    <td class="tg-0lax">gradient check</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">Enable norm gradgradchecks by lowering precision requirements. Add absolute and relative tolerance precision based on empirical observations</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">gradgradcheck_precision_override = {<br>+&nbsp;&nbsp;&nbsp;&nbsp;'test_NormFunction_1_5': {'atol': 1e-2, 'rtol': 1e-2},<br>+&nbsp;&nbsp;&nbsp;&nbsp;'test_NormFunction_2': {'atol': 1e-2, 'rtol': 1e-2},<br>+&nbsp;&nbsp;&nbsp;&nbsp;'test_NormFunction_3': {'atol': 5e-2, 'rtol': 1e-2},<br>+}<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if test_name in gradgradcheck_precision_override:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;atol = gradgradcheck_precision_override[test_name]['atol']<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rtol = gradgradcheck_precision_override[test_name]['rtol']<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertTrue(gradgradcheck(apply_fn, input, grad_y, atol=atol, rtol=rtol))<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">93</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">eaacfc7e25c0500f933b0c68e63f1d947739df90</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Speed optimization</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Performance issue in momentum update of SGD due to repeatedly converting gradient from 16 bits to 32 and vice versa. cuda was allocating and freeing chunks of memory frequently because grad was changing sizes</td>
                    <td class="tg-0lax">optimizers</td>
                    <td class="tg-0lax">optimizers</td>
                    <td class="tg-0lax">SGD optimizer, momentum update</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">Set grad to a predetermined size of fp_32 so cuda no longer needs to alloc/free this frequently.</td>
                    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net.MomentumSGDUpdate(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[grad_fp32, momentum_data, lr, param_fp32],<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[grad, momentum_data, param_fp32],</td>
                    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net.MomentumSGDUpdate(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[grad_fp32, momentum_data, lr, param_fp32],<br>param_fp32],<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[grad_fp32, momentum_data, param_fp32],<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">94</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">1f4317be3f02d84e93303193e782c1cb002b26e3</td>
                    <td class="tg-0lax">Cuda, C++</td>
                    <td class="tg-0lax">New feature</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax">ollectives = collective communication in distributed computing<br>Gloo backend for distributed CPU training</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">non-standard precision</td>
                    <td class="tg-0lax">non-standard precision</td>
                    <td class="tg-0lax">Distributed training, half precision</td>
                    <td class="tg-0lax">add new precision option</td>
                    <td class="tg-0lax">add new precision option</td>
                    <td class="tg-0lax">Add support for collectives over vectors of half-precision floating point values</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">95</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">aec182ae72d51dad0f46cdfe7ff9a41380d7da35</td>
                    <td class="tg-0lax">Cuda</td>
                    <td class="tg-0lax">New feature</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax">Performs a batch matrix-matrix product of matrices in batch1 and batch2. input is added to the final result.<br><br>batch1 and batch2 must be 3-D tensors each containing the same number of matrices.</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">linear algebra</td>
                    <td class="tg-0lax">linear algebra</td>
                    <td class="tg-0lax">tensor math, linear algebra</td>
                    <td class="tg-0lax">add new precision option</td>
                    <td class="tg-0lax">add new precision option</td>
                    <td class="tg-0lax">add support for half precision in tensormath blas in BADDBMM (batch</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">96</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">1bf7bc9768fa3f768419884595e08b3bc25913ea</td>
                    <td class="tg-0lax">Cuda</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">One often wants the type for the accumulator to be of higher precision than the inputs. When accumulating (summation for example), error will build up more.</td>
                    <td class="tg-0lax">sum accumulator had insufficient precision</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">distributions (multinomial)</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">change data type for accumulator from T to AccT and add assertion to make sure the sum of distribution did not overflow (i.e.: is not inf)</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">assert(!isinf(sum));</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">97</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">c1ba0fbab3ad3f1a4b2630de9629c4749469eada</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">New feature</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">non-standard precision</td>
                    <td class="tg-0lax">non-standard precision</td>
                    <td class="tg-0lax">cuDNN, ReLu, mixed precision</td>
                    <td class="tg-0lax">add new precision option</td>
                    <td class="tg-0lax">add new precision option</td>
                    <td class="tg-0lax">Decide at runtime which precision of types to use</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">98</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">26516f667e688ed38c8ded71af8e1abc3a56d5ee</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Unit test</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">statistics</td>
                    <td class="tg-0lax">testing precision, mean, standard deviation</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">relax precision tolerance in assertEqual</td>
                    <td class="tg-0lax">-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(r[:,:50].std(), 4, 0.2)<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(r[:,:50].std(), 4, 0.2)<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(q.mean(), 2, 0.1)<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(q.std(), 3, 0.1)<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(q.mean(), 0, 0.1)<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(q.std(), 1, 0.1)<br></td>
                    <td class="tg-0lax">&nbsp;&nbsp;self.assertEqual(r[:,:50].std(), 4, 0.3)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(r[:,:50].std(), 4, 0.3)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(q.mean(), 2, 0.3)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(q.std(), 3, 0.3)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(q.mean(), 0, 0.2)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(q.std(), 1, 0.2)<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">99</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">cd780eb9ec20827a924c658b5960be452797076d</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Speed optimization</td>
                    <td class="tg-0lax">underflow checking</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">AXPBY Scales two vectors, adds them to one another and stores result in the vector.<br>In this case the type is double (daxpby)<br>?axpby perform vector vector operation defined as y:= a*x + b*y, where a and b are scalars and x and y are vectors of length n<br></td>
                    <td class="tg-0lax">In caffe2 CPU math using MKL (MKL is an optimized Intel math library) function CAFFE2_SPECIALIZED_AXPBY(double, d) suffers from underlow.<br>When running caffe2 experiments that calling Exp with many values close to 0 causes MKL's underflow error handler to be called repeatedly, causing significant overhead while the result is correct (e.g. exp(x) = 0). </td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">external library</td>
                    <td class="tg-0lax">extermal library (MKL), exp, caffe2,</td>
                    <td class="tg-0lax">disable warning</td>
                    <td class="tg-0lax">disable test/warning</td>
                    <td class="tg-0lax">Disable MKL's underflow checker to speed up operation by setting the error mode to VML_ERRMODE_IGNORE</td>
                    <td class="tg-0lax">-#define DELEGATE_SIMPLE_UNARY_FUNCTION(T, Funcname, OriginalFunc)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>-template &lt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>-void Funcname&lt;T, CPUContext&gt;(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>-&nbsp;&nbsp;&nbsp;&nbsp;const int N, const T* x, T* y,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>-&nbsp;&nbsp;&nbsp;&nbsp;CPUContext* context) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>-&nbsp;&nbsp;OriginalFunc(N, x, y);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>-}<br>-DELEGATE_SIMPLE_UNARY_FUNCTION(float, Exp, vsExp)<br>-DELEGATE_SIMPLE_UNARY_FUNCTION(double, Exp, vdExp)</td>
                    <td class="tg-0lax">#define DELEGATE_SIMPLE_UNARY_FUNCTION(T, Funcname, OriginalFunc, ...) \<br>+&nbsp;&nbsp;template &lt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>+&nbsp;&nbsp;void Funcname&lt;T, CPUContext&gt;(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int N, const T* x, T* y, CPUContext* context) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>+&nbsp;&nbsp;&nbsp;&nbsp;OriginalFunc(N, x, y, ##__VA_ARGS__);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>+&nbsp;&nbsp;}<br>+DELEGATE_SIMPLE_UNARY_FUNCTION(<br>+&nbsp;&nbsp;&nbsp;&nbsp;float,<br>+&nbsp;&nbsp;&nbsp;&nbsp;Exp,<br>+&nbsp;&nbsp;&nbsp;&nbsp;vmsExp,<br>+&nbsp;&nbsp;&nbsp;&nbsp;VML_HA | VML_FTZDAZ_OFF | VML_ERRMODE_IGNORE)<br>+DELEGATE_SIMPLE_UNARY_FUNCTION(<br>+&nbsp;&nbsp;&nbsp;&nbsp;double,<br>+&nbsp;&nbsp;&nbsp;&nbsp;Exp,<br>+&nbsp;&nbsp;&nbsp;&nbsp;vmdExp,<br>+&nbsp;&nbsp;&nbsp;&nbsp;VML_HA | VML_FTZDAZ_OFF | VML_ERRMODE_IGNORE)<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">100</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">206029bc5a3f179abe97986641ed3ccd3c414126</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Integer literals are of type int, size index variable overflows if input tensor very big, specifically when input &gt; 2GB).</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">external library</td>
                    <td class="tg-0lax">external library, caffe2</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">Increase precision of variable that holds tensor size from int 32 to int 64. Instead of passing in an integer literal, do a static cast on an integer literal to a larger datatype for the accumulator type</td>
                    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;auto newSize = std::accumulate(<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newDims.begin(), newDims.end(), 1, std::multiplies&lt;TIndex&gt;());<br><br>@@ -180,7 +183,10 @@ class Tensor {<br>&nbsp;&nbsp;&nbsp;template &lt;class T, class ContextForCopy&gt;<br>&nbsp;&nbsp;&nbsp;void Reserve(const std::vector&lt;T&gt;&amp; newCapacity, ContextForCopy* context) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;auto newSize = std::accumulate(<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newCapacity.begin(), newCapacity.end(), 1, std::multiplies&lt;TIndex&gt;());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (newSize * meta_.itemsize() &lt;= capacity_) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>@@ -208,7 +214,10 @@ class Tensor {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"New outer dimension must be smaller than current.");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dims_[0] = outer_dim;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_ = std::accumulate(<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dims_.begin(), dims_.end(), 1, std::multiplies&lt;TIndex&gt;());<br>&nbsp;&nbsp;&nbsp;}<br></td>
                    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;auto newSize = std::accumulate(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newDims.begin(),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newDims.end(),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static_cast&lt;TIndex&gt;(1),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::multiplies&lt;TIndex&gt;());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (newSize * meta_.itemsize() &lt;= capacity_) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dims_ = newDims;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_ = newSize;<br>@@ -180,7 +183,10 @@ class Tensor {<br>&nbsp;&nbsp;&nbsp;template &lt;class T, class ContextForCopy&gt;<br>&nbsp;&nbsp;&nbsp;void Reserve(const std::vector&lt;T&gt;&amp; newCapacity, ContextForCopy* context) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;auto newSize = std::accumulate(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newCapacity.begin(),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newCapacity.end(),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static_cast&lt;TIndex&gt;(1),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::multiplies&lt;TIndex&gt;());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (newSize * meta_.itemsize() &lt;= capacity_) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>@@ -208,7 +214,10 @@ class Tensor {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"New outer dimension must be smaller than current.");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dims_[0] = outer_dim;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_ = std::accumulate(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dims_.begin(),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dims_.end(),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static_cast&lt;TIndex&gt;(1),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::multiplies&lt;TIndex&gt;());<br>&nbsp;&nbsp;&nbsp;}<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">101</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">5030d76acfcdd48492e988e3fc1aa19bebe9366a</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">linear algebra</td>
                    <td class="tg-0lax">linear algebra</td>
                    <td class="tg-0lax">precision testing for CUDA blas</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">reduce precision of CUDA blas tests</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"> custom_precision = {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'addbmm': 1e-4,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'addmm': 1e-4,<br>+&nbsp;&nbsp;&nbsp;&nbsp;'addmv': 1e-4,<br>+&nbsp;&nbsp;&nbsp;&nbsp;'addr': 1e-4,<br>+&nbsp;&nbsp;&nbsp;&nbsp;'baddbmm': 1e-4,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'rsqrt': 1e-4,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'cumprod': 1e-4,<br> }<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">102</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">a489884da4b63e33ede107261afd6a4a81d9401a</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Unit test</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">torch.addmm(input, mat1, mat2, *, beta=1, alpha=1, out=None) → Tensor Performs a matrix multiplication of the matrices mat1 and mat2. The matrix input is added to the final result. alpha and beta are scaling factors on matrix-vector product between mat1 and mat2 and the added matrix input respectively.<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">linear algebra</td>
                    <td class="tg-0lax">linear algebra</td>
                    <td class="tg-0lax">precision testing for matrix multiply</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">Reduce precision of addmm CUDA test</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"> custom_precision = {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'addbmm': 1e-4,<br>+&nbsp;&nbsp;&nbsp;&nbsp;'addmm': 1e-4,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'rsqrt': 1e-4,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'cumprod': 1e-4,<br> }<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">out = Beta * input + Alpha * (mat1_i @ mat2_i)</td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">103</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">a0fb1ab86e88d5c98733d7e6e5aa3b5811fe24f4</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Unit test</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">torch.rsqrt(input, *, out=None) → Tensor Returns a new tensor with the reciprocal of the square-root of each of the elements of input.</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">linear algebra</td>
                    <td class="tg-0lax">linear algebra</td>
                    <td class="tg-0lax">precision testing for matrix multiply and square root</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">Reduce precision for addmm and rsqrt CUDA tests</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">out_i = 1/(sqrt(input_i))</td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">104</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">f7fe6cf1a6a58c55335e1b337dbdd23a78a2f74a</td>
                    <td class="tg-0lax">C</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">multinomial distribution</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">Using higher precision type for accumulator</td>
                    <td class="tg-0lax">void THTensor_(multinomial)(THLongTensor *self, THGenerator *_generator, THTenso<br>&nbsp;&nbsp;&nbsp;for (i=0; i&lt;n_dist; i++)<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Get normalized cumulative distribution from prob distribution */<br>-&nbsp;&nbsp;&nbsp;&nbsp;real sum = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (j=0; j&lt;n_categories; j++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum += THStorage_(get)( \<br>@@ -160,7 +160,7 @@ void THTensor_(multinomial)(THLongTensor *self, THGenerator *_generator, THTenso<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* update cumulative distribution so that sample cannot be drawn again */<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real diff;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real new_val = 0;<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real sum;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (sample_idx != 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br></td>
                    <td class="tg-0lax">void THTensor_(multinomial)(THLongTensor *self, THGenerator *_generator, THTenso<br>&nbsp;&nbsp;&nbsp;for (i=0; i&lt;n_dist; i++)<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Get normalized cumulative distribution from prob distribution */<br>+&nbsp;&nbsp;&nbsp;&nbsp;accreal sum = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (j=0; j&lt;n_categories; j++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum += THStorage_(get)( \<br>@@ -160,7 +160,7 @@ void THTensor_(multinomial)(THLongTensor *self, THGenerator *_generator, THTenso<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* update cumulative distribution so that sample cannot be drawn again */<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real diff;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real new_val = 0;<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accreal sum;<br> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (sample_idx != 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">105</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">2ccbbdb4b06bf0d60d02c7cf316fce117b77df55</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">softmax output is NaN</td>
                    <td class="tg-0lax">overflow/underflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Direct calculation of the softmax function according to its definition formula&nbsp;&nbsp;is conjugate with numerical issues. Single-precision exp(x) function overflows<br>for x &gt; 89 and underflows for x &lt; −104, and, in turn, cause NaN outputs in the na¨ıve implementations.</td>
                    <td class="tg-0lax">activation functions</td>
                    <td class="tg-0lax">activation functions</td>
                    <td class="tg-0lax">softmax, openGL</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Implement a tree pass softmax algorithm, see algorithm in https://arxiv.org/pdf/2001.04438.pdf</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">softmax</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">106</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">115623e2fc21affeaeee5167daec9c1f0db27069</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">softmax output is NaN</td>
                    <td class="tg-0lax">overflow/underflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Direct calculation of the softmax function according to its definition formula&nbsp;&nbsp;is conjugate with numerical issues. Single-precision exp(x) function overflows<br>for x &gt; 89 and underflows for x &lt; −104, and, in turn, cause NaN outputs in the na¨ıve implementations.</td>
                    <td class="tg-0lax">activation functions</td>
                    <td class="tg-0lax">activation functions</td>
                    <td class="tg-0lax">softmax, openCL</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Implement a tree pass softmax algorithm, see algorithm in https://arxiv.org/pdf/2001.04438.pdf</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">softmax</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">107</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">e665a737f90564cd143fdc1b15420720596d17e1</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">statistics</td>
                    <td class="tg-0lax">mean test</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">auto input_rng = std::bind(<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::uniform_real_distribution&lt;float&gt;(-15.0f, 15.0f), std::ref(rng));<br></td>
                    <td class="tg-0lax">auto input_rng =<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::bind(std::uniform_real_distribution&lt;float&gt;(), std::ref(rng));</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">108</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">e60c1ba960e598be9c0e0cdd331cdc10e8919dbb</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">activation functions</td>
                    <td class="tg-0lax">activation functions</td>
                    <td class="tg-0lax">LSTM, logistic function</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"> XlaOp Logistic(XlaOp x) {<br>-&nbsp;&nbsp;auto half = xla::ScalarLike(x, 0.5);<br>-&nbsp;&nbsp;return half + half * xla::Tanh(half * x);<br> }</td>
                    <td class="tg-0lax"> XlaOp Logistic(XlaOp x) {<br>+&nbsp;&nbsp;auto one = xla::ScalarLike(x, 1);<br>+&nbsp;&nbsp;return xla::Div(one, (one + xla::Exp(xla::Neg(x))));<br> }</td>
                    <td class="tg-0lax">def testFloatOpsDisabledOnMlirBridge(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;for dtype in self.float_types:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if dtype != np.float16:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._assertOpOutputMatchesExpected(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lambda x: math_ops.sigmoid(x) / math_ops.log1p(math_ops.exp(x)),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;np.array([-40, 40], dtype=dtype),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expected=np.array([1.0, 0.025], dtype=dtype))</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">109</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">86fa42f516e4c5ca5ac3b2430aeab9d1a55afb30</td>
                    <td class="tg-0lax">python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">precison</td>
                    <td class="tg-0lax">the output of derivative of betainc is NaN</td>
                    <td class="tg-0lax">invalid operation</td>
                    <td class="tg-0lax">I = betainc(X,Z,W) computes the incomplete beta function for corresponding elements of the arrays X, Z and W. The elements of X must be in the closed interval . The arrays Z and W must be nonnegative and real. All arrays must be the same size, or any of them can be scalar.</td>
                    <td class="tg-0lax">When calculating the derivate of betainc, if a or b are equal to 1, there is a risk that log(0) occurs</td>
                    <td class="tg-0lax">gradients/derivatives</td>
                    <td class="tg-0lax">derivatives</td>
                    <td class="tg-0lax">derivative of Betainc (incomplete beta function)</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">Use xlog1py and xlogy instead of log. The function xlog1py&nbsp;&nbsp;computes x * log1p(y) for a given x and y, This function safely returns zero when x = 0, no matter what the value of y is. The function xlogy(x,y) returns 0 if x == 0, and x * log(y) otherwise, elementwise.</td>
                    <td class="tg-0lax">partial_x = math_ops.exp((b - 1) * math_ops.log(1 - x) +<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(a - 1) * math_ops.log(x) - log_beta)</td>
                    <td class="tg-0lax"> # We use xlog1py and xlogy since the derivatives should tend to<br>+&nbsp;&nbsp;# zero one one of the tails when a is 1. or b is 1.<br>+&nbsp;&nbsp;partial_x = math_ops.exp(math_ops.xlog1py(b - 1, -x) +<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;math_ops.xlogy(a - 1, x) - log_beta)</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">exp, log</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">110</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">ee85e6d230278e763a2784ba86acc747abdb2242</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax">decreased accuracy</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">statistics</td>
                    <td class="tg-0lax">variance</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Use the numerically stable two-pass algorithm to calculate variance in MeanStddevNormalization.</td>
                    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;for (int batch = 0; batch &lt; n_batch; ++batch) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float sum = 0.0f;<br>-&nbsp;&nbsp;&nbsp;&nbsp;float sum_sq = 0.0f;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; v_size; ++i) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum += input_vector[i];<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum_sq += input_vector[i] * input_vector[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const float mean = sum / v_size;<br>-&nbsp;&nbsp;&nbsp;&nbsp;const float variance = sum_sq / v_size - mean * mean;<br></td>
                    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;for (int batch = 0; batch &lt; n_batch; ++batch) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float sum = 0.0f;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const float mean = sum / v_size;<br>-&nbsp;&nbsp;&nbsp;&nbsp;const float variance = sum_sq / v_size - mean * mean;<br>+&nbsp;&nbsp;&nbsp;&nbsp;float sum_diff_sq = 0.0f;<br>+&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; v_size; ++i) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const float diff = input_vector[i] - mean;<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum_diff_sq += diff * diff;<br>+&nbsp;&nbsp;&nbsp;&nbsp;}<br>+&nbsp;&nbsp;&nbsp;&nbsp;const float variance = sum_diff_sq / v_size;</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">variance, sum of squares</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">111</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">fd2d8bc50e9b3143544819bf505326e4ed6db2a5</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow, underflow</td>
                    <td class="tg-0lax">incorrect result</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax">XlaOp=Array to concatenate across replicas. asinh(x) = log(x + sqrt(x^2 + 1))</td>
                    <td class="tg-0lax">risk of overflow due to x^2 for large x</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">inverse hyperbolc sine</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">For positive x, we can approximate x + sqrt(x^2 + 1) as 2*x and return log(2) + log(x). For negative x we utilize asinh(-x) = -asinh(x)</td>
                    <td class="tg-0lax">XlaOp Asinh(XlaOp x) { return Log(x + Sqrt(x * x + ScalarLike(x, 1.0))); }</td>
                    <td class="tg-0lax">XlaOp Asinh(XlaOp x) {<br>+&nbsp;&nbsp;XlaBuilder* b = x.builder();<br>+&nbsp;&nbsp;auto do_it = [&amp;](XlaOp x) -&gt; StatusOr&lt;XlaOp&gt; {<br>+&nbsp;&nbsp;&nbsp;&nbsp;TF_ASSIGN_OR_RETURN(auto shape, b-&gt;GetShape(x));<br>+&nbsp;&nbsp;&nbsp;&nbsp;auto one = ScalarLike(x, 1);<br>+&nbsp;&nbsp;&nbsp;&nbsp;if (primitive_util::IsComplexType(shape.element_type())) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Log(x + Sqrt(x * x + one));<br>+&nbsp;&nbsp;&nbsp;&nbsp;}<br>+&nbsp;&nbsp;&nbsp;&nbsp;auto a = Abs(x);<br>+&nbsp;&nbsp;&nbsp;&nbsp;auto naive_result = Log(a + Sqrt(a * a + one));<br>+&nbsp;&nbsp;&nbsp;&nbsp;auto overflow_result = Log(Abs(a)) + Log(ScalarLike(a, 2));<br>+&nbsp;&nbsp;&nbsp;&nbsp;auto sqrt_max_value = Sqrt(MaxFiniteValue(b, shape.element_type()));<br>+&nbsp;&nbsp;&nbsp;&nbsp;return Sign(x) *<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Select(Ge(a, sqrt_max_value), overflow_result, naive_result);<br>+&nbsp;&nbsp;};<br>+&nbsp;&nbsp;// These upcasts are not strictly necessary on all platforms to get within our<br>+&nbsp;&nbsp;// error tolerances, so we could relax this if it ever mattered.<br>+&nbsp;&nbsp;return DoWithUpcastToF32(x, {BF16, F16}, [&amp;](XlaOp x) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;return b-&gt;ReportErrorOrReturn(do_it(x));<br>+&nbsp;&nbsp;});<br>+}<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">log, square root, power</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">112</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">f84e8257aa88fa45cc7a15835ad386565cd60237</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">In Eigen, a reduction is a function taking a matrix or array, and returning a single scalar value. One of the most used reductions is .sum() , returning the sum of all the coefficients inside a given matrix or array.</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">CNN operations</td>
                    <td class="tg-0lax">pooling layer</td>
                    <td class="tg-0lax">eigen reduction, summation, EigenPooling</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a tree algorithm for summation</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">summation</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">113</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">18f860fd8e1fdffd80633cf5ac32f895423dfa8d</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">random number generator</td>
                    <td class="tg-0lax">testing, random number generation</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">change input range for random number generator</td>
                    <td class="tg-0lax">std::uniform_real_distribution&lt;FloatT&gt; generator(-0.9f, 1.0f);</td>
                    <td class="tg-0lax">std::uniform_real_distribution&lt;FloatT&gt; generator(1.0f, 1.125f);</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">114</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">35ca57d39b9e368ef43302421db774e4ac3e3625</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow, underflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow, underflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">binomial distribution</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">Use log_sigmoid instead of log1p and log. ALso, use logits instead of probabilities</td>
                    <td class="tg-0lax">return (self.total_count * math_ops.log1p(-self.probs)<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ x * math_ops.log(self.probs))</td>
                    <td class="tg-0lax">return (self.total_count * math_ops.log_sigmoid(-self.logits)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ x * math_ops.log_sigmoid(self.logits))</td>
                    <td class="tg-0lax">def testLogProbOverflow(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;with self.test_session() as sess:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logits = np.float32([20., 30., 40.])<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total_count = np.float32(1.)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = np.float32(0.)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nb = negative_binomial.NegativeBinomial(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total_count=total_count, logits=logits)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log_prob_ = sess.run(nb.log_prob(x))<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertAllEqual(np.ones_like(log_prob_, dtype=np.bool),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;np.isfinite(log_prob_))<br>+<br>+&nbsp;&nbsp;def testLogProbUnderflow(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;with self.test_session() as sess:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logits = np.float32([-90, -100, -110])<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total_count = np.float32(1.)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = np.float32(0.)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nb = negative_binomial.NegativeBinomial(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total_count=total_count, logits=logits)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log_prob_ = sess.run(nb.log_prob(x))<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertAllEqual(np.ones_like(log_prob_, dtype=np.bool),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;np.isfinite(log_prob_))</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">log</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">115</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">2114fd51e9e4fe3cefc058fe42363f68126a9da6</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow, underflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow, underflow</td>
                    <td class="tg-0lax">softplus(x) = log(exp(x) + 1), softplus is a smooth approximation of relu. Like relu, softplus always takes on positive values.<br><br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">activation functions</td>
                    <td class="tg-0lax">activation functions</td>
                    <td class="tg-0lax">sofplus</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">XLAJIT_MAKE_UNARY(Softplus,<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Log(b-&gt;Add(b-&gt;Exp(x), XlaHelpers::One(b, input_type(0)))));</td>
                    <td class="tg-0lax">static xla::ComputationDataHandle Softplus(<br>+&nbsp;&nbsp;&nbsp;&nbsp;xla::ComputationBuilder* b, DataType dtype,<br>+&nbsp;&nbsp;&nbsp;&nbsp;const xla::ComputationDataHandle&amp; features) {<br>+&nbsp;&nbsp;xla::ComputationDataHandle threshold =<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Add(b-&gt;Log(XlaHelpers::Epsilon(b, dtype)),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XlaHelpers::FloatLiteral(b, dtype, 2.0));<br>+&nbsp;&nbsp;// Value above which exp(x) may overflow, but softplus(x) == x<br>+&nbsp;&nbsp;// is within machine epsilon.<br>+&nbsp;&nbsp;xla::ComputationDataHandle too_large = b-&gt;Gt(features, b-&gt;Neg(threshold));<br>+&nbsp;&nbsp;// Value below which exp(x) may underflow, but softplus(x) == exp(x)<br>+&nbsp;&nbsp;// is within machine epsilon.<br>+&nbsp;&nbsp;xla::ComputationDataHandle too_small = b-&gt;Lt(features, threshold);<br>+&nbsp;&nbsp;xla::ComputationDataHandle features_exp = b-&gt;Exp(features);<br>+&nbsp;&nbsp;xla::ComputationDataHandle output = b-&gt;Select(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;too_large, features,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Select(too_small, features_exp,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Log(b-&gt;Add(features_exp, XlaHelpers::One(b, dtype)))));<br>+&nbsp;&nbsp;return output;<br>+}<br>+XLAJIT_MAKE_UNARY(Softplus, Softplus(b, input_type(0), x));</td>
                    <td class="tg-0lax">def _assertSoftplusMatchesExpected(self, features, dtype):<br>+&nbsp;&nbsp;&nbsp;&nbsp;features = np.array(features, dtype=dtype)<br>+&nbsp;&nbsp;&nbsp;&nbsp;zero = np.asarray(0).astype(dtype)<br>+&nbsp;&nbsp;&nbsp;&nbsp;expected = np.logaddexp(zero, features)<br>+&nbsp;&nbsp;&nbsp;&nbsp;self._assertOpOutputMatchesExpected(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nn_ops.softplus, features, expected=expected)<br>+<br>+&nbsp;&nbsp;def testSoftplus(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;for dtype in self.float_types:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._assertSoftplusMatchesExpected([[-2, 0, 8]], dtype)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._assertSoftplusMatchesExpected(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[-9, 7, -5, 3, -1], [1, -3, 5, -7, 9]], dtype)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log_eps = np.log(np.finfo(dtype).eps)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;one = dtype(1)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ten = dtype(10)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._assertSoftplusMatchesExpected([<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log_eps, log_eps - one, log_eps + one, log_eps - ten,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log_eps + ten, -log_eps, -log_eps - one, -log_eps + one,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-log_eps - ten, -log_eps + ten], dtype)</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">116</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">448de13b1ae2ebc96a49785cee5ae98db1ae7b06</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">linear algebra</td>
                    <td class="tg-0lax">determinant</td>
                    <td class="tg-0lax">log determinant of a matrix</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Compute the log determinant through a Partially Pivoted LU decomposition</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">117</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">1193b39c9e58545ac35aae19dfa34a06bdfae073</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">underflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Poisson&nbsp;&nbsp;is a discrete probability distribution that expresses the probability of a given number of events occurring in a fixed interval of time or space if these events occur with a known constant mean rate and independently of the time since the last event. Lambda can be 0 through infinity.</td>
                    <td class="tg-0lax">for a small rate lamdda in poisson distribution, e^(-lambda) causes numerical stability issues, because exp of a very small number produces exponentially smaller number, which leads to a risk of underflow</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">poisson distribution</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">Use log of rate instead of plain rate to avoid exponenitating very small numbers</td>
                    <td class="tg-0lax"> with ops.control_dependencies([check_ops.assert_positive(rate)] if<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;validate_args else []):<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._rate = array_ops.identity(rate, name="rate")</td>
                    <td class="tg-0lax">if (rate is None) == (log_rate is None):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise ValueError("Must specify exactly one of `rate` and `log_rate`.")<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif log_rate is None:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rate = ops.convert_to_tensor(rate, name="rate")<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not rate.dtype.is_floating:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise TypeError("rate.dtype ({}) is a not a float-type.".format(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rate.dtype.name))<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with ops.control_dependencies([check_ops.assert_positive(rate)] if<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;validate_args else []):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._rate = array_ops.identity(rate, name="rate")<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._log_rate = math_ops.log(rate, name="log_rate")<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log_rate = ops.convert_to_tensor(log_rate, name="log_rate")<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not log_rate.dtype.is_floating:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise TypeError("log_rate.dtype ({}) is a not a float-type.".format(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log_rate.dtype.name))<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._rate = math_ops.exp(log_rate, name="rate")<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._log_rate = ops.convert_to_tensor(log_rate, name="log_rate")<br><br>class PoissonLogRateTest(PoissonTest):<br>+<br>+&nbsp;&nbsp;def _make_poisson(self, rate, validate_args=False):<br>+&nbsp;&nbsp;&nbsp;&nbsp;return poisson_lib.Poisson(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log_rate=math_ops.log(rate),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;validate_args=validate_args)<br>+<br>+&nbsp;&nbsp;def testInvalidLam(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;# No need to worry about the non-negativity of `rate` when using the<br>+&nbsp;&nbsp;&nbsp;&nbsp;# `log_rate` parameterization.<br>+&nbsp;&nbsp;&nbsp;&nbsp;pass</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">exp</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">118</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">0cff60ebb29f5aba5092988c8b7f13c258115e81</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow, underflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">linear algebra</td>
                    <td class="tg-0lax">linear algebra</td>
                    <td class="tg-0lax">log of hermitian matrix determinant</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Use the property that the log det(A) = 2*sum(log(real(diag(C)))), where C is the cholesky decomposition of A. Add a function to compute the natural log of the determinant for hermitian positive definite matrices in a numerically stable way via Cholesky decompositions.. Equivalent to numpy.linalg.slogdet, although no sign is returned since only<br>+&nbsp;&nbsp;hermitian positive definite matrices are supported.</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">def logdet(matrix, name=None):<br>+&nbsp;&nbsp;"""Computes log of the determinant of a hermitian positive definite matrix.<br>+<br>+&nbsp;&nbsp;```python<br>+&nbsp;&nbsp;# Compute the determinant of a matrix while reducing the chance of over- or<br>+&nbsp;&nbsp;underflow:<br>+&nbsp;&nbsp;A = ... # shape 10 x 10<br>+&nbsp;&nbsp;det = tf.exp(tf.logdet(A))&nbsp;&nbsp;# scalar<br>+&nbsp;&nbsp;```<br>+<br>+&nbsp;&nbsp;Args:<br>+&nbsp;&nbsp;&nbsp;&nbsp;matrix:&nbsp;&nbsp;A `Tensor`. Must be `float32`, `float64`, `complex64`, or<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`complex128` with shape `[..., M, M]`.<br>+&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;&nbsp;A name to give this `Op`.&nbsp;&nbsp;Defaults to `logdet`.<br>+<br>+&nbsp;&nbsp;Returns:<br>+&nbsp;&nbsp;&nbsp;&nbsp;The natural log of the determinant of `matrix`.<br>+<br>+&nbsp;&nbsp;@compatibility(numpy)<br>+&nbsp;&nbsp;Equivalent to numpy.linalg.slogdet, although no sign is returned since only<br>+&nbsp;&nbsp;hermitian positive definite matrices are supported.<br>+&nbsp;&nbsp;@end_compatibility<br>+&nbsp;&nbsp;"""<br>+&nbsp;&nbsp;# This uses the property that the log det(A) = 2*sum(log(real(diag(C))))<br>+&nbsp;&nbsp;# where C is the cholesky decomposition of A.<br>+&nbsp;&nbsp;with ops.name_scope(name, 'logdet', [matrix]):<br>+&nbsp;&nbsp;&nbsp;&nbsp;chol = gen_linalg_ops.cholesky(matrix)<br>+&nbsp;&nbsp;&nbsp;&nbsp;return 2.0 * math_ops.reduce_sum(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;math_ops.log(math_ops.real(array_ops.matrix_diag_part(chol))),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reduction_indices=[-1])<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">119</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">b85601b95eba28605d3de076fa70cabf2f2e32b9</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">incorrect result</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">In probability theory, an ƒ-divergence is a function Df (P  || Q) that measures the difference between two probability distributions P and Q.</td>
                    <td class="tg-0lax">If probability distribution Q is not reparameterized, TensorFlow's gradient will be incorrect since the chain-rule stops at samples of unreparameterized distributions</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">probability</td>
                    <td class="tg-0lax">ƒ-divergence</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Improve score-trick to be a valid Csiszar f-Divergence yet numerically stable. Using the Score-Gradient trick results in an unbiased gradient</td>
                    <td class="tg-0lax">nabla E_q[f(X)]<br>-&nbsp;&nbsp;= nabla int dx q(x) f(x)<br>-&nbsp;&nbsp;= int dx nabla [ q(x) f(x) ]<br>-&nbsp;&nbsp;= int dx q'(x) f(x) + q(x) f'(x)<br>-&nbsp;&nbsp;= int dx q(x) nabla [ log(q(x)) stopgrad[f(x)] + f(x) ]<br>-&nbsp;&nbsp;= E_q[ nabla [ log(q(X)) stopgrad[f(X)] + f(X) ] ]<br>-&nbsp;&nbsp;~= Avg{ log(q(y_i)) stopgrad[f(y_i)] + f(y_i) : y_i = stopgrad[x_i], x_i ~ q}<br></td>
                    <td class="tg-0lax"> grad[ E_q[f(X)] ]<br>+&nbsp;&nbsp;= grad[ int dx q(x) f(x) ]<br>+&nbsp;&nbsp;= int dx grad[ q(x) f(x) ]<br>+&nbsp;&nbsp;= int dx [ q'(x) f(x) + q(x) f'(x) ]<br>+&nbsp;&nbsp;= int dx q(x) grad[ f(x) q(x) / stop_grad[q(x)] ]<br>+&nbsp;&nbsp;= E_q[ grad[ f(x) q(x) / stop_grad[q(x)] ] ]<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">120</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">e6126230200e2ce9c96da5c9e4dc7f104c645d11</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow, underflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">for very small or very large numbers naive direct computation of log of sum of exponentials has a risk of underflow and overflow respectively</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">Gaussian mixture model, log probability</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">Use Tensorflow log(sum(exp)) function to work in log scale which is numerically stable than log -&gt; sum -&gt;exp for calculating log probability</td>
                    <td class="tg-0lax">self._prior_probs[shard_id] = math_ops.log(<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;math_ops.reduce_sum(<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;math_ops.exp(self._probs[shard_id]), 1, keep_dims=True))</td>
                    <td class="tg-0lax">self._prior_probs[shard_id] = math_ops.reduce_logsumexp(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._probs[shard_id], axis=1, keep_dims=True)</td>
                    <td class="tg-0lax">def test_random_input_large(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;# sklearn version.<br>+&nbsp;&nbsp;&nbsp;&nbsp;iterations = 5&nbsp;&nbsp;# that should be enough to know whether this diverges<br>+&nbsp;&nbsp;&nbsp;&nbsp;np.random.seed(5)<br>+&nbsp;&nbsp;&nbsp;&nbsp;num_classes = 20<br>+&nbsp;&nbsp;&nbsp;&nbsp;x = np.array([[np.random.random() for _ in range(100)]<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for _ in range(num_classes)], dtype=np.float32)<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;# skflow version.<br>+&nbsp;&nbsp;&nbsp;&nbsp;gmm = gmm_lib.GMM(num_classes,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;covariance_type='full',<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;config=run_config.RunConfig(tf_random_seed=2))<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;def get_input_fn(x):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def input_fn():<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return constant_op.constant(x.astype(np.float32)), None<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return input_fn<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;gmm.fit(input_fn=get_input_fn(x), steps=iterations)<br>+&nbsp;&nbsp;&nbsp;&nbsp;self.assertFalse(np.isnan(gmm.clusters()).any())</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">log sum of exp</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">121</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">fdbd02c8d7f07bd1207938662716fad8857dcd55</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">deals with the shift parameter, but this feature is not available in TF now</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">statistics</td>
                    <td class="tg-0lax">mean, variance</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">change the shift value for calculating mean</td>
                    <td class="tg-0lax">shift = math_ops.cast(shift, dtypes.float32) if (<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shift is not None and x.dtype == dtypes.float16) else shift</td>
                    <td class="tg-0lax">if shift is None:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Compute true mean while keeping the dims for proper broadcasting.<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shift = array_ops.stop_gradient(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;math_ops.reduce_mean(y, axes, keep_dims=True))<br>+&nbsp;&nbsp;&nbsp;&nbsp;else:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shift = math_ops.cast(shift, y.dtype)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>+&nbsp;&nbsp;&nbsp;&nbsp;# Reshape shift as needed.<br>+&nbsp;&nbsp;&nbsp;&nbsp;shift = array_ops.reshape(shift, array_ops.shape(m_ss))<br>+&nbsp;&nbsp;&nbsp;&nbsp;shift.set_shape(m_ss.get_shape())<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">122</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">7c97f13ace37ac73bb820dec941c55ae4d538581</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Student's t-distribution is defined as the distribution of the random variable t which is (very loosely) the "best" that we can do not knowing sigma.</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">student t distribution log probability</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">use log1p instead of log. THe function log1p computes natural logarithm of (1 + x) element-wise.</td>
                    <td class="tg-0lax"> def _log_prob(self, x):<br>&nbsp;&nbsp;&nbsp;&nbsp;y = (x - self.mu) / self.sigma<br>&nbsp;&nbsp;&nbsp;&nbsp;half_df = 0.5 * self.df<br>&nbsp;&nbsp;&nbsp;&nbsp;return (math_ops.lgamma(0.5 + half_df) - math_ops.lgamma(half_df) - 0.5 *<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;math_ops.log(self.df) - 0.5 * math.log(math.pi) -<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;math_ops.log(self.sigma) -<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0.5 + half_df) * math_ops.log(1. + math_ops.square(y) / self.df))</td>
                    <td class="tg-0lax">def _log_prob(self, x):<br>&nbsp;&nbsp;&nbsp;&nbsp;return self._log_unnormalized_prob(x) - self._log_normalization()<br><br>&nbsp;&nbsp;def _log_unnormalized_prob(self, x):<br>&nbsp;&nbsp;&nbsp;&nbsp;y = (x - self.mu) / self.sigma&nbsp;&nbsp;# Abs(sigma) superfluous.<br>&nbsp;&nbsp;&nbsp;&nbsp;return -0.5 * (self.df + 1.) * math_ops.log1p(y**2. / self.df)<br><br>&nbsp;&nbsp;def _log_normalization(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;return (math_ops.log(math_ops.abs(self.sigma)) +<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.5 * math_ops.log(self.df) +<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.5 * np.log(np.pi) +<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;math_ops.lgamma(0.5 * self.df) -<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;math_ops.lgamma(0.5 * (self.df + 1.)))</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">log</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">123</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">de6ce1de08ea97d599687fbbe5196ca4af5232ae</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">large logit values were not properly handled in multinomial distribution</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">Multinomial distribution</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">subtract a maximum from logits before taking exponentials</td>
                    <td class="tg-0lax">running_total += std::exp(static_cast&lt;float&gt;(logits_row[j]))</td>
                    <td class="tg-0lax">// Takes an along-class maximum (for numerical stability).<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T max = std::numeric_limits&lt;T&gt;::lowest();<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int64 j = 0; j &lt; num_classes; ++j) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (std::isfinite(static_cast&lt;float&gt;(logits_row[j]))) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max = std::max(max, logits_row[j]);<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const float max_logit = static_cast&lt;float&gt;(max);<br>running_total += std::exp(static_cast&lt;float&gt;(logits_row[j]) - max_logit);<br></td>
                    <td class="tg-0lax">def testLargeLogits(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;for neg in [True, False]:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with self.test_session(use_gpu=self.use_gpu):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logits = np.array([[1000.] * 5])<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if neg:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logits *= -1<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;samples = tf.multinomial(logits, 10).eval()<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Sampled classes should be in-range.<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertTrue((samples &gt;= 0).all())<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertTrue((samples &lt; 5).all())</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">exponential</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">124</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">e47dc8593d11be8cd82767965b8b75b6307c07e4</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;&nbsp;There is evidence that the 'shift' strategy in computing the sufficient statistics of the moments is actually leading to worse numerical stability for batch normalization.<br></td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">statistics</td>
                    <td class="tg-0lax">mean, variance</td>
                    <td class="tg-0lax">amend algorithm</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">set shift parameter as a non-default argument in moments method that calculates mean and variance and is utilized in batch normalization</td>
                    <td class="tg-0lax">def sufficient_statistics(x, axes, shift=True, keep_dims=False, name=None)</td>
                    <td class="tg-0lax">def sufficient_statistics(x, axes, shift=False, keep_dims=False, name=None)</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">variance, mean</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">125</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">ab1165c4908b70441f1ddea24821a8b84a806ddc</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Legalization is the phase in code generation that eradicates any instructions that are not supported by the target.</td>
                    <td class="tg-0lax">Multi-Level IR Compiler Framework</td>
                    <td class="tg-0lax">activation functions</td>
                    <td class="tg-0lax">activation functions</td>
                    <td class="tg-0lax">sigmoid, compiler</td>
                    <td class="tg-0lax">amend algorithm</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">This function converts Sigmoid op to HLO ops computing sigmoid</td>
                    <td class="tg-0lax">class ConvertSigmoidOp : public OpRewritePattern&lt;TF::SigmoidOp&gt; {<br><br>-&nbsp;&nbsp;using OpRewritePattern::OpRewritePattern;<br>-<br>-&nbsp;&nbsp;LogicalResult matchAndRewrite(TF::SigmoidOp op,</td>
                    <td class="tg-0lax">class ConvertSigmoidOp : public RewritePattern {<br>&nbsp;&nbsp;public:<br>+&nbsp;&nbsp;explicit ConvertSigmoidOp(MLIRContext *context)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: RewritePattern(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TF::SigmoidOp::getOperationName(), 0, context,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{mhlo::ConstOp::getOperationName(),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shape::ShapeOfOp::getOperationName(),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shape::ToExtentTensorOp::getOperationName(),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mhlo::DynamicBroadcastInDimOp::getOperationName(),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mhlo::MulOp::getOperationName(), mhlo::TanhOp::getOperationName(),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mhlo::AddOp::getOperationName()}) {}<br>+<br>+&nbsp;&nbsp;LogicalResult matchAndRewrite(Operation *sigmoid_op,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PatternRewriter &amp;rewriter) const override {<br>+&nbsp;&nbsp;&nbsp;&nbsp;auto op = cast&lt;TF::SigmoidOp&gt;(sigmoid_op);<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">126</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">6acd86d539464b611d37b8dc13251fafab25fb5c</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">argmin</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">amend logic for tie breaking</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">127</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">f73e9d61a7c577a5182701d3aa5bba8d6d69f87d</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">argmin, argmax</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">amend logic for tie breaking</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">128</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">ee85e6d230278e763a2784ba86acc747abdb2242</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">MeanStddevNormalization is numerically unstable</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">statistics</td>
                    <td class="tg-0lax">variance</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Use the numerically stable two-pass algorithm to calculate variance in MeanStddevNormalization.</td>
                    <td class="tg-0lax">float sum_sq = 0.0f;<br>sum_sq += input_vector[i] * input_vector[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>const float variance = sum_sq / v_size - mean * mean;<br></td>
                    <td class="tg-0lax">float sum_diff_sq = 0.0f;<br>+&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; v_size; ++i) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const float diff = input_vector[i] - mean;<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum_diff_sq += diff * diff;<br>+&nbsp;&nbsp;&nbsp;&nbsp;}<br>+&nbsp;&nbsp;&nbsp;&nbsp;const float variance = sum_diff_sq / v_size;</td>
                    <td class="tg-0lax">test accuracy for <br>// small mean, small variance<br>/ small mean, large variance<br>// large mean, zero variance<br> // large mean, small variance<br>/ large mean, large variance<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">129</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">f42d9846f6942e497645af28b3506e6163bdc8bf</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">mel spectrogram is a spectrogram where the frequencies are converted to the mel scale. It is used in signal processing and it involves mapping audio signal from the time to frequency domain using fast fourier transform</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">loss functions</td>
                    <td class="tg-0lax">loss functions</td>
                    <td class="tg-0lax">logistic loss, uniform distribution sampling, Mel-Frequency Cepstral Coefficient (MFCC) calculation</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Replace log(1 + x) with numerically more stable log1p(x)</td>
                    <td class="tg-0lax">LogisticLossUpdater : public DualLossUpdater {<br>- return log(1 + exp(-y_wx)) * example_weight;<br><br>double MfccMelFilterbank::FreqToMel(double freq) const {<br>-&nbsp;&nbsp;return 1127.0 * log(1.0 + (freq / 700.0));<br><br>LogUniformSampler::LogUniformSampler(int64 range)<br>-&nbsp;&nbsp;&nbsp;&nbsp;: RangeSampler(range), log_range_(log(range + 1)) {}<br><br>static float FreqToMel(float freq) {<br>-&nbsp;&nbsp;return 1127.0 * log(1.0 + (freq / 700.0));<br><br>double MfccMelFilterbank::FreqToMel(double freq) const {<br>-&nbsp;&nbsp;return 1127.0 * log(1.0 + (freq / 700.0));</td>
                    <td class="tg-0lax">class LogisticLossUpdater : public DualLossUpdater {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return log1p(exp(-y_wx)) * example_weight;<br><br> double MfccMelFilterbank::FreqToMel(double freq) const {<br>+&nbsp;&nbsp;return 1127.0 * log1p(freq / 700.0);<br><br>LogUniformSampler::LogUniformSampler(int64 range)<br>+&nbsp;&nbsp;&nbsp;&nbsp;: RangeSampler(range), log_range_(log1p(range)) {}<br><br>static float FreqToMel(float freq) {<br>+&nbsp;&nbsp;return 1127.0 * log1p(freq / 700.0);<br><br>double MfccMelFilterbank::FreqToMel(double freq) const {<br>+&nbsp;&nbsp;return 1127.0 * log1p(freq / 700.0);<br><br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">130</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">0fe671dd0a14614edbbd50397777def3bff770cc</td>
                    <td class="tg-0lax">Cuda</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">loss of precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Eigen MeanReducer is numerically unstable due to unstable summation operation. Summing numbers of different magnitude leads to loss of precision, numbers should be sorted</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">statistics</td>
                    <td class="tg-0lax">mean</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Don't use the numerically unstable MeanReducer class in Eigen.</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">131</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">f84e8257aa88fa45cc7a15835ad386565cd60237</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">loss of precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Eigen MeanReducer is numerically unstable due to unstable summation operation. Summing numbers of different magnitude leads to loss of precision, numbers should be sorted</td>
                    <td class="tg-0lax">CNN operations</td>
                    <td class="tg-0lax">pooling layer</td>
                    <td class="tg-0lax">mean, average pooling</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Change the Eigen reduction code to use a tree to improve numerical stability.<br>&nbsp;&nbsp;&nbsp;&nbsp;This changes the InnerMostDimReducer to use a summation tree, which is more numerically stable than the previous approach of sequential addition into an accumulator.<br>&nbsp;&nbsp;&nbsp;&nbsp;This solves the issue for reduction over all or a trailing subset of dimensions.<br>&nbsp;&nbsp;&nbsp;&nbsp;This change does not improve the numerical accuracy for MeanReducer, which maintains state.<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;Benchmarks show a 40% (AVX) to 50% (SSE) slowdown for small row reductions (sum, float). column- and full reductions are unchanged.<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">132</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">fa2132ab65f92ea40c94152dba105a9f86a0a555</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">loss of precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">unsorted sum is numerically unstable</td>
                    <td class="tg-0lax">gradients/derivatives</td>
                    <td class="tg-0lax">gradients</td>
                    <td class="tg-0lax">gradients, hessians, boosted trees</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">Use 64bit aggregation for gradients and hessians since the 32 bit version is numerically unstable for large minibatches.</td>
                    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;per_partition_hessians = math_ops.unsorted_segment_sum(<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hessians, mapped_partitions, array_ops.size(unique_partitions))</td>
                    <td class="tg-0lax"> # Since unsorted_segment_sum can be numerically unstable, use 64bit<br>+&nbsp;&nbsp;&nbsp;&nbsp;# operation.<br>+&nbsp;&nbsp;&nbsp;&nbsp;gradients64 = math_ops.cast(gradients, dtypes.float64)<br>+&nbsp;&nbsp;&nbsp;&nbsp;hessians64 = math_ops.cast(hessians, dtypes.float64)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;per_partition_gradients = math_ops.unsorted_segment_sum(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gradients64, mapped_partitions, array_ops.size(unique_partitions))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;per_partition_hessians = math_ops.unsorted_segment_sum(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hessians64, mapped_partitions, array_ops.size(unique_partitions))<br>+&nbsp;&nbsp;&nbsp;&nbsp;per_partition_gradients = math_ops.cast(per_partition_gradients,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dtypes.float32)<br>+&nbsp;&nbsp;&nbsp;&nbsp;per_partition_hessians = math_ops.cast(per_partition_hessians,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dtypes.float32)<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">sum</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">133</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">48adc7ba73177f2a9331918b160bc3d0775985b8</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">square root</td>
                    <td class="tg-0lax">linear algebra</td>
                    <td class="tg-0lax">norm</td>
                    <td class="tg-0lax">L2 norm</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">Avoid&nbsp;&nbsp;potentially numerically unstable square root in the linalg_ops.norm()</td>
                    <td class="tg-0lax">mean = math_ops.square(linalg_ops.norm(m - m_w))&nbsp;&nbsp;# This uses the L2 norm.</td>
                    <td class="tg-0lax">mean = math_ops.reduce_sum(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;math_ops.squared_difference(m, m_w))&nbsp;&nbsp;# Equivalent to L2 but more stable.</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">square root, mean</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">134</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">18f860fd8e1fdffd80633cf5ac32f895423dfa8d</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">random number generator</td>
                    <td class="tg-0lax">random number generator</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">Create uniform numbers between 1 and 1.125&nbsp;&nbsp;instead of -0.9 and 1.0 to avoid creating denormal numbers.</td>
                    <td class="tg-0lax">std::uniform_real_distribution&lt;FloatT&gt; generator(-0.9f, 1.0f);<br>[&amp;](tensorflow::gtl::ArraySlice&lt;int64&gt; /*indices*/) {<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return generator(engine);</td>
                    <td class="tg-0lax"> std::uniform_real_distribution&lt;FloatT&gt; generator(1.0f, 1.125f);<br>[&amp;](tensorflow::gtl::ArraySlice&lt;int64&gt; indices) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Generate a random uniforma number from -0.0625 and 0.0625 and bias it<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// with&nbsp;&nbsp;a position dependent nubmer with mean 0.037109375. These number<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// should allow for long chains of accumulation without being too close<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// to zero or to large to accumulate all numbers accurately.<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (generator(engine) - 1.0625) +<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static_cast&lt;FloatT&gt;(Product(indices) % 113 - 47) /<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static_cast&lt;FloatT&gt;(256.0f);<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">135</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">6db014b44863bab616f026beab461fd646fcb505</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">gradients/derivatives</td>
                    <td class="tg-0lax">gradients</td>
                    <td class="tg-0lax">gradients testing</td>
                    <td class="tg-0lax">revert commit</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax">TEST_F(NaryGradTest, Select) {<br>+&nbsp;&nbsp;TensorShape shape({3, 2});<br>+&nbsp;&nbsp;auto x1 = Placeholder(scope_, DT_FLOAT, Placeholder::Shape(shape));<br>+&nbsp;&nbsp;auto x2 = Placeholder(scope_, DT_FLOAT, Placeholder::Shape(shape));<br>+&nbsp;&nbsp;// Use constant values to avoid instability when computing<br>+&nbsp;&nbsp;Tensor c =<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test::AsTensor&lt;float&gt;({-3.5f, 1.5f, -1.2f, 3.0f, -2.5f, 2.8f}, {3, 2});<br>+&nbsp;&nbsp;auto zero = Cast(scope_, Const(scope_, 0.0), c.dtype());<br>+&nbsp;&nbsp;auto y = Where3(scope_, Greater(scope_, c, zero), x1, x2);<br>+&nbsp;&nbsp;RunTest({x1, x2}, {shape, shape}, {y}, {shape});<br>+}<br><br>Status SelectGrad(const Scope&amp; scope, const Operation&amp; op,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;Output&gt;&amp; grad_inputs,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Output&gt;* grad_outputs) {<br>+&nbsp;&nbsp;auto comparator = op.input(0);<br>+&nbsp;&nbsp;auto x = op.input(1);<br>+&nbsp;&nbsp;auto zeros = ZerosLike(scope, x);<br>+&nbsp;&nbsp;auto grad = grad_inputs[0];<br>+<br>+&nbsp;&nbsp;auto gx_1 = Where3(scope, comparator, grad, zeros);<br>+&nbsp;&nbsp;auto gx_2 = Where3(scope, comparator, zeros, grad);<br>+<br>+&nbsp;&nbsp;grad_outputs-&gt;push_back(NoGradient());<br>+&nbsp;&nbsp;grad_outputs-&gt;push_back(gx_1);<br>+&nbsp;&nbsp;grad_outputs-&gt;push_back(gx_2);<br>+&nbsp;&nbsp;return scope.status();<br>+}<br>+REGISTER_GRADIENT_OP("Select", SelectGrad);<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">136</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">1bbec9e4e9c5d3fbbc2fa2b58841435e86dbf76a</td>
                    <td class="tg-0lax">Cuda</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">linear algebra</td>
                    <td class="tg-0lax">linear algebra</td>
                    <td class="tg-0lax">log determinant</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Compute Determinant from a partially pivoted LU factorization<br>Change behavior for Determinant on matrices with (numerically) infinite determinants to match the behavior of numpy.linalg.det: Return inf for matrix with infinite determinant.<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">137</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">265483857be3ca84b992937490ea8f0591b2d4ab</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">laplace distribution</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Add more stable calculation of Log of the cumulative distribution function and log survival function</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">138</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">e37e792d3eb2dac7ac627b7d8d56d69360649d19</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">The raw formulation of cross-entropy, tf.reduce_mean(-tf.reduce_sum(y_ * tf.log(tf.softmax(y)),<br> reduction_indices=[1])) can be numerically unstable.</td>
                    <td class="tg-0lax">loss functions</td>
                    <td class="tg-0lax">loss functions</td>
                    <td class="tg-0lax">cross entropy loss</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">we apply<br>+`tf.nn.softmax_cross_entropy_with_logits` on the unnormalized logits (e.g., we<br>+call `softmax_cross_entropy_with_logits` on `tf.matmul(x, W) + b`), because this<br>+more numerically stable function internally computes the softmax activation. </td>
                    <td class="tg-0lax">cross_entropy = tf.reduce_mean(-tf.reduce_sum(y_ * tf.log(y), reduction_indices=[1]))</td>
                    <td class="tg-0lax">cross_entropy = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(y, y_))</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">139</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">a89c54d57209f91161fa450605f645c9124d89ac</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">Bernoulli distribution</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use logits to create bernouli distribution</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">140</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">14066c4b84e56c3b86f6152de1bb80df22341aa8</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">log determinant, multivariate normal distribution</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Compute log_determinant instead of determinant in mvn to make stable (w.r.t. under/over flow).</td>
                    <td class="tg-0lax">-def _determinant_from_sigma_chol(sigma_chol):<br>&nbsp;&nbsp;&nbsp;det_last_dim = array_ops.rank(sigma_chol) - 2<br>&nbsp;&nbsp;&nbsp;sigma_batch_diag = array_ops.batch_matrix_diag_part(sigma_chol)<br>-&nbsp;&nbsp;det = math_ops.square(math_ops.reduce_prod(<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sigma_batch_diag, reduction_indices=det_last_dim))<br>-&nbsp;&nbsp;det.set_shape(sigma_chol.get_shape()[:-2])<br>-&nbsp;&nbsp;return det<br></td>
                    <td class="tg-0lax">def _log_determinant_from_sigma_chol(sigma_chol):<br>&nbsp;&nbsp;&nbsp;det_last_dim = array_ops.rank(sigma_chol) - 2<br>&nbsp;&nbsp;&nbsp;sigma_batch_diag = array_ops.batch_matrix_diag_part(sigma_chol)<br>+&nbsp;&nbsp;log_det = 2.0 * math_ops.reduce_sum(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;math_ops.log(sigma_batch_diag), reduction_indices=det_last_dim)<br>+&nbsp;&nbsp;log_det.set_shape(sigma_chol.get_shape()[:-2])<br>+&nbsp;&nbsp;return log_det<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">141</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">bce6216610d57f8f4b1e9e79836737df109c4e42</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">statistics</td>
                    <td class="tg-0lax">variance with shifted data</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">142</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">66f452d2217b155b697fc6d6cef5f56599ee2bbc</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Only enable the HoistCommonFactorOutOfAggregation rewrite in aggressive mode, since it changes program behavior w.r.t. over- and underflow. For example, it will rewrite "0.5*x + 0.5*y" to "0.5*(x + y)", which will overflow if x + y &gt; FLT_MAX, while the original expression does not overflow unless x + y &gt; 2*FLT_MAX.</td>
                    <td class="tg-0lax">optimizers</td>
                    <td class="tg-0lax">optimizers</td>
                    <td class="tg-0lax">arithmetic optimizer</td>
                    <td class="tg-0lax">allow code rewriting only in agressive mode</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">Only enable the HoistCommonFactorOutOfAggregation rewrite in aggressive mode</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">143</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">12243e6b65958c2e0c344aa3df4875f472ce5ae0</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">computational graph</td>
                    <td class="tg-0lax">analytical cost estimator</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax">Fix integer-overflow in `tensorflow::grappler::AnalyticalCostEstimator::PredictCosts` by using MultiplyWithoutOverflow. MultiplyWithoutOverflow multiplies unsigned ints since signed overflow is undefined and has a check fo integer overflow. Return nullop if overflow</td>
                    <td class="tg-0lax">size *= std::max&lt;int64&gt;(1, dim.size());</td>
                    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size = MultiplyWithoutOverflow(size, std::max&lt;int64&gt;(1, dim.size()));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (size &lt; 0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return errors::InvalidArgument(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Integer overflow encountered in dimension size.");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">144</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">cc464f04caa327d3f62d2f793a428cb7b0f0a5d7</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">unit test</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">linear algebra</td>
                    <td class="tg-0lax">linear algebra</td>
                    <td class="tg-0lax">array product</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">Limit input values to avoid integer overflow in reduction_ops_test.</td>
                    <td class="tg-0lax"> # overflow, divide the incremental int32 array by 2.<br>-&nbsp;&nbsp;&nbsp;&nbsp;for rank in range(1, _MAX_RANK + 1):<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;np_arr = self._makeIncremental((2,) * rank, dtypes.int32) / 2<br><br> def testInt64(self):<br>-&nbsp;&nbsp;&nbsp;&nbsp;for rank in range(1, _MAX_RANK + 1):<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;np_arr = self._makeIncremental((2,) * rank, dtypes.int64)</td>
                    <td class="tg-0lax">&nbsp;&nbsp;# overflow, limit array values.<br>+&nbsp;&nbsp;&nbsp;&nbsp;for rank in range(1, _MAX_RANK):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;np_arr = self._makeIncremental((2,) * rank, dtypes.int32) % 5 + 1<br><br> def testInt64(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;for rank in range(1, _MAX_RANK):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Avoid overflow by limiting array values.<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;np_arr = self._makeIncremental((2,) * rank, dtypes.int64) % 11 + 1<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">145</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">9d40a1573849b7e21d4f2d359fd9e87c40e33c0e</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Disable test</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">division, mod testing</td>
                    <td class="tg-0lax">disable test for division and mod</td>
                    <td class="tg-0lax">disable test/warning</td>
                    <td class="tg-0lax">Temporarily disable div overflow edge case due to ASAN failure.</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">146</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">b47be308c4b5ac7babd6400a8fb40c3d8bf163d6</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">The original implementations of `google_floor_div`, XLA `FloorDiv` and<br>&nbsp;&nbsp;&nbsp;&nbsp;MLIR `TF_FloorDivOp` all suffered from overflows for<br>&nbsp;&nbsp;&nbsp;&nbsp;`abs(x) + abs(y) &gt; INT_MAX</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">floor division</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">Rewrite formula to <br>T z = x / y<br>return (z * y != x &amp;&amp; (x &lt; 0) != (y &lt; 0)) ? z - 1 : z<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"> def intEdgeTestData(self, dtype):<br>+&nbsp;&nbsp;&nbsp;&nbsp;"""Edge-case test data for integer types."""<br>+&nbsp;&nbsp;&nbsp;&nbsp;nums = np.array([np.iinfo(dtype).min, -1, 1,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;np.iinfo(dtype).max],<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dtype=dtype).reshape([4, 1])<br>+&nbsp;&nbsp;&nbsp;&nbsp;divs = nums.reshape([1, 4])<br>+&nbsp;&nbsp;&nbsp;&nbsp;return nums, divs<br>+<br>+&nbsp;&nbsp;def testFloorDivModIntEdges(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;for dtype in [np.int32, np.int64]:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x, y = self.intEdgeTestData(dtype)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tf_floor_div = math_ops.floor_div(x, y)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;np_floor_div = self.numpySafeFloorDivInt(x, y)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertAllEqual(tf_floor_div, np_floor_div)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tf_floor_mod = math_ops.floormod(x, y)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;np_floor_mod = self.numpySafeFloorModInt(x, y)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertAllEqual(tf_floor_mod, np_floor_mod)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z = math_ops.add(math_ops.multiply(tf_floor_div, y), tf_floor_mod)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# x = floor_div(x, y) * y + floor_mod(x, y)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertAllEqual(z, np.broadcast_to(x, z.shape))<br>+<br>+&nbsp;&nbsp;def testTruncateDivModIntEdges(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;for dtype in [np.int32, np.int64]:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x, y = self.intEdgeTestData(dtype)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tf_truncate_div = math_ops.truncatediv(x, y)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;np_truncate_div = self.numpySafeTruncateDivInt(x, y)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertAllEqual(tf_truncate_div, np_truncate_div)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tf_truncate_mod = math_ops.truncatemod(x, y)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;np_truncate_mod = self.numpySafeTruncateModInt(x, y)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertAllEqual(tf_truncate_mod, np_truncate_mod)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z = math_ops.add(math_ops.multiply(tf_truncate_div, y), tf_truncate_mod)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# x = truncatediv(x, y) * y + truncatemod(x, y)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertAllEqual(z, np.broadcast_to(x, z.shape))</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">147</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">4c0ee937c0f61c4fc5f5d32d9bb4c67428012a60</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">sparse operations</td>
                    <td class="tg-0lax">sparse operations</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Prevent overflow by constructing the dense shape separately</td>
                    <td class="tg-0lax">sparse::SparseTensor sparse_tensor;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OP_REQUIRES_OK(context,<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sparse::SparseTensor::Create(<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input_indices, input_values,<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TensorShape(input_shape.vec&lt;int64&gt;()), &amp;sparse_tensor));</td>
                    <td class="tg-0lax">TensorShape dense_shape;<br>+&nbsp;&nbsp;&nbsp;&nbsp;const auto input_shape_flat = input_shape.flat&lt;int64&gt;();<br>+&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; input_shape.NumElements(); i++) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OP_REQUIRES_OK(context,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dense_shape.AddDimWithStatus(input_shape_flat(i)));<br>+&nbsp;&nbsp;&nbsp;&nbsp;}<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sparse::SparseTensor sparse_tensor;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OP_REQUIRES_OK(context,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TensorShape(input_shape.vec&lt;int64&gt;()), &amp;sparse_tensor));<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sparse::SparseTensor::Create(input_indices, input_values,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dense_shape, &amp;sparse_tensor));<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">148</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">7c8cc4ec69cd348e44ad6a2699057ca88faad3e5</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax">Op that looks up items from a sparse tensor in an embedding matrix. The sparse lookup tensor is represented by three individual tensors: lookup, indices, and dense_shape.</td>
                    <td class="tg-0lax">integer overflow</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">sparse operations</td>
                    <td class="tg-0lax">sparse operations, embedding</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax">ensure that output is not a null pointer that indicates overflow</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax">TF_LITE_ENSURE(context, output_shape != nullptr);</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">149</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">37054f9134af917ded7f40c7d663fa490d85c7d4</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">activation functions</td>
                    <td class="tg-0lax">activation functions</td>
                    <td class="tg-0lax">range of activation function, quantization</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax">Add extra robustness by adding more overflow checks to CalculateActivationRangeQuantized for cases where output tensor has bad, but still valid quantization parameters, which cause integer overflow.<br></td>
                    <td class="tg-0lax">void CalculateActivationRangeQuantizedImpl(TfLiteFusedActivation activation,<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32_t qmin, int32_t qmax,<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TfLiteTensor* output,<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32_t* act_min, int32_t* act_max) {<br><br>&nbsp;&nbsp;&nbsp;if (activation == kTfLiteActRelu) {<br>-&nbsp;&nbsp;&nbsp;&nbsp;*act_min = std::max(qmin, quantize(0.0));<br>&nbsp;&nbsp;&nbsp;} else if (activation == kTfLiteActRelu6) {<br>-&nbsp;&nbsp;&nbsp;&nbsp;*act_min = std::max(qmin, quantize(0.0));<br>-&nbsp;&nbsp;&nbsp;&nbsp;*act_max = std::min(qmax, quantize(6.0));<br>&nbsp;&nbsp;&nbsp;} else if (activation == kTfLiteActReluN1To1) {<br>-&nbsp;&nbsp;&nbsp;&nbsp;*act_min = std::max(qmin, quantize(-1.0));<br>-&nbsp;&nbsp;&nbsp;&nbsp;*act_max = std::min(qmax, quantize(1.0));<br><br></td>
                    <td class="tg-0lax">inline TfLiteStatus Quantize(TfLiteContext* context, float scale,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32_t zero_point, float f, int32_t&amp; q) {<br>+&nbsp;&nbsp;const float tmp = TfLiteRound(f / scale);<br>+&nbsp;&nbsp;const bool no_integer_overflow_from_quantization =<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(tmp &gt;= std::numeric_limits&lt;int32_t&gt;::min() &amp;&amp;<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp &lt;= std::numeric_limits&lt;int32_t&gt;::max());<br>+&nbsp;&nbsp;TF_LITE_ENSURE(context, no_integer_overflow_from_quantization);<br>+&nbsp;&nbsp;q = zero_point + static_cast&lt;int32_t&gt;(tmp);<br>+&nbsp;&nbsp;return kTfLiteOk;<br>+}<br>+<br>+TfLiteStatus CalculateActivationRangeQuantizedImpl(<br>+&nbsp;&nbsp;&nbsp;&nbsp;TfLiteContext* context, TfLiteFusedActivation activation, int32_t qmin,<br>+&nbsp;&nbsp;&nbsp;&nbsp;int32_t qmax, TfLiteTensor* output, int32_t* act_min, int32_t* act_max) {<br>+&nbsp;&nbsp;int32_t tmp_q;<br>&nbsp;&nbsp;&nbsp;if (activation == kTfLiteActRelu) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;TF_LITE_ENSURE_OK(context,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quantize(context, scale, zero_point, 0.0, tmp_q));<br>+&nbsp;&nbsp;&nbsp;&nbsp;*act_min = std::max(qmin, tmp_q);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*act_max = qmax;<br>&nbsp;&nbsp;&nbsp;} else if (activation == kTfLiteActRelu6) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;TF_LITE_ENSURE_OK(context,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quantize(context, scale, zero_point, 0.0, tmp_q));<br>+&nbsp;&nbsp;&nbsp;&nbsp;*act_min = std::max(qmin, tmp_q);<br>+&nbsp;&nbsp;&nbsp;&nbsp;TF_LITE_ENSURE_OK(context,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quantize(context, scale, zero_point, 6.0, tmp_q));<br>+&nbsp;&nbsp;&nbsp;&nbsp;*act_max = std::min(qmax, tmp_q);<br>&nbsp;&nbsp;&nbsp;} else if (activation == kTfLiteActReluN1To1) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;TF_LITE_ENSURE_OK(context,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quantize(context, scale, zero_point, -1.0, tmp_q));<br>+&nbsp;&nbsp;&nbsp;&nbsp;*act_min = std::max(qmin, tmp_q);<br>+&nbsp;&nbsp;&nbsp;&nbsp;TF_LITE_ENSURE_OK(context,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quantize(context, scale, zero_point, 1.0, tmp_q));<br>+&nbsp;&nbsp;&nbsp;&nbsp;*act_max = std::min(qmax, tmp_q);<br>&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*act_min = qmin;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*act_max = qmax;<br>&nbsp;&nbsp;&nbsp;}<br>+&nbsp;&nbsp;return kTfLiteOk;<br></td>
                    <td class="tg-0lax">TEST_F(KernelUtilTest, ActivationRangeQuantizedOverflow) {<br>+&nbsp;&nbsp;// Create output.<br>+&nbsp;&nbsp;TfLiteTensor output = {};<br>+&nbsp;&nbsp;output.type = kTfLiteUInt8;<br>+&nbsp;&nbsp;output.allocation_type = kTfLiteArenaRw;<br>+&nbsp;&nbsp;output.dims = nullptr;<br>+&nbsp;&nbsp;TfLiteQuantizationParams output_quant = {1e-10, -128};<br>+&nbsp;&nbsp;output.params = output_quant;<br>+&nbsp;&nbsp;output.quantization.type = kTfLiteAffineQuantization;<br>+&nbsp;&nbsp;auto* output_params = reinterpret_cast&lt;TfLiteAffineQuantization*&gt;(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;malloc(sizeof(TfLiteAffineQuantization)));<br>+&nbsp;&nbsp;output_params-&gt;scale = TfLiteFloatArrayCreate(1);<br>+&nbsp;&nbsp;output_params-&gt;scale-&gt;data[0] = 1;<br>+&nbsp;&nbsp;output_params-&gt;zero_point = TfLiteIntArrayCreate(1);<br>+&nbsp;&nbsp;output_params-&gt;zero_point-&gt;data[0] = -128;<br>+&nbsp;&nbsp;output.quantization.params = reinterpret_cast&lt;void*&gt;(output_params);<br>+<br>+&nbsp;&nbsp;// For bounded activation, a too small scale value may cause overflow.<br>+&nbsp;&nbsp;// Make sure overflow error is handled gracefully.<br>+&nbsp;&nbsp;int32_t act_min, act_max;<br>+&nbsp;&nbsp;ASSERT_EQ(kTfLiteOk,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CalculateActivationRangeQuantized(&amp;context_, kTfLiteActRelu,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;output, &amp;act_min, &amp;act_max));<br>+&nbsp;&nbsp;ASSERT_NE(kTfLiteOk,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CalculateActivationRangeQuantized(&amp;context_, kTfLiteActRelu6,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;output, &amp;act_min, &amp;act_max));<br>+&nbsp;&nbsp;EXPECT_TRUE(absl::StrContains(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context_.error, "no_integer_overflow_from_quantization was not true"));<br>+&nbsp;&nbsp;ASSERT_NE(kTfLiteOk,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CalculateActivationRangeQuantized(&amp;context_, kTfLiteActReluN1To1,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;output, &amp;act_min, &amp;act_max));<br>+&nbsp;&nbsp;EXPECT_TRUE(absl::StrContains(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context_.error, "no_integer_overflow_from_quantization was not true"));<br>+<br>+&nbsp;&nbsp;// Release.<br>+&nbsp;&nbsp;TfLiteTensorFree(&amp;output);</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">150</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">4253f96a58486ffe84b61c0415bb234a4632ee73</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">integer overflow</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">concatenate</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TF_LITE_ENSURE_EQ(context, t-&gt;type, input_type);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int d = 0; d &lt; t0-&gt;dims-&gt;size; ++d) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (d == axis) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Avoid integer overflow in sum_axis below<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TF_LITE_ENSURE(context, t-&gt;dims-&gt;data[axis] &gt;= 0);<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TF_LITE_ENSURE(context, t-&gt;dims-&gt;data[axis] &lt;=<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::numeric_limits&lt;int&gt;::max() - sum_axis);</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">sum</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">151</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">704866eabe03a9aeda044ec91a8d0c83fc1ebdbe</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">join segments</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"> OP_REQUIRES(context, num_segments_tensor.NumElements() != 0,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errors::InvalidArgument("Number of segments cannot be empty."));</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">152</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">87cf4d3ea9949051e50ca3f071fc909538a51cd0</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">sparse operations</td>
                    <td class="tg-0lax">sparse operations (concat)</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax">break if overflow occured</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"> bool overflow_ocurred = false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; N; i++) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int64 new_num_elements = 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OP_REQUIRES(context, TensorShapeUtils::IsVector(shapes[i].shape()),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errors::InvalidArgument(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Input shapes should be a vector but received shape ",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shapes[i].shape().DebugString(), " at position ", i));<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;auto input_shape_vector = shapes[i].vec&lt;int64&gt;();<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int j = 0; j &lt; input_shape_vector.size(); j++) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_num_elements =<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MultiplyWithoutOverflow(new_num_elements, input_shape_vector(j));<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (new_num_elements &lt; 0) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;overflow_ocurred = true;<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (overflow_ocurred) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br> <br>+&nbsp;&nbsp;&nbsp;&nbsp;OP_REQUIRES(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context, !overflow_ocurred,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errors::Internal("Encountered overflow from large input shape."));<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">153</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">b432a38fe0e1b4b904a6c222cbce794c39703e87</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">unit test</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">data processing</td>
                    <td class="tg-0lax">image processing</td>
                    <td class="tg-0lax">bounding boxes for image processing</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">replace check with require valid arguments into draw bounding box function and add useful error messages if argument invalid</td>
                    <td class="tg-0lax">CHECK_GE(min_box_row_clamp, 0);<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CHECK_GE(max_box_row_clamp, 0);<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CHECK_LT(min_box_row_clamp, height);<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CHECK_LT(max_box_row_clamp, height);<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CHECK_GE(min_box_col_clamp, 0);<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CHECK_GE(max_box_col_clamp, 0);<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CHECK_LT(min_box_col_clamp, width);<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CHECK_LT(max_box_col_clamp, width);<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CHECK_LT(min_box_row, height);<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CHECK_GE(max_box_row, 0);<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CHECK_LT(min_box_col, width);<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CHECK_GE(max_box_col, 0);</td>
                    <td class="tg-0lax"> OP_REQUIRES(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context, min_box_row_clamp &gt;= 0,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errors::InvalidArgument("Min box row clamp is less than 0."));<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OP_REQUIRES(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context, max_box_row_clamp &gt;= 0,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errors::InvalidArgument("Max box row clamp is less than 0."));<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OP_REQUIRES(context, min_box_row_clamp &lt;= height,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errors::InvalidArgument(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Min box row clamp is greater than height."));<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OP_REQUIRES(context, max_box_row_clamp &lt;= height,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errors::InvalidArgument(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Max box row clamp is greater than height."));<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OP_REQUIRES(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context, min_box_col_clamp &gt;= 0,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errors::InvalidArgument("Min box col clamp is less than 0."));<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OP_REQUIRES(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context, max_box_col_clamp &gt;= 0,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errors::InvalidArgument("Max box col clamp is less than 0."));<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OP_REQUIRES(context, min_box_col_clamp &lt;= width,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errors::InvalidArgument(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Min box col clamp is greater than width."));<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OP_REQUIRES(context, max_box_col_clamp &lt;= width,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errors::InvalidArgument(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Max box col clamp is greater than width."));<br><br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OP_REQUIRES(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context, min_box_row &lt;= height,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errors::InvalidArgument("Min box row is greater than height."));<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OP_REQUIRES(context, max_box_row &gt;= 0,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errors::InvalidArgument("Max box row is less than 0."));<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OP_REQUIRES(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context, min_box_col &lt;= width,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errors::InvalidArgument("Min box col is greater than width."));<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OP_REQUIRES(context, max_box_col &gt;= 0,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errors::InvalidArgument("Max box col is less than 0."));<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">154</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">87d2b9751513253058be671313db3e32cc13842a</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">unit test</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">sparse operations</td>
                    <td class="tg-0lax">sparse operations (concat)</td>
                    <td class="tg-0lax">fix overflow check</td>
                    <td class="tg-0lax">fix test/warning</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shapes.size()));<br>-&nbsp;&nbsp;&nbsp;&nbsp;bool overflow_ocurred = false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; N; i++) {<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int new_num_elements = 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OP_REQUIRES(context, TensorShapeUtils::IsVector(shapes[i].shape()),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errors::InvalidArgument(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Input shapes should be a vector but received shape ",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shapes[i].shape().DebugString(), " at position ", i));<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;auto input_shape_vector = shapes[i].vec&lt;int64&gt;();<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int j = 0; j &lt; input_shape_vector.size(); j++) {<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_num_elements =<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MultiplyWithoutOverflow(new_num_elements, input_shape_vector(j));<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (new_num_elements &lt; 0) {<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;overflow_ocurred = true;<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>-<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (overflow_ocurred) {<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br> <br>-&nbsp;&nbsp;&nbsp;&nbsp;OP_REQUIRES(<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context, !overflow_ocurred,<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errors::Internal("Encountered overflow from large input shape."));<br></td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">155</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">7bb2d255e6d404cbfa528d0ffc2f22248e6c1b21</td>
                    <td class="tg-0lax">Cuda</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">sparse operations</td>
                    <td class="tg-0lax">sparse to dense operation</td>
                    <td class="tg-0lax">change variable type</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">use int 64 as index</td>
                    <td class="tg-0lax">Index output_idx = indices[thread_idx * ndims + ndims - 1];</td>
                    <td class="tg-0lax">int64 output_idx = indices[thread_idx * ndims + ndims - 1];</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">156</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">dc4d330cfe25bbb0c3e4759dadfb16d4715f338a</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">underflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">underflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">If a complex value's squared norm was denormal but had a non-zero imaginary part, the Householder reflection computation could yield NaNs.</td>
                    <td class="tg-0lax">linear algebra</td>
                    <td class="tg-0lax">norm</td>
                    <td class="tg-0lax">norm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">By using a more accurate norm, we can avoid the underflow. The new norm Computes sqrt(x^2 + y^2 + ...), avoiding overflow/underflow</td>
                    <td class="tg-0lax">auto mu = Sqrt(Real(alpha * Conj(alpha)) + sigma);</td>
                    <td class="tg-0lax">XlaOp Norm(std::vector&lt;XlaOp&gt; xs) {<br>+&nbsp;&nbsp;CHECK(!xs.empty());<br>+&nbsp;&nbsp;XlaOp w;<br>+&nbsp;&nbsp;for (size_t i = 0; i &lt; xs.size(); ++i) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;xs[i] = Abs(xs[i]);<br>+&nbsp;&nbsp;&nbsp;&nbsp;w = i == 0 ? xs[i] : xla::Max(w, xs[i]);<br>+&nbsp;&nbsp;}<br>+<br>+&nbsp;&nbsp;XlaOp out;<br>+&nbsp;&nbsp;for (size_t i = 0; i &lt; xs.size(); ++i) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;XlaOp t = Square(xs[i] / w);<br>+&nbsp;&nbsp;&nbsp;&nbsp;out = i == 0 ? t : xla::Add(out, t);<br>+&nbsp;&nbsp;}<br>+&nbsp;&nbsp;return Select(Eq(w, ZerosLike(w)), ZerosLike(w), w * Sqrt(out));<br><br>auto mu = Norm({Real(alpha), Imag(alpha), Sqrt(sigma)});</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">157</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">ff6601a943db5f71fda09210e67ba8e9fd839ae8</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax">CombinedNonMaxSuppression greedily selects a subset of bounding boxes in descending order of score</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">data processing</td>
                    <td class="tg-0lax">image processing</td>
                    <td class="tg-0lax">non_max_suppression</td>
                    <td class="tg-0lax">change variable type</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">Use an int32 scalar as the default type for representing the maximum number of boxes retained over all classes. If int32 should overflow, use int64</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">max_total_size = ops.convert_to_tensor(max_total_size)<br></td>
                    <td class="tg-0lax">class CombinedNonMaxSuppressionTest(test_util.TensorFlowTestCase):<br>+<br>+&nbsp;&nbsp;# NOTE(b/142795960): parameterized tests do not work well with tf.tensor<br>+&nbsp;&nbsp;# inputs. Due to failures, creating another test `testInvalidTensorInput`<br>+&nbsp;&nbsp;# which is identical to this one except that the input here is a scalar as<br>+&nbsp;&nbsp;# opposed to a tensor.<br>+&nbsp;&nbsp;def testInvalidPyInput(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;boxes_np = [[[[0, 0, 1, 1], [0, 0.1, 1, 1.1], [0, -0.1, 1, 0.9],<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0, 10, 1, 11], [0, 10.1, 1, 11.1], [0, 100, 1, 101]]]]<br>+&nbsp;&nbsp;&nbsp;&nbsp;scores_np = [[[0.9, 0.75, 0.6, 0.95, 0.5, 0.3]]]<br>+&nbsp;&nbsp;&nbsp;&nbsp;max_output_size_per_class = 5<br>+&nbsp;&nbsp;&nbsp;&nbsp;max_total_size = 2**31<br>+&nbsp;&nbsp;&nbsp;&nbsp;with self.assertRaisesRegex(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(TypeError, ValueError),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"type int64 that does not match expected type of int32|"<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Tensor conversion requested dtype int32 for Tensor with dtype int64"):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_ops.combined_non_max_suppression(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boxes=boxes_np,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scores=scores_np,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_output_size_per_class=max_output_size_per_class,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_total_size=max_total_size)<br>+<br>+&nbsp;&nbsp;# NOTE(b/142795960): parameterized tests do not work well with tf.tensor<br>+&nbsp;&nbsp;# inputs. Due to failures, creating another this test which is identical to<br>+&nbsp;&nbsp;# `testInvalidPyInput` except that the input is a tensor here as opposed<br>+&nbsp;&nbsp;# to a scalar.<br>+&nbsp;&nbsp;def testInvalidTensorInput(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;boxes_np = [[[[0, 0, 1, 1], [0, 0.1, 1, 1.1], [0, -0.1, 1, 0.9],<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0, 10, 1, 11], [0, 10.1, 1, 11.1], [0, 100, 1, 101]]]]<br>+&nbsp;&nbsp;&nbsp;&nbsp;scores_np = [[[0.9, 0.75, 0.6, 0.95, 0.5, 0.3]]]<br>+&nbsp;&nbsp;&nbsp;&nbsp;max_output_size_per_class = 5<br>+&nbsp;&nbsp;&nbsp;&nbsp;max_total_size = ops.convert_to_tensor(2**31)<br>+&nbsp;&nbsp;&nbsp;&nbsp;with self.assertRaisesRegex(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(TypeError, ValueError),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"type int64 that does not match expected type of int32|"<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Tensor conversion requested dtype int32 for Tensor with dtype int64"):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_ops.combined_non_max_suppression(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boxes=boxes_np,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scores=scores_np,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_output_size_per_class=max_output_size_per_class,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_total_size=max_total_size)</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">158</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">94b6db8cc538408cc29d88be13307f9fd8a77120</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax">Dynamic stitch interleaves the values from the data tensors into a single tensor.</td>
                    <td class="tg-0lax">slice_size must not be stored as int for cases of tensors over 2GB.</td>
                    <td class="tg-0lax">data processing</td>
                    <td class="tg-0lax">data</td>
                    <td class="tg-0lax">dynamic_stitch</td>
                    <td class="tg-0lax">change variable type</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">use auto type instead of int</td>
                    <td class="tg-0lax">const int slice_size = merged_flat.dimension(1);</td>
                    <td class="tg-0lax">const auto slice_size = merged_flat.dimension(1);</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">159</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">087859fce9409991164f727735743da4cb310fd4</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">large input size</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">computational graph</td>
                    <td class="tg-0lax">bilinear operation, computational graph optimization</td>
                    <td class="tg-0lax">change variable type</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">use int64 instead of int</td>
                    <td class="tg-0lax">const int output_elements = CalculateTensorElementCount(</td>
                    <td class="tg-0lax">const int64 output_elements = CalculateTensorElementCount</td>
                    <td class="tg-0lax">// Cost with very large tensor.<br>+&nbsp;&nbsp;&nbsp;&nbsp;op_context.op_info.clear_outputs();<br>+&nbsp;&nbsp;&nbsp;&nbsp;// Number of elements in tensor exceeds 2^32.<br>+&nbsp;&nbsp;&nbsp;&nbsp;constexpr int64 kLargeOutputImageDim = 40000;<br>+&nbsp;&nbsp;&nbsp;&nbsp;DescribeTensor4D(1, kLargeOutputImageDim, kLargeOutputImageDim,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kChannelSize, op_context.op_info.add_outputs());<br>+&nbsp;&nbsp;&nbsp;&nbsp;const int64 kInterpWeightCost = 12;<br>+&nbsp;&nbsp;&nbsp;&nbsp;// Using half_pixel_centers.<br>+&nbsp;&nbsp;&nbsp;&nbsp;AttrValue half_pixel_centers;<br>+&nbsp;&nbsp;&nbsp;&nbsp;half_pixel_centers.set_b(true);<br>+&nbsp;&nbsp;&nbsp;&nbsp;(*op_context.op_info.mutable_attr())["half_pixel_centers"] =<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;half_pixel_centers;<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;const int64 num_ops =<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kInterpWeightCost * (kLargeOutputImageDim * 2) +<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kComputeLerpCost *<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(kLargeOutputImageDim * kLargeOutputImageDim * kChannelSize);<br>+&nbsp;&nbsp;&nbsp;&nbsp;const int64 expected_compute_time = std::ceil(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num_ops /<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;estimator_.GetDeviceInfo(op_context.op_info.device()).gigaops);<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;const int64 expected_memory_time =<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(kImageDim * kImageDim + kLargeOutputImageDim * kLargeOutputImageDim) *<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4;<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;const auto cost = PredictCosts(op_context);<br>+&nbsp;&nbsp;&nbsp;&nbsp;EXPECT_EQ(cost.compute_time, Costs::Duration(expected_compute_time));<br>+&nbsp;&nbsp;&nbsp;&nbsp;EXPECT_EQ(cost.memory_time, Costs::Duration(expected_memory_time));<br>+&nbsp;&nbsp;&nbsp;&nbsp;EXPECT_EQ(cost.execution_time,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Costs::Duration(expected_memory_time + expected_compute_time));<br>+&nbsp;&nbsp;&nbsp;&nbsp;EXPECT_FALSE(cost.inaccurate);<br>+&nbsp;&nbsp;&nbsp;&nbsp;EXPECT_EQ(cost.num_ops_with_unknown_shapes, 0);<br>+&nbsp;&nbsp;}</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">160</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">90e89339a9bf04fb304129a01ca50f25fdde441d</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">potential overflow in 64-bit MultiplyByQuantizedMultiplier function<br></td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">int32_t reduced_multiplier = (quantized_multiplier + (1 &lt;&lt; 15)) &gt;&gt; 16;<br></td>
                    <td class="tg-0lax">int32_t reduced_multiplier = (quantized_multiplier &lt; 0x7FFF0000)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;? ((quantized_multiplier + (1 &lt;&lt; 15)) &gt;&gt; 16)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: 0x7FFF;</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">161</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">dffb0b56192f4c95fbf563a82742b4a3f4881e05</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;&nbsp;A U16 of 46977 multiplied by a U16 of 53826, when evaluated in the evaluator,<br>&nbsp;&nbsp;&nbsp;&nbsp;results in the operands of the multiply getting promoted to the C++ type "int"<br>&nbsp;&nbsp;&nbsp;&nbsp;which is signed. The result of the multiply will overflow a signed int and give<br>&nbsp;&nbsp;&nbsp;&nbsp;a negative result.<br></td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler, XLA HLO (high level operations)</td>
                    <td class="tg-0lax">change variable type</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">promote both operands to "unsigned int" which will not suffer<br>&nbsp;&nbsp;&nbsp;&nbsp;from any overflow issues</td>
                    <td class="tg-0lax"> typename std::enable_if&lt;std::is_integral&lt;T&gt;::value &amp;&amp;<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::is_signed&lt;T&gt;::value&gt;::type* = nullptr&gt;<br>-typename std::make_unsigned&lt;T&gt;::type ToArithmeticSafeType(T t) {<br>-&nbsp;&nbsp;return static_cast&lt;typename std::make_unsigned&lt;T&gt;::type&gt;(t);<br><br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typename std::enable_if&lt;!std::is_integral&lt;T&gt;::value ||<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!std::is_signed&lt;T&gt;::value&gt;::type* = nullptr&gt;<br></td>
                    <td class="tg-0lax">namespace detail {<br>+template &lt;typename T&gt;<br>+using unsigned_promoted_type_t =<br>+&nbsp;&nbsp;&nbsp;&nbsp;std::make_unsigned_t&lt;decltype(std::declval&lt;T&gt;() + std::declval&lt;T&gt;())&gt;;<br>+}<br><br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typename std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::type* = nullptr&gt;<br>+detail::unsigned_promoted_type_t&lt;T&gt; ToArithmeticSafeType(T t) {<br>+&nbsp;&nbsp;return static_cast&lt;detail::unsigned_promoted_type_t&lt;T&gt;&gt;(t);<br><br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typename std::enable_if&lt;!std::is_integral&lt;T&gt;::value&gt;::type* = nullptr&gt;<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">162</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">90b80fba1ade0222713b8a33af00858190532075</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">compiler message overflow</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler, XLA HLO (high level operations)</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">limit max inuts</td>
                    <td class="tg-0lax">SummarizeNodeDef(node_def), ".\n");<br>string SummarizeNodeDef(const NodeDef&amp; node_def) {</td>
                    <td class="tg-0lax">SummarizeNodeDef(node_def, /*max_inputs_in_summary=*/10), ".\n");<br>+string SummarizeNodeDef(const NodeDef&amp; node_def, int max_inputs_in_summary) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;if (max_inputs_in_summary-- == 0) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strings::StrAppend(&amp;ret, "...");<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>+// The parameter `max_inputs_in_summary` specifies how many inputs at most to<br>+// serialize in the output (in order not to get a string which is overly large).<br>+// The value `-1` specifies that all inputs will be shown.<br>+string SummarizeNodeDef(const NodeDef&amp; node_def,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int max_inputs_in_summary = -1);</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">163</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">036b75a818493a30cd25caef1761931a3bc2b074</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">increase precision of index from int to int64</td>
                    <td class="tg-0lax">int linear_index = j * vector_size + i;</td>
                    <td class="tg-0lax">int64 linear_index = j * vector_size + i;</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">164</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">2adf1114d4dc7ca30e5117acd2dc7aeb3279feb7</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">unit test</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax">The Android Neural Networks API (NNAPI) is available on all Android devices running Android 8.1 (API level 27) or higher. It provides acceleration for TensorFlow Lite models on Android devices with supported hardware accelerators including:<br><br>Graphics Processing Unit (GPU)<br>Digital Signal Processor (DSP)<br>Neural Processing Unit (NPU)<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">NNAPI delegate</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax">add overflow check of cpu</td>
                    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;&nbsp;// reference CPU path.<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expect(is_accelerator_specified ||<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(builtin-&gt;filter_width * builtin-&gt;filter_height &lt;= 256),<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NNAPIValidationFailureType::kUnsupportedOperandSize,<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Large filter window would overflow on the reference CPU path",<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;val_ctx);</td>
                    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// quantized reference CPU path.<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (IsQuantized(context-&gt;tensors[node-&gt;inputs-&gt;data[0]].type)) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expect(is_accelerator_specified ||<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(builtin-&gt;filter_width * builtin-&gt;filter_height &lt;= 256),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NNAPIValidationFailureType::kUnsupportedOperandSize,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Large filter window would overflow on the reference CPU path",<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;val_ctx);<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">165</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">85f10eb4200b3b3339340943b288da157e9742e7</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">unit test</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Compilers are producing different<br>&nbsp;&nbsp;&nbsp;&nbsp;code and resulting in bad assumptions.</td>
                    <td class="tg-0lax">precision tests/speed benchmarks</td>
                    <td class="tg-0lax">overflow test</td>
                    <td class="tg-0lax">overflow test</td>
                    <td class="tg-0lax">change variable type</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">change type of variable y from auto to int64</td>
                    <td class="tg-0lax">-&nbsp;&nbsp;for (auto x : interesting) {<br>-&nbsp;&nbsp;&nbsp;&nbsp;for (auto y : interesting) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>-&nbsp;&nbsp;long double dxy = static_cast&lt;long double&gt;(x) * y;<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (dxy &gt; std::numeric_limits&lt;int64&gt;::max()) {<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EXPECT_LT(xy, 0);</td>
                    <td class="tg-0lax">bool HasOverflow(int64 x, int64 y) {<br>+#ifdef PLATFORM_WINDOWS<br>+&nbsp;&nbsp;// `long double` on MSVC is 64 bits not 80 bits - use a windows specific API<br>+&nbsp;&nbsp;// for this test.<br>+&nbsp;&nbsp;return ::MultiplyHigh(x, y) != 0;<br>+#else<br>+&nbsp;&nbsp;long double dxy = static_cast&lt;long double&gt;(x) * static_cast&lt;long double&gt;(y);<br>+&nbsp;&nbsp;return dxy &gt; std::numeric_limits&lt;int64&gt;::max();<br>+#endif<br>+}<br><br>+&nbsp;&nbsp;for (int64 x : interesting) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;for (int64 y : interesting) {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (HasOverflow(x, y)) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EXPECT_LT(xy, 0) &lt;&lt; x &lt;&lt; " " &lt;&lt; y;</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">166</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">171ba06f5e52078e0aa2112797b5a4227370bbd5</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">unit test</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Subgraphs are the part of main graph and are themselves computational graphs by nature.</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">computational graph</td>
                    <td class="tg-0lax">tensorflow subgraph graph generation</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax">bring back overflow detection for windows</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">167</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">2522ce7dd5d28c9733824a66133fc918290e3ed0</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">data processing</td>
                    <td class="tg-0lax">tensor allocation</td>
                    <td class="tg-0lax">tensor allocation</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax">Check for overflow in # of bytes computation of tensor allocation.<br>Check both for product of shape dimensions (# of elements) and number of bytes (elements * sizeof(data_type)).</td>
                    <td class="tg-0lax">no overflow check</td>
                    <td class="tg-0lax">TfLiteStatus MultiplyAndCheckOverflow(size_t a, size_t b, size_t* product) {<br>+&nbsp;&nbsp;constexpr size_t overflow_threshold = (8 * sizeof(size_t)) &gt;&gt; 1;<br>+&nbsp;&nbsp;*product = a * b;<br>+&nbsp;&nbsp;// If neither integers have non-zero bits past 32 bits can't overflow.<br>+&nbsp;&nbsp;// Otherwise check using slow devision.<br>+&nbsp;&nbsp;if (__builtin_expect((a | b) &gt;&gt; overflow_threshold != 0, false)) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;if (a != 0 &amp;&amp; *product / a != b) return kTfLiteError;<br>+&nbsp;&nbsp;}<br>+&nbsp;&nbsp;return kTfLiteOk;<br><br>+&nbsp;&nbsp;for (int k = 0; k &lt; dims_size; k++) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;size_t old_count = count;<br>+&nbsp;&nbsp;&nbsp;&nbsp;TF_LITE_ENSURE_MSG(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;context_,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MultiplyAndCheckOverflow(old_count, dims[k], &amp;count) == kTfLiteOk,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"BytesRequired number of elements overflowed.\n");<br>+&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;size_t type_size = 0;<br>&nbsp;&nbsp;&nbsp;TF_LITE_ENSURE_OK(&amp;context_, GetSizeOfType(&amp;context_, type, &amp;type_size));<br><br>+&nbsp;&nbsp;TF_LITE_ENSURE_MSG(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;context_, MultiplyAndCheckOverflow(type_size, count, bytes) == kTfLiteOk,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"BytesRequired number of bytes overflowed.\n");<br><br></td>
                    <td class="tg-0lax">TEST(BasicInterpreter, TestOverflow) {<br>+&nbsp;&nbsp;TestErrorReporter reporter;<br>+&nbsp;&nbsp;Interpreter interpreter(&amp;reporter);<br>+&nbsp;&nbsp;TfLiteQuantizationParams quantized;<br>+<br>+&nbsp;&nbsp;ASSERT_EQ(interpreter.AddTensors(1), kTfLiteOk);<br>+&nbsp;&nbsp;ASSERT_EQ(interpreter.SetInputs({0}), kTfLiteOk);<br>+&nbsp;&nbsp;ASSERT_EQ(interpreter.SetOutputs({0}), kTfLiteOk);<br>+&nbsp;&nbsp;// Overflow testing is pointer word size dependent.<br>+&nbsp;&nbsp;if (sizeof(size_t) == 8) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;// #bits for bytecount = 30 + 30 + 2 = 62 &lt; 64<br>+&nbsp;&nbsp;&nbsp;&nbsp;ASSERT_EQ(interpreter.SetTensorParametersReadWrite(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0, kTfLiteFloat32, "in1", {1 &lt;&lt; 30, 1 &lt;&lt; 30}, quantized),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kTfLiteOk);<br>+&nbsp;&nbsp;&nbsp;&nbsp;// #bits for element count = 30 + 30 + 2 = 62 &lt; 64 (no overflow)<br>+&nbsp;&nbsp;&nbsp;&nbsp;// #bits for byte count = 30 + 30 + 2 + 2 = 64 == 64 (overflow)<br>+&nbsp;&nbsp;&nbsp;&nbsp;ASSERT_NE(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interpreter.SetTensorParametersReadWrite(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0, kTfLiteFloat32, "in1", {1 &lt;&lt; 30, 1 &lt;&lt; 30, 1 &lt;&lt; 2}, quantized),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kTfLiteOk);<br>+&nbsp;&nbsp;&nbsp;&nbsp;EXPECT_THAT(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reporter.error_messages(),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testing::EndsWith("BytesRequired number of bytes overflowed.\n"));<br>+&nbsp;&nbsp;&nbsp;&nbsp;// #bits for element count = 30 + 30 + 2 + 4 = 66 &gt; 64 (overflow).<br>+&nbsp;&nbsp;&nbsp;&nbsp;// #bits for byte count = 30 + 30 + 2 + 4 + 2 = 68 &gt; 64 (overflow).<br>+&nbsp;&nbsp;&nbsp;&nbsp;reporter.Reset();<br>+&nbsp;&nbsp;&nbsp;&nbsp;ASSERT_NE(interpreter.SetTensorParametersReadWrite(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0, kTfLiteFloat32, "in1", {1 &lt;&lt; 30, 1 &lt;&lt; 30, 1 &lt;&lt; 2, 1 &lt;&lt; 4},<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quantized),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kTfLiteOk);<br>+&nbsp;&nbsp;&nbsp;&nbsp;EXPECT_THAT(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reporter.error_messages(),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testing::EndsWith("BytesRequired number of elements overflowed.\n"));<br>+<br>+&nbsp;&nbsp;} else if (sizeof(size_t) == 4) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;// #bits for bytecount = 14 + 14 + 2 = 30 &lt; 32<br>+&nbsp;&nbsp;&nbsp;&nbsp;ASSERT_EQ(interpreter.SetTensorParametersReadWrite(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0, kTfLiteFloat32, "in1", {1 &lt;&lt; 14, 1 &lt;&lt; 14}, quantized),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kTfLiteOk);<br>+&nbsp;&nbsp;&nbsp;&nbsp;// #bits for element count = 14 + 14 + 3 = 31 &lt; 32 (no overflow).<br>+&nbsp;&nbsp;&nbsp;&nbsp;// #bits for byte count = 14 + 14 + 3 + 2 = 33 &gt; 32 (overflow).<br>+&nbsp;&nbsp;&nbsp;&nbsp;ASSERT_NE(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interpreter.SetTensorParametersReadWrite(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0, kTfLiteFloat32, "in1", {1 &lt;&lt; 14, 1 &lt;&lt; 14, 1 &lt;&lt; 3}, quantized),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kTfLiteOk);<br>+&nbsp;&nbsp;&nbsp;&nbsp;EXPECT_THAT(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reporter.error_messages(),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testing::EndsWith("BytesRequired number of bytes overflowed.\n"));<br>+&nbsp;&nbsp;&nbsp;&nbsp;// #bits for element count = 14 + 14 + 4 = 32 == 32 (overflow).<br>+&nbsp;&nbsp;&nbsp;&nbsp;// byte count also overflows, but we don't get to that check.<br>+&nbsp;&nbsp;&nbsp;&nbsp;reporter.Reset();<br>+&nbsp;&nbsp;&nbsp;&nbsp;ASSERT_NE(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interpreter.SetTensorParametersReadWrite(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0, kTfLiteFloat32, "in1", {1 &lt;&lt; 14, 1 &lt;&lt; 14, 1 &lt;&lt; 4}, quantized),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kTfLiteOk);<br>+&nbsp;&nbsp;&nbsp;&nbsp;EXPECT_THAT(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reporter.error_messages(),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testing::EndsWith("BytesRequired number of elements overflowed.\n"));<br>+&nbsp;&nbsp;} else {<br>+&nbsp;&nbsp;&nbsp;&nbsp;// This test failing means that we are using a non 32/64 bit architecture.<br>+&nbsp;&nbsp;&nbsp;&nbsp;ASSERT_TRUE(false);<br>+&nbsp;&nbsp;}<br>+}<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">168</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">75e5b5d70b6f33bd41fdf07b844c762b23f99d1b</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflows in accumulation results</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">summation</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">upcastto an integer type with more bits</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax">// Upcast small integer types to 32 bit to avoid overflow.<br>+&nbsp;&nbsp;if (dtype == DT_INT8 || dtype == DT_INT16) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;return DT_INT32;<br>+&nbsp;&nbsp;}<br>+&nbsp;&nbsp;if (dtype == DT_UINT8 || dtype == DT_UINT16) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;return DT_UINT32;<br>+&nbsp;&nbsp;}</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">169</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">23fde233bf3210759b5a4453bc39101df9c86d0c</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">statistics</td>
                    <td class="tg-0lax">mean</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">Perform mean reductions for integer types in 64 bit to mitigate overflow in the sum and/or denominator.<br>I.e.: Upcast int8, int16, int32 into int64</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">define CASTING_SPECIALIZATION(ScalarType, IntermediateType)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>+&nbsp;&nbsp;template &lt;typename Device, typename OUT_T, typename IN_T,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typename ReductionAxes&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>+&nbsp;&nbsp;struct ReduceEigenImpl&lt;Device, OUT_T, IN_T, ReductionAxes,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;functor::MeanReducer&lt;ScalarType&gt;&gt; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>+&nbsp;&nbsp;&nbsp;&nbsp;void operator()(const Device&amp; d, OUT_T out, IN_T in,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const ReductionAxes&amp; reduction_axes,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const functor::MeanReducer&lt;ScalarType&gt;&amp; reducer) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static_assert(std::is_same&lt;ScalarType, typename OUT_T::Scalar&gt;::value,&nbsp;&nbsp;\<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Eigen::internal::SumReducer&lt;IntermediateType&gt; sum_reducer;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.device(d) = (in.template cast&lt;IntermediateType&gt;().reduce(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reduction_axes, sum_reducer) /&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static_cast&lt;IntermediateType&gt;(in.size() / out.size())) \<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.template cast&lt;ScalarType&gt;();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>+&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>+&nbsp;&nbsp;}</td>
                    <td class="tg-0lax"># This tests the issue reported in b/145030710.<br>+&nbsp;&nbsp;@test_util.run_deprecated_v1<br>+&nbsp;&nbsp;def testSizeOverflowUint8(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;np_arr = self._makeRandom((2**8,), dtypes.uint8)<br>+&nbsp;&nbsp;&nbsp;&nbsp;self._compareAllAxes(np_arr)<br>+<br>+&nbsp;&nbsp;@test_util.run_deprecated_v1<br>+&nbsp;&nbsp;def testSizeOverflowInt8(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;np_arr = self._makeRandom((2**7,), dtypes.int8)<br>+&nbsp;&nbsp;&nbsp;&nbsp;self._compareAllAxes(np_arr)<br>+<br>+&nbsp;&nbsp;@test_util.run_deprecated_v1<br>+&nbsp;&nbsp;def testSizeOverflowUint16(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;np_arr = self._makeRandom((2**16,), dtypes.uint16)<br>+&nbsp;&nbsp;&nbsp;&nbsp;self._compareAllAxes(np_arr)<br>+<br>+&nbsp;&nbsp;@test_util.run_deprecated_v1<br>+&nbsp;&nbsp;def testSizeOverflowInt16(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;np_arr = self._makeRandom((2**15,), dtypes.int16)<br>+&nbsp;&nbsp;&nbsp;&nbsp;self._compareAllAxes(np_arr)</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">170</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">79605069321520bd8af318eef92b71070dcc8961</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax">strided_slice extracts a strided slice of a tensor (generalized Python array indexing).</td>
                    <td class="tg-0lax">strided_slice would overflow for end and start slices larger than int16</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">strided slice kernel</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">change the StridedSliceParams start_indices and end_indices from int16 to int32 values</td>
                    <td class="tg-0lax"> struct StridedSliceParams {<br>&nbsp;&nbsp;&nbsp;int8 start_indices_count;<br>-&nbsp;&nbsp;int16 start_indices[4];<br>&nbsp;&nbsp;&nbsp;int8 stop_indices_count;<br>-&nbsp;&nbsp;int16 stop_indices[4];<br>&nbsp;&nbsp;&nbsp;int8 strides_count;<br>-&nbsp;&nbsp;int16 strides[4];</td>
                    <td class="tg-0lax"> struct StridedSliceParams {<br>&nbsp;&nbsp;&nbsp;int8 start_indices_count;<br>+&nbsp;&nbsp;int32 start_indices[4];<br>&nbsp;&nbsp;&nbsp;int8 stop_indices_count;<br>+&nbsp;&nbsp;int32 stop_indices[4];<br>&nbsp;&nbsp;&nbsp;int8 strides_count;<br>+&nbsp;&nbsp;int32 strides[4];<br></td>
                    <td class="tg-0lax">TEST(StridedSliceOpTest, In1D_Int32End) {<br>+&nbsp;&nbsp;StridedSliceOpModel&lt;&gt; m({32768}, {1}, {1}, {1}, 0, 0, 0, 0, 0);<br>+&nbsp;&nbsp;std::vector&lt;float&gt; values;<br>+&nbsp;&nbsp;for (int i = 0; i &lt; 32768; i++) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;values.push_back(i);<br>+&nbsp;&nbsp;}<br>+&nbsp;&nbsp;m.SetInput(values);<br>+&nbsp;&nbsp;m.SetBegin({0});<br>+&nbsp;&nbsp;m.SetEnd({32768});<br>+&nbsp;&nbsp;m.SetStrides({1});<br>+&nbsp;&nbsp;m.Invoke();<br>+&nbsp;&nbsp;EXPECT_THAT(m.GetOutputShape(), ElementsAreArray({32768}));<br>+&nbsp;&nbsp;EXPECT_THAT(m.GetOutput(), ElementsAreArray(values));<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">171</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">eaea3db3be4e27464a0b669bebffe46f2f8b005f</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow in quantization if there is a mismatch in scale of weights and biases</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">Adjusts the scale of the weight tensor when the scale is small enough to lead to overflow due to a mismatch with the scale of the bias values.<br>Checks that the bias is quantized to within the middle half of the allowable bit range determined by the scales of the input and weight tensors If this condition is not satisfied, the scale of the weights is increased in order to prevent overflow.</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">TfLiteStatus AdjustWeightsForBiasScale(QuantizationParametersT* quant_params,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const float* bias_data,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const size_t bias_size,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const float input_scale,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ErrorReporter* error_reporter) {<br>+&nbsp;&nbsp;// TODO(dmolitor) Allow adjusting activation scale.<br>+&nbsp;&nbsp;// TODO(dmolitor) Tighten scale adjustment.<br>+&nbsp;&nbsp;// TODO(dmolitor) Test using a separate strategy for scales of 0.<br>+&nbsp;&nbsp;const int32_t kScale = std::numeric_limits&lt;int32_t&gt;::max();<br>+&nbsp;&nbsp;if (quant_params == nullptr) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;error_reporter-&gt;Report("Missing max and min values for weight tensor.");<br>+&nbsp;&nbsp;&nbsp;&nbsp;return kTfLiteError;<br>+&nbsp;&nbsp;}<br>+&nbsp;&nbsp;// channel_dim_size is calculated from min.size() to infer whether<br>+&nbsp;&nbsp;// quantization is per axis<br>+&nbsp;&nbsp;int channel_dim_size = quant_params-&gt;min.size();<br>+&nbsp;&nbsp;if (channel_dim_size == 0) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;error_reporter-&gt;Report(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Missing weight scales. Unable to check compatibility with bias "<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"scale.");<br>+&nbsp;&nbsp;&nbsp;&nbsp;return kTfLiteError;<br>+&nbsp;&nbsp;}<br>+<br>+&nbsp;&nbsp;std::vector&lt;float&gt; weight_scales(channel_dim_size);<br>+&nbsp;&nbsp;TF_LITE_ENSURE_STATUS(GetSymmetricScalesFromMaxMin(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quant_params, &amp;weight_scales, error_reporter));<br>+<br>+&nbsp;&nbsp;// Per channel quantization<br>+&nbsp;&nbsp;if (channel_dim_size &gt; 1) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;for (size_t i = 0; i &lt; channel_dim_size; ++i) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Current scale is not compatible with bias. Adjust max/min values.<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (std::abs(bias_data[i]) &gt;=<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.5 * input_scale * weight_scales[i] * kScale) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quant_params-&gt;max[i] = 2.0 * std::abs(bias_data[i]) / kScale *<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(kMaxQuantizedValue / input_scale);<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quant_params-&gt;min[i] = -quant_params-&gt;max[i];<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>+&nbsp;&nbsp;&nbsp;&nbsp;}<br>+&nbsp;&nbsp;&nbsp;&nbsp;// Per layer quantization<br>+&nbsp;&nbsp;} else if (channel_dim_size == 1) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;const auto minmax = std::minmax_element(bias_data, bias_data + bias_size);<br>+&nbsp;&nbsp;&nbsp;&nbsp;const float bias_half_range =<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::max(std::abs(*minmax.first), std::abs(*minmax.second));<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;// Need to adjust weight min/max; not compatible with bias.<br>+&nbsp;&nbsp;&nbsp;&nbsp;if (bias_half_range / kScale &gt;= 0.5 * input_scale * weight_scales[0]) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quant_params-&gt;min[0] =<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.0 * bias_half_range / kScale * (kMinQuantizedValue / input_scale);<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quant_params-&gt;max[0] =<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.0 * bias_half_range / kScale * (kMaxQuantizedValue / input_scale);<br>+&nbsp;&nbsp;&nbsp;&nbsp;}<br>+&nbsp;&nbsp;}<br>+&nbsp;&nbsp;return kTfLiteOk;<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">172</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">676bce388aba376a4e6f7307dc92fdc0a8b3af42</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Quantized mean and sum have a risk of overflow</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">cast input based on numeric limits</td>
                    <td class="tg-0lax">// Convert to float value.<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output_data[idx] =<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static_cast&lt;T&gt;(std::round(float_mean * scale + bias)) +<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output_zero_point;</td>
                    <td class="tg-0lax">float result =<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::min(std::round(float_mean * scale + bias) + output_zero_point,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static_cast&lt;float&gt;(std::numeric_limits&lt;T&gt;::max()));<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result =<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::max(result, static_cast&lt;float&gt;(std::numeric_limits&lt;T&gt;::min()));<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output_data[idx] = static_cast&lt;T&gt;(result);</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">173</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">e08474a981b87a8c4fdc9d9d08765727fe8d629e</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler, variable accessor</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">Change shared variables to high precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">174</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">c782a538b0b90d93c6070ac177cb1f542272bcce</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflowing of integer "+" and "-" operations</td>
                    <td class="tg-0lax">CNN operations</td>
                    <td class="tg-0lax">convolution</td>
                    <td class="tg-0lax">convolution transpose</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i = y * $kernel_size.x$ + x;<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ivec2 idx = gid.xy + ivec2(x, y) - $padding$;<br></td>
                    <td class="tg-0lax"> int i = int(float(y * $kernel_size.x$) + float(x));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ivec2 idx = ivec2(vec2(gid.xy + ivec2(x, y)) - vec2($padding$));</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">175</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">ea316ec1827bacae811858a7f681dfac47ef7f47</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">signed overflow</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler, dot interpreter</td>
                    <td class="tg-0lax">change variable type</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">change type to unsigned</td>
                    <td class="tg-0lax">-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static_cast&lt;ElementwiseT&gt;(lhs_literal.Get&lt;ReturnT&gt;(lhs_index)) *<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static_cast&lt;ElementwiseT&gt;(rhs_literal.Get&lt;ReturnT&gt;(rhs_index));<br></td>
                    <td class="tg-0lax"> ElementwiseT lhs_val(lhs_literal.Get&lt;ReturnT&gt;(lhs_index));<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ElementwiseT rhs_val(rhs_literal.Get&lt;ReturnT&gt;(rhs_index));<br>ToArithmeticSafeType(lhs_val) * ToArithmeticSafeType(rhs_val);</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">176</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">09b8ed34f47dbd6921304f2d4ceb3669c1e089e6</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">int32 overflow</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">flatten layer</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">increase precision of variable shape to int64 if neccessary, otherwise keep it as int32</td>
                    <td class="tg-0lax">input_shape = inputs.shape<br>+&nbsp;&nbsp;&nbsp;&nbsp;if input_shape[1:].is_fully_defined():<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flattened_dim = tensor_shape.dimension_value(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;np.prod(input_shape[1:], dtype=int))<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Temporary fix for integer overflow issue.<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if flattened_dim &gt; np.iinfo(np.int32).max:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shape_dtype = dtypes.int64<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shape_dtype = dtypes.int32<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outputs = array_ops.reshape(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputs, constant_op.constant((-1, flattened_dim), shape_dtype))<br></td>
                    <td class="tg-0lax">def testFlattenLargeDim(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;x = array_ops.placeholder(shape=(None, 21316, 21316, 80), dtype='float32')<br>+&nbsp;&nbsp;&nbsp;&nbsp;y = core_layers.Flatten()(x)<br>+&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(y.shape.as_list(), [None, 21316 * 21316 * 80])<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">177</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">dbcb2a5470e40974924cebd0f74d7f117b21bf8e</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler, bit cast operation</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">increase precision of an integer to int64</td>
                    <td class="tg-0lax">auto output_bit_width_mask = (1 &lt;&lt; output_bit_width) - 1;</td>
                    <td class="tg-0lax">auto output_bit_width_mask = (int64(1) &lt;&lt; output_bit_width) - 1;<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">178</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">0d6095963d907e0de1d635842d8ed80759a436ba</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">data processing</td>
                    <td class="tg-0lax">memory allocator</td>
                    <td class="tg-0lax">ruy allocator, size</td>
                    <td class="tg-0lax">change variable type</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">change from std::size_t to std::ptrdiff_t</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">179</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">5b4fe5470852d1aea737b194e03727cdedddebca</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">underflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">underflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">exponent smaller than -31 causes underflow</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">For exponents smaller than -31, set shift to zero</td>
                    <td class="tg-0lax">void GuardedQuantizeMultiplier(double effective_output_scale,<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32_t* significand, int* shift) {<br>-&nbsp;&nbsp;QuantizeMultiplier(effective_output_scale, significand, shift);<br>-&nbsp;&nbsp;// Additional guard to make sure RoundingDivideByPOT does not fail.<br>-&nbsp;&nbsp;if (*shift &lt; -31) {<br>-&nbsp;&nbsp;&nbsp;&nbsp;// If shift is less than -31, RoundingDivideByPOT fails. This happens when<br>-&nbsp;&nbsp;&nbsp;&nbsp;// min and max are close and small. For this particular case, both<br>-&nbsp;&nbsp;&nbsp;&nbsp;// significand and shift are set to zero.<br>-&nbsp;&nbsp;&nbsp;&nbsp;*significand = 0;<br>-&nbsp;&nbsp;&nbsp;&nbsp;*shift = 0;<br>-&nbsp;&nbsp;}<br>-}</td>
                    <td class="tg-0lax">void QuantizeMultiplier(double double_multiplier, int32_t* quantized_multiplier,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++*shift;<br>&nbsp;&nbsp;&nbsp;}<br><br>if (*shift &lt; -31) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;*shift = 0;<br>+&nbsp;&nbsp;&nbsp;&nbsp;q_fixed = 0;<br>+&nbsp;&nbsp;}<br><br>QuantizeMultiplier(effective_output_scale, &amp;significand, &amp;shift);</td>
                    <td class="tg-0lax">TEST(QuantizationUtilTest, QuantizeMultiplierUnderflow) {<br>+&nbsp;&nbsp;auto quantize = [](double d) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;int32_t q;<br>+&nbsp;&nbsp;&nbsp;&nbsp;int s;<br>+&nbsp;&nbsp;&nbsp;&nbsp;QuantizeMultiplier(d, &amp;q, &amp;s);<br>+&nbsp;&nbsp;&nbsp;&nbsp;return std::pair&lt;int32_t, int&gt;{q, s};<br>+&nbsp;&nbsp;};<br>+<br>+&nbsp;&nbsp;EXPECT_THAT(quantize(std::ldexp(1.0f, -31)), Pair(1073741824, -30));<br>+&nbsp;&nbsp;EXPECT_THAT(quantize(std::ldexp(1.0f, -32)), Pair(1073741824, -31));<br>+&nbsp;&nbsp;EXPECT_THAT(quantize(std::ldexp(0.99f, -32)), Pair(0, 0));<br>+&nbsp;&nbsp;EXPECT_THAT(quantize(std::ldexp(1.0f, -33)), Pair(0, 0));<br>+}<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">180</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">3af3959377d54414f480d617402274f7e9440316</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Using sqrt(a^2 + b^2)</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">absolute value of a complex number</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">use sqrt(a^2 + b^2) = sqrt(a^2 * (1 + b^2/a^2))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= |a| * sqrt(1 + (b/a)^2)<br>With the assumption that |a| &gt;= |b|<br></td>
                    <td class="tg-0lax">case HloOpcode::kAbs: {<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;auto sum_sq = FAdd(<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FMul(EmitExtractReal(operand_value), EmitExtractReal(operand_value)),<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FMul(EmitExtractImag(operand_value), EmitExtractImag(operand_value)));<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return llvm_ir::EmitCallToIntrinsic(llvm::Intrinsic::sqrt, {sum_sq},</td>
                    <td class="tg-0lax">StatusOr&lt;llvm::Value*&gt; ElementalIrEmitter::EmitComplexAbs(<br>+&nbsp;&nbsp;&nbsp;&nbsp;PrimitiveType prim_type, llvm::Value* operand_value) {<br>+&nbsp;&nbsp;auto real = EmitExtractReal(operand_value);<br>+&nbsp;&nbsp;auto imag = EmitExtractImag(operand_value);<br>+&nbsp;&nbsp;auto abs_real = llvm_ir::EmitCallToIntrinsic(llvm::Intrinsic::fabs, {real},<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{real-&gt;getType()}, b_);<br>+&nbsp;&nbsp;auto abs_imag = llvm_ir::EmitCallToIntrinsic(llvm::Intrinsic::fabs, {imag},<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{imag-&gt;getType()}, b_);<br>+&nbsp;&nbsp;auto max = EmitFloatMax(abs_real, abs_imag);<br>+&nbsp;&nbsp;auto min = EmitFloatMin(abs_real, abs_imag);<br>+<br>+&nbsp;&nbsp;auto div = FDiv(min, max);<br>+&nbsp;&nbsp;auto div_sq = FMul(div, div);<br>+&nbsp;&nbsp;auto one = llvm::ConstantFP::get(max-&gt;getType(), 1);<br>+&nbsp;&nbsp;TF_ASSIGN_OR_RETURN(auto sqrt, EmitSqrt(prim_type, FAdd(one, div_sq)));<br>+<br>+&nbsp;&nbsp;auto zero = llvm::ConstantFP::get(max-&gt;getType(), 0);<br>+&nbsp;&nbsp;return Select(FCmpOEQ(max, zero), zero, FMul(max, sqrt));<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">181</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">840f25bd4623e5a9aedcbe6163332f51ee303784</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">signed integer overflow in HandleCopies when batch_size * indices_size * slice_size is larger than int32</td>
                    <td class="tg-0lax">data processing</td>
                    <td class="tg-0lax">parallelism</td>
                    <td class="tg-0lax">kernels, gather</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">use int64 instead of int32 for large values</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool use_large =<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;batch_size * indices_size * slice_size &gt;<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::numeric_limits&lt;int32&gt;::max());<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">182</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">8211365f9e8aed8cec7b63d7eb992ab104422f8c</td>
                    <td class="tg-0lax">C++, Python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">build error on Windows caused by potential int32 overflow</td>
                    <td class="tg-0lax">data processing</td>
                    <td class="tg-0lax">data</td>
                    <td class="tg-0lax">shard size</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">increase precision from int32 to int64 to calculate the default shard size</td>
                    <td class="tg-0lax">self._shard_size_bytes = (<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shard_size_bytes<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if shard_size_bytes is not None else 10 * 1024 * 1024 * 1024)<br>self._pending_snapshot_expiry_seconds = (<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pending_snapshot_expiry_seconds<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if pending_snapshot_expiry_seconds is not None else 86400)<br></td>
                    <td class="tg-0lax">// Defaults to 10 GiB per shard.<br>+const int64 kDefaultShardSizeBytes = 10L * 1024 * 1024 * 1024;<br><br>&nbsp;&nbsp;&nbsp;if (shard_size_bytes_ == -1) shard_size_bytes_ = kDefaultShardSizeBytes;<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;// Default to 1 day expiry for snapshots.<br>+&nbsp;&nbsp;&nbsp;&nbsp;if (pending_snapshot_expiry_seconds_ == -1) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pending_snapshot_expiry_seconds_ = 86400;<br>+&nbsp;&nbsp;&nbsp;&nbsp;}<br><br> shard_size_bytes if shard_size_bytes is not None else -1)<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">183</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">8ac1075eac1ab9072e29c025348f749b43f251cf</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">optimizers</td>
                    <td class="tg-0lax">optimizers</td>
                    <td class="tg-0lax">experimental optimizer</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">add upper bound scaling to prevent overflow</td>
                    <td class="tg-0lax">element = T(UniformDistribution(RandomType(0), RandomType(1), &amp;gen));</td>
                    <td class="tg-0lax">auto upper_bound =<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RandomType(std::is_same&lt;T, Eigen::half&gt;::value ? 0.1 : 1.0);<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element = T(UniformDistribution(RandomType(0), upper_bound, &amp;gen));</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">184</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">737600454df83be02fac46e48b093a8892c7241a</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">unit test</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">linear algebra</td>
                    <td class="tg-0lax">linear algebra</td>
                    <td class="tg-0lax">matrix multiply</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">Avoid the corner case where both lhs and rhs zero_point's are the lowest representable value in their respective quantized type.&nbsp;&nbsp;E.g. when both LHS and RHS are uint8 with zero_point=0.</td>
                    <td class="tg-0lax">if (!use_golden &amp;&amp; !std::is_floating_point&lt;LhsScalar&gt;::value) {<br>-&nbsp;&nbsp;&nbsp;&nbsp;lhs_params.zero_point = random_engine() % 8;<br><br>if (!use_golden &amp;&amp; !std::is_floating_point&lt;RhsScalar&gt;::value) {<br>-&nbsp;&nbsp;&nbsp;&nbsp;rhs_params.zero_point = random_engine() % 8;</td>
                    <td class="tg-0lax">if (!std::is_floating_point&lt;LhsScalar&gt;::value) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;lhs_params.zero_point = 1;<br>+&nbsp;&nbsp;&nbsp;&nbsp;if (!use_golden) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lhs_params.zero_point += random_engine() % 8;<br>+&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>if (!std::is_floating_point&lt;RhsScalar&gt;::value) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;rhs_params.zero_point = 1;<br>+&nbsp;&nbsp;&nbsp;&nbsp;if (!use_golden) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rhs_params.zero_point += random_engine() % 8;<br>+&nbsp;&nbsp;&nbsp;&nbsp;}<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">185</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">c38b41d7c813e0dc26fa99cf6495ec474a595542</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">possible float-to-integer-cast overflow</td>
                    <td class="tg-0lax">precision tests/speed benchmarks</td>
                    <td class="tg-0lax">timing</td>
                    <td class="tg-0lax">timing</td>
                    <td class="tg-0lax">change variable type</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">cahnge variable for holding processing time from int64 to double</td>
                    <td class="tg-0lax">const int64 processing_time = TotalProcessingTime(snapshot);<br>const int64 output_time = OutputTime(snapshot);<br>int64 best_delta = -1;<br>int64 new_output_time = OutputTime(snapshot);<br>int64 delta = output_time - new_output_time;<br>int64 Model::OutputTime(std::shared_ptr&lt;Node&gt; node)</td>
                    <td class="tg-0lax">const double processing_time = TotalProcessingTime(snapshot);<br>const double output_time = OutputTime(snapshot);<br>double best_delta = -1.0L;<br>double new_output_time = OutputTime(snapshot);<br>double delta = output_time - new_output_time;<br>double Model::OutputTime(std::shared_ptr&lt;Node&gt; node) {<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">186</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">52a6cfddef9b51b608b4a554b77a10e1522d56ec</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow of variable size</td>
                    <td class="tg-0lax">data processing</td>
                    <td class="tg-0lax">parallelism</td>
                    <td class="tg-0lax">segmented reduction—a parallel reduction over many irregular-length segments.</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">change int to int64 for number of threads, block size, block numbers, compute cycles, compute bytes</td>
                    <td class="tg-0lax">const int num_threads = cpu_device.numThreads();<br>const int min_block_size = 64;<br>-&nbsp;&nbsp;&nbsp;&nbsp;const int max_block_num = std::min(N / min_block_size + 1, num_reductions);<br>-&nbsp;&nbsp;&nbsp;&nbsp;int block_num = std::min(max_block_num, num_threads);<br>-&nbsp;&nbsp;&nbsp;&nbsp;const int block_size = N / block_num;<br>const int compute_cycles = 5 * (N - num_reductions) * inner_dim;<br>-&nbsp;&nbsp;&nbsp;&nbsp;const int output_bytes = num_reductions * inner_dim * sizeof(T);</td>
                    <td class="tg-0lax">const int64 num_threads = cpu_device.numThreads();<br>const int64 min_block_size = 64;<br>+&nbsp;&nbsp;&nbsp;&nbsp;int64 block_num = std::min(num_reductions, num_threads);<br>+&nbsp;&nbsp;&nbsp;&nbsp;int64 block_size = (N - 1) / block_num + 1;<br>+&nbsp;&nbsp;&nbsp;&nbsp;if (block_size &lt; min_block_size) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;block_size = min_block_size;<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;block_num = (N - 1) / min_block_size + 1;<br>const int64 compute_cycles = 5 * (N - num_reductions) * inner_dim;<br>+&nbsp;&nbsp;&nbsp;&nbsp;const int64 output_bytes = num_reductions * inner_dim * sizeof(T);<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">187</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">aa4765a1417950cf2c29afd0172aebdd31b0725f</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">cast overflow undefined behavior</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">absolute value of a complex number</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">Change this function that outputs absolute value to return a double instead of a float to avoid cast overfloat for inputs with types double and complex128.<br></td>
                    <td class="tg-0lax">float FpAbsoluteValue(NativeT value)</td>
                    <td class="tg-0lax">double FpAbsoluteValue(NativeT value)</td>
                    <td class="tg-0lax">TEST(LiteralTestUtilTest, ExpectNearDoubleOutsideFloatValueRange) {<br>+&nbsp;&nbsp;auto two_times_float_max =<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LiteralUtil::CreateR0&lt;double&gt;(2.0 * std::numeric_limits&lt;float&gt;::max());<br>+&nbsp;&nbsp;ErrorSpec error(0.001);<br>+&nbsp;&nbsp;EXPECT_TRUE(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LiteralTestUtil::Near(two_times_float_max, two_times_float_max, error));<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">188</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">d0136d4affebd14fee59ba1865d5f1c8fa64251a</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax">TensorFlow BFC Allocator is a memory allocator that implements a 'best-fit with coalescing' algorithm.</td>
                    <td class="tg-0lax">index integer overflow</td>
                    <td class="tg-0lax">data processing</td>
                    <td class="tg-0lax">memory allocator</td>
                    <td class="tg-0lax">TensorFlow BFC Allocator</td>
                    <td class="tg-0lax">change variable type</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">change type of an index from int to size_t</td>
                    <td class="tg-0lax">int IndexFor(const void* p) const <br> return static_cast&lt;int&gt;(((p_int - base_int) &gt;&gt; kMinAllocationBits));<br></td>
                    <td class="tg-0lax">size_t IndexFor(const void* p) const <br>return static_cast&lt;size_t&gt;(((p_int - base_int) &gt;&gt; kMinAllocationBits));<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">189</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">f9ac078ebd0d05b64691e6718d404ee801f80c67</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">conversion to float32 results in overflow</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">number casting</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax">return error if overflow and return null pointer if infinity</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">double as_double = PyFloat_AsDouble(v);<br>+&nbsp;&nbsp;&nbsp;&nbsp;// Handle infinity.<br>+&nbsp;&nbsp;&nbsp;&nbsp;if (as_double == std::numeric_limits&lt;double&gt;::infinity()) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*out = std::numeric_limits&lt;T&gt;::infinity();<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nullptr;<br>+&nbsp;&nbsp;&nbsp;&nbsp;} else if (as_double == -1 * std::numeric_limits&lt;double&gt;::infinity()) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*out = -1 * std::numeric_limits&lt;T&gt;::infinity();<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nullptr;<br>+&nbsp;&nbsp;&nbsp;&nbsp;}<br>+&nbsp;&nbsp;&nbsp;&nbsp;// Check for overflow.<br>+&nbsp;&nbsp;&nbsp;&nbsp;if (as_double &gt; std::numeric_limits&lt;T&gt;::max() ||<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as_double &lt; std::numeric_limits&lt;T&gt;::lowest()) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ErrorOutOfRangeDouble;<br>+&nbsp;&nbsp;&nbsp;&nbsp;}<br>+&nbsp;&nbsp;&nbsp;&nbsp;*out = static_cast&lt;T&gt;(as_double);</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">190</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">c8e8f35f3e39b36d105eb7e43321a9da1362f242</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">integer overflow</td>
                    <td class="tg-0lax">precision tests/speed benchmarks</td>
                    <td class="tg-0lax">timing</td>
                    <td class="tg-0lax">timing</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">use unsigned long long int</td>
                    <td class="tg-0lax">event-&gt;set_timestamp_ps(node.all_start_micros() * 1000000);<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;event-&gt;set_duration_ps(node.all_end_rel_micros() * 1000000);<br></td>
                    <td class="tg-0lax">static constexpr uint64 kMicrosToPicos = 1000ULL * 1000ULL;<br>const uint64 profile_start_time_micros<br>&nbsp;&nbsp;&nbsp;&nbsp;event-&gt;set_timestamp_ps(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(node.all_start_micros() - profile_start_time_micros) *<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EnvTime::kMicrosToPicos);<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;event-&gt;set_duration_ps(node.all_end_rel_micros() *<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EnvTime::kMicrosToPicos);<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">191</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">f1d0c84f699624382c8d66e2ea10205ac0207868</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">disable test</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">precision tests/speed benchmarks</td>
                    <td class="tg-0lax">timing</td>
                    <td class="tg-0lax">timing</td>
                    <td class="tg-0lax">disable overflow test</td>
                    <td class="tg-0lax">disable test/warning</td>
                    <td class="tg-0lax">Skip overflow testing when running with address sanitizer.</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">192</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">84337310517914ca4b4d6eb35295a65758bc6d75</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">unit test</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">AveragePool uses a uint16 accumulator which causes it to overflow for<br>large images</td>
                    <td class="tg-0lax">CNN operations</td>
                    <td class="tg-0lax">pooling layer</td>
                    <td class="tg-0lax">average pooling</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax">add overflow test</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax">// Send in a white image, expect a white pixel.<br>+TEST(QuantizedPoolingOpTest, AveragePoolImageSize16) {<br>+&nbsp;&nbsp;int image_size = 16;<br>+&nbsp;&nbsp;QuantizedPoolingOpModel m(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BuiltinOperator_AVERAGE_POOL_2D,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*input=*/{TensorType_UINT8, {1, image_size, image_size, 1}, 0, 16},<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*filter_width=*/image_size,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*filter_height=*/image_size,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*output=*/{TensorType_UINT8, {}, 0, 16});<br>+<br>+&nbsp;&nbsp;std::vector&lt;float&gt; input(image_size * image_size, 16.f);<br>+&nbsp;&nbsp;m.SetInput(input);<br>+&nbsp;&nbsp;m.Invoke();<br>+<br>+&nbsp;&nbsp;EXPECT_THAT(m.GetOutput(), ::testing::ElementsAre(255));<br>+&nbsp;&nbsp;EXPECT_THAT(m.GetDequantizedOutput(), ElementsAreArray(ArrayFloatNear({16})));<br>+}<br>+<br>+// Send in a white image, expect something other than a white pixel, due to<br>+// overflow.<br>+TEST(QuantizedPoolingOpTest, AveragePoolImageSize17) {<br>+&nbsp;&nbsp;int image_size = 17;<br>+&nbsp;&nbsp;QuantizedPoolingOpModel m(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BuiltinOperator_AVERAGE_POOL_2D,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*input=*/{TensorType_UINT8, {1, image_size, image_size, 1}, 0, 16},<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*filter_width=*/image_size,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*filter_height=*/image_size,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*output=*/{TensorType_UINT8, {}, 0, 16});<br>+<br>+&nbsp;&nbsp;std::vector&lt;float&gt; input(image_size * image_size, 16.f);<br>+&nbsp;&nbsp;m.SetInput(input);<br>+&nbsp;&nbsp;m.Invoke();<br>+<br>+&nbsp;&nbsp;// Ordinarily we would see '255' here. However, the optimized version of<br>+&nbsp;&nbsp;// AveragePool uses a uint16 accumulator which causes it to overflow for<br>+&nbsp;&nbsp;// images this large.<br>+&nbsp;&nbsp;EXPECT_THAT(m.GetOutput(), ::testing::ElementsAre(28));</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">193</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">434dbe38970ffc90a5b546780be702e0b5de9a0c</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax">undefined behavior</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">undefined behavior caused by integer overflow in custom float comparison</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">casting</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">consider numeric limits</td>
                    <td class="tg-0lax">return std::numeric_limits&lt;CastType&gt;::max() - casted_value;</td>
                    <td class="tg-0lax"> return static_cast&lt;UnsignedCastType&gt;(std::numeric_limits&lt;CastType&gt;::max()) -<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;casted_value;</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">194</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">fc44600e5c3ccf1de1e3d4792a00d3578311d3f6</td>
                    <td class="tg-0lax">Cuda</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">index integer overflow</td>
                    <td class="tg-0lax">linear algebra</td>
                    <td class="tg-0lax">linear algebra</td>
                    <td class="tg-0lax">row reduce</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite formula</td>
                    <td class="tg-0lax">const int row = (blockIdx.x * blockDim.x + threadIdx.x) / 32;<br>std::size_t temp_storage_bytes = 0;<br> <br>-&nbsp;&nbsp;Tensor temp_storage;<br>-&nbsp;&nbsp;// written as a loop because it reduces clutter<br>-&nbsp;&nbsp;// first pass allocates memory, second launches kernel(s)<br>-&nbsp;&nbsp;for (int i = 0; i &lt; 2; ++i) {<br>-&nbsp;&nbsp;&nbsp;&nbsp;auto success = cub::DeviceReduce::Reduce(<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i == 0 ? nullptr : temp_storage.flat&lt;int8_t&gt;().data(),<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp_storage_bytes, in, out, in_size, op, init, cu_stream);<br></td>
                    <td class="tg-0lax">assert(blockDim.x % 32 == 0);<br>+&nbsp;&nbsp;int warps_per_block = blockDim.x / 32;<br>+&nbsp;&nbsp;int warp_index = threadIdx.x / 32;<br>+&nbsp;&nbsp;const int row = blockIdx.x * warps_per_block + warp_index;<br><br>size_t temp_storage_bytes = 0;<br>+&nbsp;&nbsp;auto reduce = [&amp;](void* temp_storage_ptr) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;auto success =<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cub::DeviceReduce::Reduce(temp_storage_ptr, temp_storage_bytes, in, out,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in_size, op, init, cu_stream);<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">195</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">e66aea59e0367618f924ffe3bc3b1140be8eaf45</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">underflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">underflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">underflow if data empty</td>
                    <td class="tg-0lax">data processing</td>
                    <td class="tg-0lax">data</td>
                    <td class="tg-0lax">tf.data / Cloud Bigtable</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">change order of operations</td>
                    <td class="tg-0lax">if (index_ &gt; keys_.size() - 2) {<br></td>
                    <td class="tg-0lax">if (index_ + 2 &gt; keys_.size()) {</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">196</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">880390941ce6430996c8f842540f73b53f3d1d8e</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">int32 overflow</td>
                    <td class="tg-0lax">data processing</td>
                    <td class="tg-0lax">parallelism</td>
                    <td class="tg-0lax">parallelism</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">use int64 number of segments to guard against int32 overflow</td>
                    <td class="tg-0lax">num_segments *= n</td>
                    <td class="tg-0lax">num_segments = math_ops.cast(num_segments, dtypes.int64) * math_ops.cast(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n, dtypes.int64)</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">197</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">f0d7172a30954b6696bdf2f40a5be11e7fdeb39c</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">int overflow</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler, shape inference</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax">return invalid argument if number of features is not positive</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"> if (feature_group_count &lt;= 0) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;return InvalidArgument(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"feature_group_count must be a positive number, got %d",<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;feature_group_count);<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">198</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">63bac283d12899a2d769a768729942c4f64436ea</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax">undefined behavior</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">undefined behavior due to signed integer overflow</td>
                    <td class="tg-0lax">data processing</td>
                    <td class="tg-0lax">image processing</td>
                    <td class="tg-0lax">bmp image decoding</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite formula</td>
                    <td class="tg-0lax">const int row_size = (8 * channels_ * width + 31) / 32 * 4;</td>
                    <td class="tg-0lax">const int row_size = (channels_ * width + 3) / 4 * 4;</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">199</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">4f7a169a7eb97ea4819217f14705d6c2bd125355</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Need to handle overflow in devision and remainder</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler, elemental emiter, division, remainder</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax">Define integer division overflow for CPU/GPU</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X / 0 == -1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X % 0 == X<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INT_SMIN / -1 = INT_SMIN<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INT_SMIN % -1 = 0<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">200</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">d7ebc1f4ca2c677710c5257d30c757f0f8b604c6</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow in flops calculations in nn_ops.py</td>
                    <td class="tg-0lax">CNN operations</td>
                    <td class="tg-0lax">CNN</td>
                    <td class="tg-0lax">flops calculation, product</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">use int64 for product calculation</td>
                    <td class="tg-0lax">output_count = np.prod(output_shape.as_list())<br></td>
                    <td class="tg-0lax">output_count = np.prod(output_shape.as_list(), dtype=np.int64)</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">201</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">e7674c09a151cac07bae43f6fe8551e8fec6dfe0</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">array index overflow in TransformFilter functor</td>
                    <td class="tg-0lax">CNN operations</td>
                    <td class="tg-0lax">convolution</td>
                    <td class="tg-0lax">indexing, 2D convolution</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">subtract 2 from number of dimentions to iterate over</td>
                    <td class="tg-0lax">for (int i = 0; i &lt; NDIMS; ++i) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// spatial dimensions</td>
                    <td class="tg-0lax">for (int i = 0; i &lt; NDIMS - 2; ++i) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// spatial dimensions</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">202</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">aec5a0191e21ce022f47d743a4954e13f710cd8f</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">very large and branchy models, where the number of paths is exponential to the number of nodes can overflow - specifically an overflow in hlo_scheduling, when compiling AutoML models</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler, HLO (high level operations)</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">set min and max for total number of HLOs</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax">int64 total_hlos = computation.parent()-&gt;NumUniqueInstructionIds();<br>extra_users[hlo] = std::min(extra_users[hlo], total_hlos);</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">203</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">503b7c11b44ee8b238946b345efea503058652c0</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">disable test</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax">SinhArcsinh: Y = g(X) = Sinh( (Arcsinh(X) + skewness) * tailweight ) * multiplier.</td>
                    <td class="tg-0lax">overflow test fails</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">transformations</td>
                    <td class="tg-0lax">square, Bijective transformations</td>
                    <td class="tg-0lax">disable overflow test</td>
                    <td class="tg-0lax">disable test/warning</td>
                    <td class="tg-0lax">Skipped the check that fails due to overflow error</td>
                    <td class="tg-0lax"># Do the numpy calculation in float128 to avoid inf/nan.<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y_float128 = np.float128(y)<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertAllClose(<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;np.log(np.cosh(<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;np.arcsinh(y_float128) / tailweight - skewness) / np.sqrt(<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y_float128**2 + 1)) -<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;np.log(tailweight),<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bijector.inverse_log_det_jacobian(y, event_ndims=0).eval(),<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rtol=1e-4,<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;atol=0.)</td>
                    <td class="tg-0lax">&nbsp;&nbsp;# On IBM PPC systems, longdouble (np.float128) is same as double except that it can have more precision.<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Type double being of 8 bytes, can't hold square of max of float64 (which is also 8 bytes) and<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# below test fails due to overflow error giving inf. So this check avoids that error by skipping square<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# calculation and corresponding assert.<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if np.amax(y) &lt;= np.sqrt(np.finfo(np.float128).max) and \<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;np.fabs(np.amin(y)) &lt;= np.sqrt(np.fabs(np.finfo(np.float128).min)):<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Do the numpy calculation in float128 to avoid inf/nan.<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y_float128 = np.float128(y)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertAllClose(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;np.log(np.cosh(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;np.arcsinh(y_float128) / tailweight - skewness) / np.sqrt(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y_float128**2 + 1)) -<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;np.log(tailweight),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bijector.inverse_log_det_jacobian(y, event_ndims=0).eval(),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rtol=1e-4,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;atol=0.)<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">204</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">f5dbc1e16622f433f41f195bb33f56d674a004ce</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax">TensorFlow Lite Converter converts TensorFlow graphs into TensorFlow Lite graphs</td>
                    <td class="tg-0lax">overflow in shape calculation<br>TensorFlow's shapes use int64s, while TOCO uses ints.</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor shape</td>
                    <td class="tg-0lax">shape, Tensorflow Lite Converter (TOCO)</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">205</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">9f312f32091534bfc115212d2ec7c838180df663</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow due to large values</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">random number generator</td>
                    <td class="tg-0lax">random tensor generation</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">Updating Generate Random Tensor to generate tensors whose values are small and do not cause overflow for arithmetic operations.</td>
                    <td class="tg-0lax">tensor.flat&lt;T&gt;() = tensor.flat&lt;T&gt;().random();</td>
                    <td class="tg-0lax">for (auto i = 0; i &lt; tensor.NumElements(); i++)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tensor.flat&lt;T&gt;()(i) = i + random::New64() % 10;</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">206</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">6a7779f3384e48012d3e27ae0f48d410f5174d06</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">undefined signed integer overflow</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">random uniform distribution</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">impose coditions on random number generation to prevent overflow</td>
                    <td class="tg-0lax">result[i] = lo_ + static_cast&lt;int32&gt;(sample[i] % range_);<br>result[i] = lo_ + static_cast&lt;int64&gt;(bits % range_);<br></td>
                    <td class="tg-0lax">template &lt;typename Int&gt;<br>+PHILOX_DEVICE_INLINE Int SignedAdd(Int a,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typename std::make_unsigned&lt;Int&gt;::type b) {<br>+&nbsp;&nbsp;auto b_div_2 = b &gt;&gt; 1;<br>+&nbsp;&nbsp;return a + static_cast&lt;Int&gt;(b_div_2) + static_cast&lt;Int&gt;(b - b_div_2);<br><br>result[i] = SignedAdd(lo_, sample[i] % range_);<br>result[i] = SignedAdd(lo_, bits % range_);</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">207</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">d107fee1e4a9a4462f01564798d345802acc2aef</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">I/O</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">consider numeric limits</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax">if (kBlockTrailerSize &gt; std::numeric_limits&lt;size_t&gt;::max() - n) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;return errors::DataLoss("handle.size() too big");<br>+&nbsp;&nbsp;}<br>+<br>N249</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">208</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">665a4bf664546224c65eeb5a0a52d80e48e2f3e1</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">int64 overflow and low accuracy</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler, HLO (high level operations), size</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax"> The new implementation computes the<br>&nbsp;&nbsp;&nbsp;&nbsp;min of the previous overestimate and the sum of all HLO's<br>&nbsp;&nbsp;&nbsp;&nbsp;before-and-including the current HLO in a topological sort of the<br>&nbsp;&nbsp;&nbsp;&nbsp;graph.</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">209</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">11f1e50886f91ce2caa6e53b0bc9a1e82abdda8e</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">unit test</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">exp() test overflowing</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">exponential</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">Keep the results below 2^31 in exp(), consider min and max</td>
                    <td class="tg-0lax">create_tensor_data(parameters["input_dtype"], parameters["input_shape"])</td>
                    <td class="tg-0lax">create_tensor_data(parameters["input_dtype"], parameters["input_shape"],<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min_value=-100, max_value=9)</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">210</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">49f73c55d56edffebde4bca4a407ad69c1cae433</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">integer overflow</td>
                    <td class="tg-0lax">data processing</td>
                    <td class="tg-0lax">image processing</td>
                    <td class="tg-0lax">bmp image decoding</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">Fix integer overflow in BMP decoder by making the checks in DecodeBmp<br>more stringent.&nbsp;&nbsp;Total possible pixel bytes must be less than 2^30. Also, increase orecision of image size from int to int64. Add fuzzer to improve the robustness of the decoder in the future.</td>
                    <td class="tg-0lax"> const int last_pixel_offset =<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header_size + (abs(height) - 1) * row_size + (width - 1) * channels_;<br>-&nbsp;&nbsp;&nbsp;&nbsp;const int expected_file_size = last_pixel_offset + channels_;<br></td>
                    <td class="tg-0lax">OP_REQUIRES(context, width &gt; 0 &amp;&amp; header_size &gt;= 0,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errors::InvalidArgument("Width must be positive"));<br>+&nbsp;&nbsp;&nbsp;&nbsp;OP_REQUIRES(context, header_size &gt;= 0,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errors::InvalidArgument("header size must be nonnegative"));<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;// The real requirement is &lt; 2^31 minus some headers and channel data,<br>+&nbsp;&nbsp;&nbsp;&nbsp;// so rounding down to something that's still ridiculously big.<br>+&nbsp;&nbsp;&nbsp;&nbsp;OP_REQUIRES(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(static_cast&lt;int64&gt;(width) * std::abs(static_cast&lt;int64&gt;(height))) &lt;<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static_cast&lt;int64&gt;(std::numeric_limits&lt;int32_t&gt;::max() / 8),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errors::InvalidArgument(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Total possible pixel bytes must be less than 2^30"));<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;const int32 abs_height = abs(height);<br><br>const int64 last_pixel_offset = static_cast&lt;int64&gt;(header_size) +<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(abs_height - 1) * row_size +<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(width - 1) * channels_;<br><br>const int64 expected_file_size = last_pixel_offset + channels_;</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">211</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">7f88363810e77a39db919fb4000583ad0138e53c</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">integer overflow</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">computational graph</td>
                    <td class="tg-0lax">shape size propagation in a tf graph</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">increase precision from int to int64 for max loops</td>
                    <td class="tg-0lax">const int num_loops = new_shapes-&gt;size();<br>-&nbsp;&nbsp;const int max_loop_length = item_.graph.node_size();<br>-&nbsp;&nbsp;const int max_rank = 4;<br>-&nbsp;&nbsp;const int max_loop_iterations =<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_rank * max_loop_length * std::max(1, num_loops * num_loops);<br>-&nbsp;&nbsp;const int num_queues = resources.size();<br>-&nbsp;&nbsp;const int max_resource_iterations = num_queues * num_queues * max_rank;<br>-<br>-&nbsp;&nbsp;int num_resource_iterations = 0;<br><br> int num_loop_iterations = 0;<br></td>
                    <td class="tg-0lax"> const int64 num_loops = new_shapes-&gt;size();<br>+&nbsp;&nbsp;const int64 max_loop_length = item_.graph.node_size();<br>+&nbsp;&nbsp;const int64 max_rank = 4;<br>+&nbsp;&nbsp;const int64 max_loop_iterations =<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_rank * max_loop_length * std::max&lt;int64&gt;(1, num_loops * num_loops);<br>+&nbsp;&nbsp;const int64 num_queues = resources.size();<br>+&nbsp;&nbsp;const int64 max_resource_iterations = num_queues * num_queues * max_rank;<br>+<br>+&nbsp;&nbsp;int64 num_resource_iterations = 0;<br>&nbsp;&nbsp;&nbsp;do {<br>+&nbsp;&nbsp;&nbsp;&nbsp;int64 num_loop_iterations = 0;<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">212</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">192f1c24ec6692342391c03bb620f5de1af9de3b</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">integer overflow</td>
                    <td class="tg-0lax">data processing</td>
                    <td class="tg-0lax">parallelism</td>
                    <td class="tg-0lax">parallelism</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite formula for calculating maximum number of elements</td>
                    <td class="tg-0lax">-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input_shape.num_elements() &gt;=<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::max(num_threads, num_split) * 4096 &amp;&amp;<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input_shape.num_elements() &lt; num_split * 180 * 1024);<br><br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num_split, kint64max, range_output_func);<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input_shape.num_elements() &gt;=<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::max(num_threads, num_split) * 4096 &amp;&amp;<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input_shape.num_elements() &lt; num_split * 180 * 1024);<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num_split, kint64max, range_output_func);</td>
                    <td class="tg-0lax">const auto input_element_count = input_shape.num_elements();<br>input_element_count &gt;= std::max(num_threads, num_split) * 4096 &amp;&amp;<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input_element_count &lt; num_split * 180 * 1024);<br>num_split, input_element_count / num_split, range_output_func);<br>input_element_count &gt;= std::max(num_threads, num_split) * 4096 &amp;&amp;<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input_element_count &lt; num_split * 180 * 1024);<br>num_split, input_element_count / num_split, range_output_func);</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">213</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">b1c095a28a7aa9bbee4af4d9a7e9d0c60567765b</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">underflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">underflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">underflow in log probability</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">multinomial distribution, log probabilty</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use log softmax and logits instead of log and probabilities</td>
                    <td class="tg-0lax">return math_ops.reduce_sum(counts * math_ops.log(self.probs), -1)<br></td>
                    <td class="tg-0lax">return math_ops.reduce_sum(counts * nn_ops.log_softmax(self.logits), -1)</td>
                    <td class="tg-0lax">def testPmfUnderflow(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;logits = np.array([[-200, 0]], dtype=np.float32)<br>+&nbsp;&nbsp;&nbsp;&nbsp;with self.test_session():<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dist = multinomial.Multinomial(total_count=1., logits=logits)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lp = dist.log_prob([1., 0.]).eval()[0]<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertAllClose(-200, lp, atol=0, rtol=1e-6)<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">214</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">74137f994faad09593ae2daad6251a4ccf72f558</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">When a node name has a long numeric suffix, e.g.,<br>&nbsp;&nbsp;&nbsp;&nbsp;"foo/y_0/gradient_debug_09684b60f2184c67b744721915034528" (as has happened with tfdbg GradientsDebugger),<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;the parsing algorithm in ParseTensorName() may experience signed int overflow.</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">tensor name parser</td>
                    <td class="tg-0lax">change variable type</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">use unsigned int instead of signed int</td>
                    <td class="tg-0lax">-&nbsp;&nbsp;int index = 0;<br>-&nbsp;&nbsp;int mul = 1;</td>
                    <td class="tg-0lax"> unsigned int index = 0;<br>+&nbsp;&nbsp;unsigned int mul = 1;</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">215</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">793fa4e91d3cae77565f753c2b8d769e1a3928f8</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax">vimco package proves a Bayesian variable selection method for GWAS data with multiple traits. Unlike in BVSR where each trait is analyzed seperately, vimco performs a joint analysis for the multiple traits, while accounting for correlation among the multiple traits. Csiszar f-Divergence generalized VIMCO objective</td>
                    <td class="tg-0lax">overflow issue in Csiszar-VIMCO</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">probability</td>
                    <td class="tg-0lax">gradient estimator, csiszar divergence</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite formula for log sum - subtract maximum from input</td>
                    <td class="tg-0lax">log_sum_u = math_ops.reduce_logsumexp(logu, axis=0)<br>return log_sum_u - log_n, log_soosum_u - log_n<br></td>
                    <td class="tg-0lax">log_max_u = math_ops.reduce_max(logu, axis=0)<br>+&nbsp;&nbsp;&nbsp;&nbsp;log_sum_u_minus_log_max_u = math_ops.reduce_logsumexp(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logu - log_max_u, axis=0)<br><br><br>is_positive_and_largest = math_ops.logical_and(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logu &gt; 0.,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;math_ops.equal(logu, log_max_u[array_ops.newaxis, ...]))<br>+&nbsp;&nbsp;&nbsp;&nbsp;log_lomsum_u = math_ops.reduce_logsumexp(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array_ops.where(is_positive_and_largest,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array_ops.fill(array_ops.shape(logu), -inf),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logu),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;axis=0, keep_dims=True)<br>+&nbsp;&nbsp;&nbsp;&nbsp;log_lomsum_u = array_ops.tile(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log_lomsum_u,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;multiples=1 + array_ops.pad([n-1], [[0, array_ops.rank(logu)-1]]))<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;d_not_ok_result = array_ops.where(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_positive_and_largest,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log_lomsum_u,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array_ops.fill(array_ops.shape(d), -inf))<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;log_loosum_u = array_ops.where(d_ok, d_ok_result, d_not_ok_result)<br><br>&nbsp;&nbsp;<br>log_avg_u = log_sum_u_minus_log_max_u + log_max_u - log_n<br>+&nbsp;&nbsp;&nbsp;&nbsp;log_sooavg_u = log_soosum_u - log_n<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;log_avg_u.set_shape(logu.shape.with_rank_at_least(1)[1:])<br>+&nbsp;&nbsp;&nbsp;&nbsp;log_sooavg_u.set_shape(logu.shape)<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;return log_avg_u, log_sooavg_u<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">216</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">d906c963269dd1522c7693c8f944e6a846b86221</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">unit test</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">signed integer overflows detected with -fsanitize=signed-integer-overflow</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler</td>
                    <td class="tg-0lax">compiler, shape inference</td>
                    <td class="tg-0lax">change variable type, add overflow check</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">use unsigned int instead of signed int to prevent undefined behavior and report error if overflow</td>
                    <td class="tg-0lax">const int64 b = a + 1;<br>const int64 sum = first_value + second_value;<br>-&nbsp;&nbsp;int64 result = 0;<br>[](int i) { return static_cast&lt;float&gt;(i * i * i); });<br></td>
                    <td class="tg-0lax"> const int64 b = a - 1;<br>const int64 sum = static_cast&lt;uint64&gt;(first_value) + second_value;<br><br>uint64 result = 0;<br>[](int i) { return static_cast&lt;float&gt;(i) * i * i; });</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">217</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">931fd84bb72df0500f512d5d92ec0bef2ea461be</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">numpy.prod overflow on windows</td>
                    <td class="tg-0lax">gradients/derivatives</td>
                    <td class="tg-0lax">gradients</td>
                    <td class="tg-0lax">shape, gradient, tensor</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">perform computations in int64 instead of int32 and then convert result to int32</td>
                    <td class="tg-0lax">shape_size = np.prod(shape)<br>num_elements = np.prod(shape)<br>params_shape = array_ops.shape(params)</td>
                    <td class="tg-0lax">shape_size = np.prod(shape, dtype=np.int64)<br>num_elements = np.prod(shape, dtype=np.int64)<br>params_shape = array_ops.shape(params, out_type=ops.dtypes.int64)<br>params_shape = math_ops.to_int32(params_shape)</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">218</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">e8ee5286a686c6fc3057ba7cf9ba9ef7003789a6</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">data processing</td>
                    <td class="tg-0lax">data</td>
                    <td class="tg-0lax">tensor shape, multipy, size</td>
                    <td class="tg-0lax">limit input range, add overflow check</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">Remove 2**40 size limit on TensorShape, use std::numerica_limits instead. the previous TensorShape code did not check for overflow when multiplying</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">219</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">3c9ba5673cf560ded0739530b673ab0a05d43630</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">unit test</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">integer overflow, undefined behavior, square</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">random number generator</td>
                    <td class="tg-0lax">pseudo-random number generator</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">cast from int32 to int64</td>
                    <td class="tg-0lax">sum += Square(counts[i] - expected_count);</td>
                    <td class="tg-0lax">sum += Square(static_cast&lt;int64&gt;(counts[i] - expected_count));</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">220</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">60e7360dfcf8951c4a269cfddd2a9cf2a05d7f91</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow, underflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow, underflow</td>
                    <td class="tg-0lax">Adjust the brightness of RGB or Grayscale images.</td>
                    <td class="tg-0lax">The current implementation (i.e. without clipping before conversion) introduces different behavior for images with different original data types, i.e. uint8 or float32.</td>
                    <td class="tg-0lax">data processing</td>
                    <td class="tg-0lax">image processing</td>
                    <td class="tg-0lax">images, adjust brightness</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">clip image into [0.0, 1.0] before converting back to original data type in 'adjust_brightness'</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax">adjusted = clip_ops.clip_by_value(adjusted, 0.0, 1.0)</td>
                    <td class="tg-0lax">def testNegativeDeltaFloat(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;x_shape = [2, 2, 3]<br>+&nbsp;&nbsp;&nbsp;&nbsp;x_data = [0, 5, 13, 10, 135, 226, 37, 8, 245, 90, 255, 1]<br>+&nbsp;&nbsp;&nbsp;&nbsp;x_np = np.array(x_data, dtype=np.float32).reshape(x_shape) / 255.<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;y_data = [0, 0, 3, 0, 125, 216, 27, 0, 235, 80, 245, 0]<br>+&nbsp;&nbsp;&nbsp;&nbsp;y_np = np.array(y_data, dtype=np.float32).reshape(x_shape) / 255.<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;self._testBrightness(x_np, y_np, delta=-10. / 255.)</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">221</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">ec58d4042790e71172964383f737b249289d15af</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">underflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">underflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">gumbel distribution</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">set min value with np.finfo(np_dtype).tiny</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">222</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">096ab75275862f973b2fd1a369a9fd25952a6c37</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">text files larger than 2B words overflows</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">NLP</td>
                    <td class="tg-0lax">word to vec embedding, size</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">increase precision of corpus size from int32 to int64</td>
                    <td class="tg-0lax">int32 corpus_size_ = 0;</td>
                    <td class="tg-0lax">int64 corpus_size_ = 0;</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">223</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">e6e06b2fc89d41556d159d1181a558f8f5352b87</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">strings</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite formula for checking overflow</td>
                    <td class="tg-0lax">if (new_v &lt; v) {</td>
                    <td class="tg-0lax">if (new_v / 8 &lt; v) {</td>
                    <td class="tg-0lax"> // (2^64-1)*10+9<br>+&nbsp;&nbsp;TestConsumeLeadingDigits("184467440737095516159yz", -1,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"184467440737095516159yz");<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">224</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">4ad8912996a25136a280312de3801f30dd4d4a74</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">unit test</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow in float-int32 cast</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">const int values_count = sizeof(T) == 256 ? 256 : 50000;<br> if (sizeof(T) == 256) {<br>input_array(i) = Eigen::NumTraits&lt;T&gt;::lowest() +<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static_cast&lt;int32&gt;(q_range / values_count * i);</td>
                    <td class="tg-0lax">const int values_count = sizeof(T) == 1 ? 256 : 50000;<br>if (sizeof(T) == 1) {<br>int64 offset = static_cast&lt;int64&gt;(q_range / values_count * i);<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input_array(i) = static_cast&lt;int32&gt;(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Eigen::NumTraits&lt;T&gt;::lowest() +<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::min&lt;int64&gt;(Eigen::NumTraits&lt;T&gt;::highest(), offset));<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">225</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">f4264cb8e1ea70c612170ed72b9fe0382d1967a0</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow when using float in eigen to quantize to QInt32</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">limit input range</td>
                    <td class="tg-0lax">use bounds that can be converted back to int32 without going outside the range of an int32.</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">static float upper_bound_float() {<br>+&nbsp;&nbsp;&nbsp;&nbsp;return Eigen::numext::mini(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static_cast&lt;float&gt;(Eigen::NumTraits&lt;T&gt;::highest()), +2.147483520e+09f);<br><br>static float lower_bound_float() {<br>+&nbsp;&nbsp;&nbsp;&nbsp;return Eigen::numext::maxi(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static_cast&lt;float&gt;(Eigen::NumTraits&lt;T&gt;::lowest()), -2.147483648e+09f);<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">226</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">6047c6977dbc30f018b8b3ea0486ca907901dabb</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">data processing</td>
                    <td class="tg-0lax">data</td>
                    <td class="tg-0lax">png I/O</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">Force height*row_bytes computations to use 64 bits.</td>
                    <td class="tg-0lax">N/A</td>
                    <td class="tg-0lax">int64 height = static_cast&lt;int64&gt;(height_in);</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">227</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">f4686d27a705bd547b828693462714d31bfd21ce</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">static_cast overflow in WorkSharder Shard</td>
                    <td class="tg-0lax">data processing</td>
                    <td class="tg-0lax">data</td>
                    <td class="tg-0lax">shard, dataset</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">cast intermediate variable to higher precision</td>
                    <td class="tg-0lax">const int num_shards = std::max(<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1, std::min&lt;int&gt;(num_workers, total * cost_per_unit / kMinCostPerShard));<br></td>
                    <td class="tg-0lax">const int num_shards =<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::max&lt;int&gt;(1, std::min(static_cast&lt;int64&gt;(num_workers),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total * cost_per_unit / kMinCostPerShard));</td>
                    <td class="tg-0lax">TEST(Shard, OverflowTest) {<br>+&nbsp;&nbsp;thread::ThreadPool threads(Env::Default(), "test", 3);<br>+&nbsp;&nbsp;mutex mu;<br>+&nbsp;&nbsp;for (auto workers : {1, 2, 3}) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;const int64 total_elements = 1LL &lt;&lt; 32;<br>+&nbsp;&nbsp;&nbsp;&nbsp;const int64 cost_per_unit = 10000;<br>+&nbsp;&nbsp;&nbsp;&nbsp;int num_shards = 0;<br>+&nbsp;&nbsp;&nbsp;&nbsp;int64 num_elements = 0;<br>+&nbsp;&nbsp;&nbsp;&nbsp;Shard(workers, &amp;threads, total_elements, cost_per_unit,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&amp;mu, &amp;num_shards, &amp;num_elements](int64 start, int64 limit) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutex_lock l(mu);<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++num_shards;<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num_elements += limit - start;<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br>+&nbsp;&nbsp;&nbsp;&nbsp;EXPECT_EQ(num_shards, workers);<br>+&nbsp;&nbsp;&nbsp;&nbsp;EXPECT_EQ(num_elements, total_elements);<br>+&nbsp;&nbsp;}<br>+}<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">228</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">e6000a7c045cbece5fbfd7d933c39e40b1625037</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Disable test</td>
                    <td class="tg-0lax">loss of precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Quantize = convert from float 32 ro int 8, dequantize = convert from int 8 to float 32<br><br>During training, all calculations are done in floating point, with fake_quant modules modeling the effects of quantization by clamping and rounding to simulate the effects of INT8. After model conversion, weights and activations are quantized, and activations are fused into the preceding layer where possible. It is commonly used with CNNs and yields a higher accuracy compared to static quantization. Quantization Aware Training is also known as QAT.</td>
                    <td class="tg-0lax">test_numerical_consistency_per_tensor in test_fake_quant is failing on Windows. The test is comparing numerical consistency between CPU quantize/dequantize op and the CPU fake quantize op.</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">testing, quantization</td>
                    <td class="tg-0lax">disable precision test</td>
                    <td class="tg-0lax">disable test/warning</td>
                    <td class="tg-0lax">Temporarily disables a test for comparing numerical consistency between CPU quantize/dequantize op and the CPU fake quantize op</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">229</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">02d318461e5c7bded304c42ed7075de84f71dac6</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Disable test</td>
                    <td class="tg-0lax">loss of precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Quantized operations require FBGEMM. FBGEMM (Facebook GEneral Matrix Multiplication) is a low-precision, high-performance matrix-matrix multiplications and convolution library for server-side inference. FBGEMM is only optimized for CPUs with instruction set support avx2 or newer. In Pytorch, quantization currently supports two backends: fbgemm (for use on x86,) and qnnpack (for use on the ARM)<br></td>
                    <td class="tg-0lax">Failing test</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">testing, quantization</td>
                    <td class="tg-0lax">disable precision test</td>
                    <td class="tg-0lax">disable test/warning</td>
                    <td class="tg-0lax">Temporarily disable test_numerical_consistency_per_channel due to failure</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">230</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">b7038f7c37e955f7400459bbfc9382a77b16377d</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Change exception to a warning</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax">exception</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">This test script compares if two values are “close enough” and handles +inf, -inf, nan</td>
                    <td class="tg-0lax">numerical differences raise exception</td>
                    <td class="tg-0lax">precision tests/speed benchmarks</td>
                    <td class="tg-0lax">accuracy testing</td>
                    <td class="tg-0lax">tensor compare, testing accuracy, JIT</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">relax accuracy test tolerance</td>
                    <td class="tg-0lax">changes errors to warnings when numerical differences found by replacing self.assertRaisesRegex with assertWarnsRegex</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">231</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">032e4f81a8df14fe8b7177957f73567fa04919e8</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Unit test</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Test for overflow does not verify that all listed conditions throw, just the first one</td>
                    <td class="tg-0lax">precision tests/speed benchmarks</td>
                    <td class="tg-0lax">overflow test</td>
                    <td class="tg-0lax">testing</td>
                    <td class="tg-0lax">fix overflow check</td>
                    <td class="tg-0lax">fix test/warning</td>
                    <td class="tg-0lax">Update test to check that the correct exceptions are raised when attempting to convert and invalid value to a certain type. Refactor code: add 'with' and 'assert' for every condition.</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">232</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">86abc8cd481bfa2b9bb741722770796966778ab1</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Change exception to a warning</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">PyTorch has a JIT compiler and a method to allow for inserting instructions as the compiler is compiling on the go. In this case an overflow check is inserted.</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax">C++ interpreter</td>
                    <td class="tg-0lax">change variable type, change exception to a warning</td>
                    <td class="tg-0lax">fix test/warning</td>
                    <td class="tg-0lax">Change an exception to instead just raise a non fatal warning, also, this changes a cast to use unsigned variants of 16 and 64 bit integers, which both allows double the amount of positive values these types can represent, as well as giving them well defined overflow behavior, which avoids undefined behavior in the event that they do overflow, and will simply wrap arround.</td>
                    <td class="tg-0lax">throw std::runtime_error("safe_narrow_cast&lt;&gt;() failed due to overflow");<br>safe_narrow_cast&lt;int16_t, int64_t&gt;(N));</td>
                    <td class="tg-0lax">TORCH_WARN(<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"ATTENTION: your model computation is overflowing, safe_narrow_cast&lt;&gt;() failed");<br>+&nbsp;&nbsp;&nbsp;&nbsp;return v;<br><br>safe_narrow_cast&lt;uint16_t, uint64_t&gt;(N));</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">233</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">2171f910531be28f7d5dd8e6ab8bff3a5486e6fd</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Unit test</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">ROCm is the first open-source software development platform for HPC/Hyperscale-class GPU computing</td>
                    <td class="tg-0lax">The test was previously turned off because of broken continuous integration on ROCm</td>
                    <td class="tg-0lax">precision tests/speed benchmarks</td>
                    <td class="tg-0lax">overflow test</td>
                    <td class="tg-0lax">testing overflow, Cuda</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax">add overflow check</td>
                    <td class="tg-0lax">reenable cuda_kernel_loop_overflow_large test</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">def test_cuda_kernel_loop_overflow_large(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Make sure input.numel() &gt; INT_MAX is handled:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = torch.randn(1, 1, 1, 2**31, dtype=torch.float16, device="cuda")</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">234</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">916eee182c9dc8d335501f6672842c6d29f0af58</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Unit test</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">A test that checks input shape of 2D convolution prints overflowed integers.<br>Bug in error message:<br>RuntimeError: Expected 4-dimensional input for 4-dimensional weight 6 1 5 5 2323362894317625376, but got 5-dimensional input of size [1, 10, 1, 28, 28] instead<br>Correct error message: <br>RuntimeError: Expected 4-dimensional input for 4-dimensional weight 6 1 5 5, but got 5-dimensional input of size [1, 10, 1, 28, 28] instead<br></td>
                    <td class="tg-0lax">CNN operations</td>
                    <td class="tg-0lax">convolution</td>
                    <td class="tg-0lax">2D convolution</td>
                    <td class="tg-0lax">correct error message</td>
                    <td class="tg-0lax">fix test/warning</td>
                    <td class="tg-0lax">add unit test to test shape mismatch for 2d convolutions</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">def test_mismatch_shape_conv2d(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = torch.randn(1, 10, 1, 28, 28)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w = torch.randn(6, 1, 5, 5)<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with self.assertRaisesRegex(RuntimeError,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r'Expected 4-dimensional input for 4-dimensional weight 6 1 5 5,' +<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r' but got 5-dimensional input of size \[1, 10, 1, 28, 28\] instead'):<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F.conv2d(x, w)<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">235</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">3805be62c1bb10b8bf4e645aac30d89efd8f79ab</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Unit test</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">quantization test fails due to overflow when width parameter is specified</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization, testing</td>
                    <td class="tg-0lax">increase variable precision</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">skip test and get rid of width parameter. Note: no longer in pytorch</td>
                    <td class="tg-0lax"> @given(A=hu.tensor(shapes=((3, 4, 5),),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qparams=hu.qparams()),<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b=st.floats(allow_infinity=False, allow_nan=False, width=32))<br><br></td>
                    <td class="tg-0lax">@unittest.skip("FIXME: Failing due to overflow error without width option")<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@given(A=hu.tensor(shapes=((3, 4, 5),),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qparams=hu.qparams()),<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b=st.floats(allow_infinity=False, allow_nan=False))<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">236</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">1ed488da4f88ec7b85ba5f6a4113908dda3681e3</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Unit test</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">non-standard precision</td>
                    <td class="tg-0lax">non-standard precision</td>
                    <td class="tg-0lax">custom precision testing</td>
                    <td class="tg-0lax">fix precision test</td>
                    <td class="tg-0lax">fix test/warning</td>
                    <td class="tg-0lax">fix precision test for inplace mode<br></td>
                    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for inplace in (True, False):<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if len(decl) == 3:<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name, constr, arg_constr = decl<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;desc = ''<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif len(decl) == 4:<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name, constr, arg_constr, desc = decl<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if inplace:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name = name + '_'<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not hasattr(tensor, name):<br>@@ -335,8 +337,6 @@ for decl in tests:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if desc:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_name += '_' + desc<br> <br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;precision = custom_precision.get(name, TestCuda.precision)</td>
                    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for t in types:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tensor = t()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpu_tensor = get_gpu_type(t)()<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if len(decl) == 3:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name, constr, arg_constr = decl<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;desc = ''<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif len(decl) == 4:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name, constr, arg_constr, desc = decl<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;precision = custom_precision.get(name, TestCuda.precision)<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">237</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">37af1b8790d633b9002ab04a0e664ca3c1dbe508</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">data processing</td>
                    <td class="tg-0lax">batch normalization</td>
                    <td class="tg-0lax">batch normalization</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">Do not use moving average in batch normalization since the method moments that calculate the mean of input that is utilized already implements this ogic in a numerically stable way</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">238</td>
                    <td class="tg-0lax">Tensorflow/Keras</td>
                    <td class="tg-0lax">f93960d0afdcf59457b614158ee5575ca2acfe15</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">incorrect comment about numerical stability</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">Beta distribution</td>
                    <td class="tg-0lax">delete incorrect comment</td>
                    <td class="tg-0lax">fix test/warning</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">239</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">8c8918c3412aa1a7a50df02cddfd66be948d2ace</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">non-standard precision</td>
                    <td class="tg-0lax">non-standard precision</td>
                    <td class="tg-0lax">half precision, overflow testing</td>
                    <td class="tg-0lax">fix overflow check</td>
                    <td class="tg-0lax">fix test/warning</td>
                    <td class="tg-0lax">make half precision overflow checks consistent with other types</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"> template&lt;&gt; bool overflows&lt;Half, double&gt;(double f) {<br>+&nbsp;&nbsp;using limit = std::numeric_limits&lt;double&gt;;<br>+&nbsp;&nbsp;if (limit::has_infinity &amp;&amp; std::isinf(f)) {<br>+&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>+&nbsp;&nbsp;}</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">240</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">79c3ebc040c4bac896477030d8af4ac94bc6f440</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Unit test</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Unit test was not aware of the precision of inputs</td>
                    <td class="tg-0lax">activation functions</td>
                    <td class="tg-0lax">activation functions</td>
                    <td class="tg-0lax">testing</td>
                    <td class="tg-0lax">fix overflow check</td>
                    <td class="tg-0lax">fix test/warning</td>
                    <td class="tg-0lax">Add argument to make assertion aware of precision of inputs.</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">241</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">2b902e9738f5346050814b40db3ec67faf37128a</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">fix</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">An offset within an array or other data structure object is an integer indicating the distance (displacement) between the beginning of the object and a given element or point, presumably within the same object. The concept of a distance is valid only if all elements of the object are of the same size (typically given in bytes or words).<br><br>For example, in A as an array of characters containing "abcdef", the fourth element containing the character 'd' has an offset of three from the start of A.<br><br>In assembly language an offset usually denotes the number of address locations added to a base address in order to get to a specific absolute address.</td>
                    <td class="tg-0lax">offset numerical bug when casting</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization</td>
                    <td class="tg-0lax">quantization, caffe2, type conversion</td>
                    <td class="tg-0lax">change variable type</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">change all_offsets variable type from float to int32_t</td>
                    <td class="tg-0lax">std::vector&lt;std::vector&lt;float&gt;&gt;* all_offsets)</td>
                    <td class="tg-0lax">std::vector&lt;std::vector&lt;int32_t&gt;&gt;* all_offsets)</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">242</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">5292685d2f144d9781ab8b7991c0a1153098a477</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">loss of precision</td>
                    <td class="tg-0lax">-inf, NaN</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Logarithms of determinants of large positive definite matrices appear ubiquitously in ML. Log-determinant computation involves the Cholesky decomposition</td>
                    <td class="tg-0lax">loss of precision when diagonal matrix contains small values. log determinant of a square matrix causes -inf when the matrix entries are very small numbers. Result is -inf if input has zero log determinant. If input has negative determinant, the result is NaN</td>
                    <td class="tg-0lax">linear algebra</td>
                    <td class="tg-0lax">linear algebra</td>
                    <td class="tg-0lax">linear algebra, log of matrix determinant</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">Use sign of diagonal of U instead of the matrix determinant when diag_U has a lot small values.<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">determinant of a matrix, log of a matrix</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">243</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">67f2039f4ce233754910ebc24fbfcc8bc68685ae</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">step size unreasonably small</td>
                    <td class="tg-0lax">slow execution</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">The binomial distribution is used when there are exactly two mutually exclusive outcomes of a trial, e.g., a coin toss has only two outcomes: heads and tails. A single binary outcome has a Bernoulli distribution, and a sequence of binary outcomes has a Binomial distribution.. The binomial distribution gives the discrete probability distribution P_p(n|N) of obtaining exactly n successes out of N Bernoulli trials (where the result of each Bernoulli trial is true with probability p and false with probability q=1-p).</td>
                    <td class="tg-0lax">Log probability in binomial distribution has numerical stability issues. issue manifests itself when `total_count` is high and `probs` is very low</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">distributions, log probability, binomial distribution</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">log probability method in binomial distribution is unstable</td>
                    <td class="tg-0lax">max_val = (-self.logits).clamp(min=0.0)<br>value * self.logits + self.total_count * max_val -<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.total_count * torch.log1p((self.logits + 2 * max_val).exp()))</td>
                    <td class="tg-0lax">value * self.logits - self.total_count * torch.log1p(self.logits.exp()))</td>
                    <td class="tg-0lax">@unittest.skipIf(not TEST_NUMPY, "NumPy not found")<br>&nbsp;&nbsp;&nbsp;&nbsp;def test_binomial_log_prob_float(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;probs = torch.tensor([1e-5, 0.99999], dtype=torch.float)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total_count = 1000000.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = torch.tensor([10, 9999], dtype=torch.float)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expected = scipy.stats.binom(total_count, probs.numpy()).logpmf(x.numpy())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log_prob = Binomial(total_count, probs).log_prob(x)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Comparison is again scipy distributions which use float64.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertTrue(np.allclose(log_prob, expected, rtol=0.05))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logits = probs_to_logits(probs, is_binary=True)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log_prob = Binomial(total_count, logits=logits).log_prob(x)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertTrue(np.allclose(log_prob, expected, rtol=0.05))</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">244</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">a17c0118a52d34c97ab48bae416ae1896ad14e56</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax">NaN loss</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax">Binary Cross Entropy (BCE) is a loss function used for binary classification taks to measure the difference between true labels and predicted labels. BCE with logits takes logits, not predicted labels as input, but serves the same purpose.</td>
                    <td class="tg-0lax">Binary cross entropy with logits is unstable with positive weights argument when logits are large negative values and results in an inf. Positive weight is a weight of positive examples and must be a vector with length equal to the number of classes.</td>
                    <td class="tg-0lax">loss functions</td>
                    <td class="tg-0lax">loss functions</td>
                    <td class="tg-0lax">binary cross entropy loss</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">instead of multipling by 1 + exp(-input), add exp(-input-max_val)</td>
                    <td class="tg-0lax">loss = (1 - target).mul_(input).add_(log_weight.mul_((-max_val).exp_().mul_(1 + (-input).exp_()).log_().add_(max_val)));</td>
                    <td class="tg-0lax">loss = (1 - target).mul_(input).add_(log_weight.mul_(((-max_val).exp_().add_((-input - max_val).exp_())).log_().add_(max_val)));<br></td>
                    <td class="tg-0lax">def test_bce_with_logits_stability(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output = torch.tensor([0., -120.])<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target = torch.tensor([0., 1.])<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pos_weight = torch.tensor([1., 1.])<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out1 = nn.BCEWithLogitsLoss()(output, target)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertTrue(torch.isfinite(out1).all().item())<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out2 = nn.BCEWithLogitsLoss(pos_weight=pos_weight)(output, target)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertTrue(torch.isfinite(out2).all().item())<br></td>
                    <td class="tg-0lax">H_p(q) = -1/N * sum_from_i_to_N(y_i * log(p(y_i)) + (1-y_i) * log (1-p(y_i))</td>
                    <td class="tg-0lax">log, multiply</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">245</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">00d2befba11a1e9c85146a4470721eb75596d5b7</td>
                    <td class="tg-0lax">Cuda</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">numerical stability</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">TH = TorcH<br>This is in directory aten/src, which contains the low-level tensor libraries for PyTorch, as well as the new ATen C++ bindings. The low-level libraries trace their lineage from the original Torch. There are multiple variants of the library, summarized here:<br><br>TH = TorcH<br>THC = TorcH Cuda<br>THCS = TorcH Cuda Sparse (now defunct)<br>THCUNN = TorcH CUda Neural Network (see cunn)<br>THNN = TorcH Neural Network (now defunct)<br>THS = TorcH Sparse (now defunct)<br></td>
                    <td class="tg-0lax">unstable TorcH Cuda Tensor outer dimentions (THTensor_varOuterDim)</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">tensor math</td>
                    <td class="tg-0lax">low level tensor math, variance calculation, GPU</td>
                    <td class="tg-0lax">change variable type</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">Use Accreal variable type instead of real</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">def test_var_stability(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tensor = torch.FloatTensor([2281.5, 2281.25]).cuda()<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Stability for inner dim<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(tensor.var(0)[0], 0.03125)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# General stability<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(tensor.var(), 0.03125)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Stability for outer dimensions<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tensor = tensor.unsqueeze(1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(tensor.var(0)[0], 0.03125)</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">variance</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">246</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">72a257584efa7fb63b14f09d19efc96caa5d6e4d</td>
                    <td class="tg-0lax">Cuda</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">numerical stability</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Log sigmoid is a logistic non-linear activation function. However, typically softmax is prefered over sigmoid</td>
                    <td class="tg-0lax">numerically unstable logsigmoid</td>
                    <td class="tg-0lax">activation functions</td>
                    <td class="tg-0lax">activation functions</td>
                    <td class="tg-0lax">log sigmoid</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite formula for log sigmoid considering the maximum representable values</td>
                    <td class="tg-0lax"> const float fmax =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(float)((int32_t)(uint32_t)qmax - (int32_t)(uint32_t)zero_point);<br><br>const T z = THCNumerics&lt;T&gt;::exp(- *input);<br>-&nbsp;&nbsp;&nbsp;&nbsp;*gradInput = *gradOutput * z / (1.f + z);</td>
                    <td class="tg-0lax">const T max = fmaxType(0.f, -*input);<br>+&nbsp;&nbsp;&nbsp;&nbsp;const T z = THCNumerics&lt;T&gt;::exp(-max) + THCNumerics&lt;T&gt;::exp(-*input -max);<br>+&nbsp;&nbsp;&nbsp;&nbsp;T max_deriv = 0.f;<br>+&nbsp;&nbsp;&nbsp;&nbsp;T sign = -1.f;<br>+&nbsp;&nbsp;&nbsp;&nbsp;if (*input &lt; 0.f){<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_deriv = -1.f;<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sign = 1.f;<br>+&nbsp;&nbsp;&nbsp;&nbsp;}<br>+&nbsp;&nbsp;&nbsp;&nbsp;*gradInput = *gradOutput * (-max_deriv - sign*((z - 1.f)/z));<br>+&nbsp;&nbsp;&nbsp;&nbsp;*gradInput = *gradOutput * (-max_deriv - sign*((z - 1.f)/z));</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">log(1/1+e^(-x))</td>
                    <td class="tg-0lax">log sigmoid</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">247</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">f555c6308c534dd3964d106f2551067fad6edaec</td>
                    <td class="tg-0lax">Cuda, C++</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">numerical stability</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Normalized gradient helps to ameliorate issues with gradient descent such as slow convergenece and getting stuck in saddle points. Normalized gradient is the gradient divided by its magnitude. Therefore, when normalized gradient only provides the direction for gradient descent, but does not affect magnitude of step size. Gradient magnitude is calculated as the square root of sum of squares of the gradient vector.</td>
                    <td class="tg-0lax">normalization operation for gradient is unstable due to sum of squares operation</td>
                    <td class="tg-0lax">gradients/derivatives</td>
                    <td class="tg-0lax">gradients</td>
                    <td class="tg-0lax">gradient normalization</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">in Cuda:<br>grad_mat[index] = (y_ij / x_ij) * (dy_ij - y_ij) * row_sum;<br><br>in C++:<br>gradInMat = ((outputMat / inputMat) * (gradOutMat - outputMat)).rowwise() *<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(gradOutMat * inputMat).colwise().sum();</td>
                    <td class="tg-0lax"> in Cuda:<br>grad_mat[index] = (dy_ij / row_norm) - ((x_ij / row_norm_3) * row_sum);<br><br>in C++:<br>auto square = inputMat.square();<br>&nbsp;&nbsp;auto norm = square.colwise().sum().sqrt();<br>&nbsp;&nbsp;gradInMat = gradOutMat.rowwise() * norm.inverse() -<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((inputMat.rowwise() / norm.pow(3)).rowwise() *<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(gradOutMat * inputMat).colwise().sum());</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">gradient/||gradient||</td>
                    <td class="tg-0lax">sum of squares, square root</td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">248</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">9a153412fd4f78b9a9b59bbf85a358339fb69613</td>
                    <td class="tg-0lax">C++, Python, Cuda</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">underflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Rsample offers a reparametrization trick, where the parameterized random variable can be constructed via a parameterized deterministic function of a parameter-free random variable. The reparameterized sample therefore becomes differentiable. <br>sample and rsample both generate samples from the distribution, but only rsample supports differentiating through the sampler. You should use rsample whenever you need to compute gradients of distribution parameters with respect to functions of samples, e.g. in variational inference. SOURCE: https://forum.pyro.ai/t/sample-vs-rsample/2344<br>sample is literally rsample wrapped in with torch.no_grad(), so when you don't need gradients. SOURCE: https://github.com/cornellius-gp/gpytorch/issues/764<br></td>
                    <td class="tg-0lax">underflow issue in method rsample of dirichlet distribution class</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">statistical distributions</td>
                    <td class="tg-0lax">dirichlet distribution, sampling, forward pass</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">adds a `torch._sample_dirichlet` method in `Distributions.cpp`</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"> def test_beta_underflow(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# For low values of (alpha, beta), the gamma samples can underflow<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# with float32 and result in a spurious mode at 0.5. To prevent this,<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# torch._sample_dirichlet works with double precision for intermediate<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# calculations.<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_rng_seed(1)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num_samples = 50000<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for dtype in [torch.float, torch.double]:<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;conc = torch.tensor(1e-2, dtype=dtype)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;beta_samples = Beta(conc, conc).sample([num_samples])<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual((beta_samples == 0).sum(), 0)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual((beta_samples == 1).sum(), 0)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# assert support is concentrated around 0 and 1<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frac_zeros = float((beta_samples &lt; 0.1).sum()) / num_samples<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frac_ones = float((beta_samples &gt; 0.9).sum()) / num_samples<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(frac_zeros, 0.5, 0.05)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(frac_ones, 0.5, 0.05)<br>+<br>+&nbsp;&nbsp;&nbsp;&nbsp;@unittest.skipIf(not TEST_CUDA, "CUDA not found")<br>+&nbsp;&nbsp;&nbsp;&nbsp;def test_beta_underflow_gpu(self):<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_rng_seed(1)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num_samples = 50000<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;conc = torch.tensor(1e-2, dtype=torch.float64).cuda()<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;beta_samples = Beta(conc, conc).sample([num_samples])<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual((beta_samples == 0).sum(), 0)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual((beta_samples == 1).sum(), 0)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# assert support is concentrated around 0 and 1<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frac_zeros = float((beta_samples &lt; 0.1).sum()) / num_samples<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frac_ones = float((beta_samples &gt; 0.9).sum()) / num_samples<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# TODO: increase precision once imbalance on GPU is fixed.<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(frac_zeros, 0.5, 0.12)<br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(frac_ones, 0.5, 0.12)<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">249</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">74819087de17de4c8215a7f631d8d4d18dd13d45</td>
                    <td class="tg-0lax">C++</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">other</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">Mixed precision training with DDP (distributed data parallelization) randomly hangs. The reason for that is that take_tensors will generate a list of bucketed tensors in an undeterministic order, because the key to the map is a pointer.</td>
                    <td class="tg-0lax">non-standard precision</td>
                    <td class="tg-0lax">non-standard precision</td>
                    <td class="tg-0lax">distributed data parallelization, mixed precision</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use a different algorithm</td>
                    <td class="tg-0lax">use map instead of unordered map&nbsp;&nbsp;to generate an ordered list of bucketed tensors for parallel training</td>
                    <td class="tg-0lax">std::unordered_map&lt;at::Type*, TensorGroup&gt; groups;</td>
                    <td class="tg-0lax">std::map&lt;TypeID, TensorGroup&gt; groups;</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">250</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">73bdb661feb195a8b98366db5750b998c025f709</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Unit test</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">BCELoss's outputs and gradInput computations are accurate to around 1e-6 on float types (as a relative value, not absolute), which is reasonable. However, the tests use absolute thresholds: the accumulation of 5 gradInputs has to have error less than 0.0002.</td>
                    <td class="tg-0lax">loss functions</td>
                    <td class="tg-0lax">loss functions</td>
                    <td class="tg-0lax">binary cross entropy loss, testing precision</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">restrict input to [0.028, 1- 0.028]&nbsp;&nbsp;instead of [0.02, 1- 0.02] to decrease error<br><br>The worse case for BCELoss's gradInput for each element may be described as 1 / ( (1-x) * x ). Previously, the input to the test was restricted to [0.02, 1- 0.02], resulting in worse-case largest gradInput of 50, resulting in a total accumulated grad of 50*5 = 250, resulting in an error of 250 * 1e-6 = 0.00025, which was too big.<br>&nbsp;&nbsp;&nbsp;&nbsp;By restricting x to [0.028, 1- 0.028] we get a worse case of 36.74, resulting in a total accumulated grad of 184, which is less than the 200 needed to have error less than 0.0002.<br></td>
                    <td class="tg-0lax">input_fn=lambda: torch.rand(15, 10).clamp_(2e-2, 1 - 2e-2)</td>
                    <td class="tg-0lax">input_fn=lambda: torch.rand(15, 10).clamp_(2.8e-2, 1 - 2.8e-2),</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">251</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">912ee4e40a9f2f2f156e94a76a521d3ed4f49bd0</td>
                    <td class="tg-0lax">Python</td>
                    <td class="tg-0lax">Unit test</td>
                    <td class="tg-0lax">precision</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">failing unit test</td>
                    <td class="tg-0lax">linear algebra</td>
                    <td class="tg-0lax">linear algebra</td>
                    <td class="tg-0lax">testing, sparse to dense matrix conversion</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax">rewrite math formula</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">elements=st.floats(min_value=0.5, max_value=10), dtype=dt))<br>D = np.random.uniform(0, 1, size=(first_dim,) + X.shape[1:])</td>
                    <td class="tg-0lax"> elements=st.floats(min_value=0, max_value=1), dtype=dt))<br>D = np.zeros((first_dim,) + X.shape[1:])</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                  <tr>
                    <td class="tg-0lax">252</td>
                    <td class="tg-0lax">PyTorch</td>
                    <td class="tg-0lax">b1fa9d2b06714de099e3ae1141d15dcbaba78dd3</td>
                    <td class="tg-0lax">C</td>
                    <td class="tg-0lax">Fix</td>
                    <td class="tg-0lax">overflow</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">THFile is for loading data from disk or memory, but this is no longer part of PyTorch<br></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax">data processing</td>
                    <td class="tg-0lax">data</td>
                    <td class="tg-0lax">data loading</td>
                    <td class="tg-0lax">increase variable precision, add overflow check</td>
                    <td class="tg-0lax">increase variable precision/change variable type</td>
                    <td class="tg-0lax">increase precision to long, add logic to check that smaller than long max</td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                    <td class="tg-0lax"></td>
                  </tr>
                </tbody>
                </table>
    </main>
  </body>
</html>
